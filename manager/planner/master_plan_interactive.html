
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Master Plan Visualization</title>
  <script src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js"></script>
  <script>
    if (typeof d3 === 'undefined') {
        document.write('<script src="d3.min.js" onerror="handleScriptError()"><\/script>');
    }
  </script>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 0; overflow: hidden; background: #f8f9fa; }
    #container { width: 100vw; height: 100vh; display: flex; }
    #viz { flex-grow: 1; height: 100%; position: relative; }
    #sidebar { width: 400px; height: 100vh; background: white; border-left: 1px solid #ddd; padding: 20px; box-sizing: border-box; overflow-y: auto; display: none; box-shadow: -2px 0 5px rgba(0,0,0,0.05); z-index: 10; transform: translateX(0); transition: transform 0.3s ease; }
    
    .node circle { fill: #fff; stroke: steelblue; stroke-width: 2px; cursor: pointer; transition: all 0.3s; }
    .node circle:hover { stroke-width: 4px; }
    .node text { font: 12px sans-serif; cursor: pointer; text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff; }
    
    .link { fill: none; stroke: #ccc; stroke-width: 1.5px; transition: all 0.5s; stroke-opacity: 0.6; }

    .dep-link { fill: none; stroke: #e74c3c; stroke-width: 1.5px; stroke-dasharray: 4; marker-end: url(#arrowhead); opacity: 0.6; }
    .dep-link:hover { opacity: 1.0; stroke-width: 2.5px; }

    /* Metadata Colors */
    .status-done { stroke: #2ecc71 !important; fill: #e8f8f5; }
    .status-active, .status-in-progress { stroke: #3498db !important; fill: #ebf5fb; }
    .status-todo { stroke: #bdc3c7 !important; fill: #fbfcfc; }
    .status-blocked { stroke: #e74c3c !important; fill: #fdedec; }
    
    h2 { margin-top: 0; font-size: 1.5em; color: #2c3e50; }
    .meta-tag { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 0.85em; margin-right: 5px; margin-bottom: 5px; color: white; font-weight: 500;}
    
    .tag-todo { background: #95a5a6; }
    .tag-active, .tag-in-progress { background: #3498db; }
    .tag-done { background: #2ecc71; }
    .tag-blocked { background: #e74c3c; }
    .tag-default { background: #7f8c8d; }

    pre { background: #f4f6f7; padding: 10px; border-radius: 4px; overflow-x: auto; font-size: 0.9em; white-space: pre-wrap; }
    .content-block { line-height: 1.6; color: #34495e; font-size: 0.95em; }

    .control-panel { position: absolute; top: 20px; left: 20px; background: rgba(255, 255, 255, 0.9); padding: 10px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    button { background: #3498db; color: white; border: none; padding: 5px 12px; border-radius: 4px; cursor: pointer; font-size: 13px; margin-right: 5px; }
    button:hover { background: #2980b9; }

    #debug-log { position: absolute; bottom: 10px; left: 10px; font-family: monospace; font-size: 10px; color: #aaa; pointer-events: none; z-index: 100; max-height: 200px; overflow: hidden; }
    #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1.5em; color: #666; background: rgba(255,255,255,0.8); padding: 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
  </style>
</head>
<body>

<div id="container">
  <div id="viz">
    <div id="loading">Initializing...</div>
    <div id="debug-log"></div>
    <svg width="100%" height="100%"></svg>
    <div class="control-panel">
        <button onclick="expandAll()">Expand All</button>
        <button onclick="collapseAll()">Collapse All</button>
        <button onclick="resetZoom()">Reset Zoom</button>
        <button onclick="toggleDeps()">Toggle Dependencies</button>
    </div>
  </div>
  <div id="sidebar">
    <div id="details">
        <h2 style="color: #bbb;">Select a node...</h2>
    </div>
  </div>
</div>

<script>
// Global Variables - Must be declared before use
let root, svg, g, zoom, tree;
let i = 0;
let duration = 500;
let parsedData = null;
let showDependencies = true;

function log(msg) {
    console.log(msg);
    const logDiv = document.getElementById('debug-log');
    if (logDiv) logDiv.innerHTML += msg + "<br>";
}

function handleScriptError() {
    log("ERROR: Failed to load D3.js. Check if d3.min.js exists in the same folder.");
    document.getElementById('loading').innerHTML = "Error: D3.js missing.<br><small>Ensure d3.min.js is in the folder.</small>";
}

// Base64 Decode
function decodeData(enc) {
    try {
        log("Decoding data...");
        const jsonStr = new TextDecoder().decode(Uint8Array.from(atob(enc), c => c.charCodeAt(0)));
        log("Data decoded. Length: " + jsonStr.length);
        return JSON.parse(jsonStr);
    } catch(e) {
        log("Decoding error: " + e.message);
        document.getElementById('loading').innerText = "Error decoding data";
        return null;
    }
}

// Data Injection
try {
    const rawData = "eyJ0cmVlIjogeyJ0aXRsZSI6ICJNYXN0ZXIgUGxhbjogSW50ZWxsaWdlbnQgQ29udHJvbCBTYWFTIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAicGxhbiIsICJpZCI6ICJtYXN0ZXJfcGxhbi5zYWFzIiwgIm93bmVyIjogInByb2R1Y3QtbWFuYWdlciIsICJwcmlvcml0eSI6ICJjcml0aWNhbCIsICJjb250ZXh0X2RlcGVuZGVuY2llcyI6IHsibWFuYWdlciI6ICJNQU5BR0VSX0FHRU5ULm1kIiwgImNvbnZlbnRpb25zIjogIi4uLy4uL01EX0NPTlZFTlRJT05TLm1kIn0sICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QxNToxNDoyNSswMTowMCJ9LCAiY29udGVudCI6ICJUaGlzIGRvY3VtZW50IHNlcnZlcyBhcyB0aGUgY2VudHJhbCBzdHJhdGVnaWMgcGxhbiBmb3IgdGhlICoqSW50ZWxsaWdlbnQgQ29udHJvbCAmIEFuYWx5c2lzIFBsYXRmb3JtKiouIEl0IGlzIGEgZHVhbC1lbmdpbmUgQUkgc3lzdGVtIGZ1bmN0aW9uaW5nIGFzIGJvdGggYSAqKkJ1c2luZXNzIEFuYWx5c3QqKiBhbmQgYW4gKipBdXRvbm9tb3VzIE9wZXJhdG9yKiogZm9yIFNNQnMgYW5kIGluZHVzdHJpYWwgY2xpZW50cy4gSXQgY29tYmluZXMgTExNIHJlYXNvbmluZyAoQW5hbHlzaXMpIHdpdGggUkwgY29udHJvbCAoT3B0aW1pemF0aW9uKS4iLCAiY2hpbGRyZW4iOiBbeyJ0aXRsZSI6ICJFeGVjdXRpdmUgU3VtbWFyeSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImRvbmUiLCAidHlwZSI6ICJjb250ZXh0IiwgImlkIjogInByb2R1Y3Quc2Fhcy5zdW1tYXJ5IiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTIzVDEzOjQ3OjA3KzAxOjAwIn0sICJjb250ZW50IjogIioqVGhlIFZpc2lvbioqOiBUbyBlbXBvd2VyIGV2ZXJ5IFNNQiB3aXRoIGEgRm9ydHVuZSA1MDAtZ3JhZGUgRGF0YSBTY2llbmNlICYgT3BlcmF0aW9ucyB0ZWFtXHUyMDE0aW5zdGFudGx5LiBXZSBicmlkZ2UgdGhlIGdhcCBiZXR3ZWVuIHJhdyBkYXRhIGFuZCBwcm9maXRhYmxlIGFjdGlvbiBieSBjb21iaW5pbmcgbmF0dXJhbCBsYW5ndWFnZSBpbnR1aXRpb24gd2l0aCByaWdvcm91cyBtYXRoZW1hdGljYWwgaW1wbGVtZW50YXRpb24uXG5cbioqVGhlIFByb2JsZW0qKjogU21hbGwgYW5kIG1pZC1zaXplZCBidXNpbmVzc2VzIChTTUJzKSBhY3Jvc3MgUmV0YWlsIGFuZCBMb2dpc3RpY3MgYXJlIGRyb3duaW5nIGluIHNwcmVhZHNoZWV0cy4gVGhleSBmYWNlIGNvbXBsZXggaW52ZW50b3J5IGRpbGVtbWFzIGFuZCBvcGVyYXRpb25hbCBpbmVmZmljaWVuY2llcyBidXQgY2Fubm90IGFmZm9yZCBhIGRlZGljYXRlZCBEYXRhIFNjaWVuY2UgdGVhbS4gVGhleSBvcGVyYXRlIG9uIFwiZ3V0IGZlZWxpbmdcIiByYXRoZXIgdGhhbiBvcHRpbWFsIGNvbnRyb2wuXG5cbioqVGhlIFNvbHV0aW9uKio6IEFuICoqSW50ZWxsaWdlbnQgQ29udHJvbCBTYWFTKiogdGhhdCBmdW5jdGlvbnMgYXMgYSBkdWFsLWVuZ2luZSBBSSBwYXJ0bmVyOlxuMS4gICoqVGhlIFwiVmlydHVhbCBDaGllZiBBbmFseXN0XCIgKFVuZGVyc3RhbmRpbmcpKio6IEEgQ29kZSBJbnRlcnByZXRlciBhZ2VudCB0aGF0IHR1cm5zIFwiV2h5IGFyZSBzYWxlcyBkb3duP1wiIGludG8gaW5zdGFudCwgdmlzdWFsaXplZCwgc3RhdGlzdGljYWwgdHJ1dGhcdTIwMTRub3QganVzdCB0ZXh0IHN1bW1hcmllcy5cbjIuICAqKlRoZSBcIkF1dG9ub21vdXMgT3BlcmF0b3JcIiAoQWN0aW9uKSoqOiBBbiBSTC1kcml2ZW4gQ29udHJvbGxlciB0aGF0IHR1cm5zIFwiT3B0aW1pemUgbXkgc3RvY2tcIiBpbnRvIHByZWNpc2UsIGV4ZWN1dGVkIGFjdGlvbnMsIHNvbHZpbmcgY29tcGxleCBtYXRoIChsaWtlIHRoZSBOZXdzdmVuZG9yIHByb2JsZW0pIHRvIG1heGltaXplIGNhc2ggZmxvdyBhbmQgbWluaW1pemUgd2FzdGUuXG5cbioqTWFya2V0IFZhbHVlKio6XG4qICAgKipEZW1vY3JhdGl6YXRpb24qKjogQWNjZXNzIHRvIGFkdmFuY2VkIGFuYWx5dGljcyAoVGltZS1zZXJpZXMgZm9yZWNhc3RpbmcsIEh5cG90aGVzaXMgdGVzdGluZykgdmlhIGEgc2ltcGxlIGNoYXQgaW50ZXJmYWNlLlxuKiAgICoqT3BlcmF0aW9uYWwgRXhjZWxsZW5jZSoqOiBUcmFuc2l0aW9uaW5nIGNsaWVudHMgZnJvbSAqcmVhY3RpdmUqIGZpcmUtZmlnaHRpbmcgdG8gKnByb2FjdGl2ZSosIG1hdGhlbWF0aWNhbGx5IG9wdGltYWwgaW52ZW50b3J5IG1hbmFnZW1lbnQuXG4qICAgKipIeWJyaWQgQXJjaGl0ZWN0dXJlKio6IEEgcHJpdmFjeS1jb25zY2lvdXMgTG9jYWwgTmV4dXMgZm9yIGRhaWx5IHdvcmssIGNvbm5lY3RlZCB0byBhIHNjYWxhYmxlIENsb3VkIEJyYWluIGZvciBoZWF2eSBjb21wdXRhdGlvbi4iLCAiY2hpbGRyZW4iOiBbXX0sIHsidGl0bGUiOiAiTWVldGluZyBOb3RlcyIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImFjdGl2ZSIsICJ0eXBlIjogImxvZyIsICJpZCI6ICJwbGFubmVyLm1lZXRpbmdfbm90ZXMudG9wIiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTI1VDE3OjQ3OjAwKzAxOjAwIn0sICJjb250ZW50IjogIkhpc3RvcmljYWwgbG9nIG9mIG1lZXRpbmdzIGFuZCBjb29yZGluYXRpb24gd2l0aCBjb2xsZWFndWVzLiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIjIwMjYtMDEtMjUgLSBTZXR0aW5nIHRoZSBJbnRlbGxpZ2VudCBDb250cm9sIFNhYVMgUm9hZG1hcCIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJsb2ciLCAicGFydGljaXBhbnRzIjogWyJcIklnbmFjaW9cIiIsICJcIkZyYW5cIiJdLCAiaWQiOiAicGxhbm5lci5tZWV0aW5nLjIwMjYwMTI1LnJvYWRtYXAiLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjVUMTc6NDU6MDArMDE6MDAifSwgImNvbnRlbnQiOiAiKipBZ2VuZGE6Kipcbi0gVW5kZXJzdGFuZCBQbGFubmluZyBUb29scyBhbmQgTWFzdGVyIFBsYW5cbi0gQ2xvdWQgU2l0dWF0aW9uOiBpcyBzbmFrZSB1cD9cbi0gR2l0YWNjZXNzP1xuLSBSZWFjdCB2cyBQeXRob25cbi0gTmV4dCBzdGVwc1xuXG4qKkRpc2N1c3Npb246Kipcbi0gVGVtYSBjZW50cmFsaXphY2lvbjogVXBzdHJlYW0gdnMgRG93bnN0cmVhbVxuLSBGcmFuIHNlIGhhY2UgY2FyZ28gZGVsIG5vZG8gUGhhc2UgMiBkZWwgTWFzdGVyIFBsYW4uXG4tIEhhY2VyIHNjaXB0IHF1ZSBtYXBlZSBsYXMgZGVwZW5kZW5jaWFzLlxuLSBWYW1vcyBhIHVzYXIgUmVhY3QuXG4tIERhcmxlIGFjY2VzbyBhIGxvcyByZXBvc2l0b3Jpb3MgZGUgZ2l0LlxuLSBFbiBsb3MgcHJvamVjdCBzZXR1cCBndWlkZWxpbmVzLCBhY2xhcmFybGUgYWwgYWdlbnRlIHF1ZSBpbmNsdXlhIHVuIC5naXRpZ25vcmUgdGlwaWNvIGEgbG9zIGxlbmd1YWplcyBxdWUgc2UgbWFuYWplbi5cbi0gaGFibGFtb3MgbGEgZmFzZSAzLCBhY29yZGFtb3MgcXVlIHZpZW5lIGRlc3B1ZXMgZGUgbGFzIHByaW1lcmFzIGRvcyBmYXNlcy5cbi0gVm9sdmlvIGVsIHRlbWEgc2VndXJpZGFkLCBwZXJvIGxvIGRlamFtb3MgcGFyYSBhZGVsYW50ZSBlbiBsYSBmYXNlIDIuXG4tIEFncmVnYW1vcyBjb3NhcyBhIHN0YXR1cy5cblxuKipBY3Rpb24gSXRlbXM6Kipcbi0gUXVlIEZyYW4gYXZhbmNlIGNvbiBQaGFzZSAyOiBUaGUgQ2xvdWQgQnJpZGdlIHRvZG8gbG8gcXVlIHB1ZWRhLiBFbiBwYXJ0aWN1bGFyLCBwb2RlciBqdWdhciBhbCBzbmFrZSBkZXNkZSBudWVzdHJvcyBzZXJ2ZXJzIGVuIGxhIG51YmUuXG4tIFF1ZSBJZ25hY2lvIGF2YW5jZSBjb24gUGhhc2UgMTogTG9jYWwgTmV4dXMgdG9kbyBsbyBxdWUgcHVlZGEuXG4tIEVuIGxvcyBwcm9qZWN0IHNldHVwIGd1aWRlbGluZXMsIGFjbGFyYXJsZSBhbCBhZ2VudGUgcXVlIGluY2x1eWEgdW4gLmdpdGlnbm9yZSB0aXBpY28gYSBsb3MgbGVuZ3VhamVzIHF1ZSBzZSBtYW5hamVuLlxuLSBIYWNlciBzY2lwdCBxdWUgbWFwZWUgbGFzIGRlcGVuZGVuY2lhcy4iLCAiY2hpbGRyZW4iOiBbXX1dfSwgeyJ0aXRsZSI6ICJUZWNobmljYWwgQXJjaGl0ZWN0dXJlIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAicGxhbiIsICJpZCI6ICJwcm9kdWN0LnNhYXMuYXJjaCIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QxMzo0NzowNyswMTowMCJ9LCAiY29udGVudCI6ICJUaGUgc3lzdGVtIHNlcGFyYXRlcyBBbmFseXRpY2FsIFF1ZXJpZXMgKENvZGUgRXhlY3V0aW9uKSBmcm9tIENvbnRyb2wgVGFza3MgKE1vZGVsIEluZmVyZW5jZSkuIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiQ29yZSBDb21wb25lbnRzIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAiY29udGV4dCIsICJpZCI6ICJwcm9kdWN0LnNhYXMuYXJjaC5jb21wb25lbnRzIiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTIzVDEzOjQ3OjA3KzAxOjAwIn0sICJjb250ZW50IjogIiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIkNoYXRib3QgQXNzaXN0YW50IEFwcCIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImFjdGl2ZSIsICJ0eXBlIjogImNvbnRleHQiLCAiaWQiOiAicHJvZHVjdC5zYWFzLmFyY2guY29tcG9uZW50cy5jaGF0Ym90IiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTIzVDE5OjQ3OjMxKzAxOjAwIn0sICJjb250ZW50IjogIlNlcnZlcyBhcyB0aGUgcHJpbWFyeSBpbnRlcmZhY2UgZm9yIHVzZXJzLCBmdW5jdGlvbmluZyBzaW11bHRhbmVvdXNseSBhcyBhIG1lY2hhbmlzbSBmb3IgaW50ZXJhY3Rpb24gYW5kIGEgbG9jYWwgZGF0YSB3YXJlaG91c2UuIEl0IGZhY2lsaXRhdGVzIGRhdGEgY29sbGVjdGlvbiBhbmQgdXNlciBpbnRlbnQgY2FwdHVyZS4iLCAiY2hpbGRyZW4iOiBbXX0sIHsidGl0bGUiOiAiSW50ZXJuYWwgRWNvc3lzdGVtIG9mIEFJLUFzc2lzdGFudHMiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJhY3RpdmUiLCAidHlwZSI6ICJjb250ZXh0IiwgImlkIjogInByb2R1Y3Quc2Fhcy5hcmNoLmNvbXBvbmVudHMuZWNvc3lzdGVtIiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTIzVDE5OjQ3OjMxKzAxOjAwIn0sICJjb250ZW50IjogIkEgYmFja2dyb3VuZCBvcmNoZXN0cmF0aW9uIGxheWVyIHdoZXJlIG11bHRpcGxlIHNwZWNpYWxpemVkIEFJIGFnZW50cyBjb2xsYWJvcmF0ZS4gVGhlc2UgYWdlbnRzIGFyZSBpbnRlcm5hbC1vbmx5IGFuZCBoYW5kbGUgc3BlY2lmaWMgc3ViLXRhc2tzIHRvIGVuc3VyZSBzZWFtbGVzcyBzeXN0ZW0gb3BlcmF0aW9uLiIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJDbG91ZCBJbmZyYXN0cnVjdHVyZSAoQmlnUXVlcnkgJiBDb21wdXRlKSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImFjdGl2ZSIsICJ0eXBlIjogImNvbnRleHQiLCAiaWQiOiAicHJvZHVjdC5zYWFzLmFyY2guY29tcG9uZW50cy5jbG91ZCIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QxOTo0NzozMSswMTowMCJ9LCAiY29udGVudCI6ICJUaGUgc2NhbGFibGUgYmFja2JvbmUgb2YgdGhlIHBsYXRmb3JtLiBJdCBpbmNsdWRlcyAqKkdvb2dsZSBCaWdRdWVyeSoqIGZvciBtYXNzaXZlIGRhdGEgd2FyZWhvdXNpbmcgYW5kICoqR29vZ2xlIENsb3VkIENvbXB1dGUqKiBmb3IgcGVyZm9ybWFudCBwcm9jZXNzaW5nLCBlbnN1cmluZyByZWxpYWJpbGl0eSBhbmQgc3BlZWQuIiwgImNoaWxkcmVuIjogW119LCB7InRpdGxlIjogIkludGVybmFsIEFsZ29yaXRobXMgUmVwb3NpdG9yeSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImFjdGl2ZSIsICJ0eXBlIjogImNvbnRleHQiLCAiaWQiOiAicHJvZHVjdC5zYWFzLmFyY2guY29tcG9uZW50cy5hbGdvcml0aG1zIiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTIzVDE5OjQ3OjMxKzAxOjAwIn0sICJjb250ZW50IjogIlRoZSBjZW50cmFsIGxpYnJhcnkgb2YgZGF0YSBwcm9jZXNzaW5nIGFuZCBjb250cm9sIGFsZ29yaXRobXMuIFRoaXMgbGV2ZXJhZ2VzICoqVmVydGV4IEFJKiogZm9yIGFkdmFuY2VkIGRhdGEgc2NpZW5jZSBtb2RlbGluZyBhbmQgb3B0aW1pemF0aW9uIHRhc2tzLCByZXByZXNlbnRpbmcgdGhlIGNvcmUgaW50ZWxsZWN0dWFsIHByb3BlcnR5IG9mIHRoZSBhbmFseXNpcyBlbmdpbmUuIiwgImNoaWxkcmVuIjogW119XX0sIHsidGl0bGUiOiAiSW5mb3JtYXRpb24gRmxvdyIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImFjdGl2ZSIsICJ0eXBlIjogImNvbnRleHQiLCAiaWQiOiAicHJvZHVjdC5zYWFzLmFyY2guZmxvdyIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QxMzo0NzowNyswMTowMCJ9LCAiY29udGVudCI6ICIiLCAiY2hpbGRyZW4iOiBbeyJ0aXRsZSI6ICJBSSBBc3Npc3RhbnQgT3JjaGVzdHJhdGlvbiIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImFjdGl2ZSIsICJ0eXBlIjogImNvbnRleHQiLCAiaWQiOiAicHJvZHVjdC5zYWFzLmFyY2guZmxvdy5vcmNoZXN0cmF0aW9uIiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTIzVDE1OjI4OjU5KzAxOjAwIn0sICJjb250ZW50IjogIlVzZXIgaW50ZXJhY3Rpb24gYmVnaW5zIHdpdGggdGhlIENoYXRib3QgQXBwLCB3aGljaCBmb3J3YXJkcyByZXF1ZXN0cyB0byB0aGUgT3JjaGVzdHJhdG9yIChWZXJ0ZXggQUkpLlxuMS4gICoqSW50ZW50IFJlY29nbml0aW9uKio6IFRoZSBPcmNoZXN0cmF0b3IgZGV0ZXJtaW5lcyBpZiB0aGUgcmVxdWVzdCBpcyAqKkFuYWx5c2lzKiogKGluZm9ybWF0aW9uYWwpIG9yICoqQ29udHJvbCoqIChhY3Rpb25hYmxlKS5cbjIuICAqKlJvdXRpbmcqKjpcbiAgICAqICAgKipBbmFseXNpcyoqOiBSb3V0ZWQgdG8gQ29kZSBJbnRlcnByZXRlciAvIEFuYWx5c3QgQWdlbnQgZm9yIGRhdGEgcXVlcnlpbmcgYW5kIHZpc3VhbGl6YXRpb24uXG4gICAgKiAgICoqQ29udHJvbCoqOiBSb3V0ZWQgdG8gUGxhbm5lciAvIFJMIEFnZW50IGZvciBvcHRpbWl6YXRpb24gYW5kIGRlY2lzaW9uIG1ha2luZy5cbjMuICAqKlJlc3BvbnNlKio6IFJlc3VsdHMgYXJlIGFnZ3JlZ2F0ZWQgYW5kIHJldHVybmVkIHRvIHRoZSBDaGF0Ym90IGFzIG5hdHVyYWwgbGFuZ3VhZ2Ugb3IgVUkgY29tcG9uZW50cy4iLCAiY2hpbGRyZW4iOiBbXX0sIHsidGl0bGUiOiAiQ29udHJvbCBMb29wIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAiY29udGV4dCIsICJpZCI6ICJwcm9kdWN0LnNhYXMuYXJjaC5mbG93LmNvbnRyb2wiLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjNUMTU6Mjg6NTkrMDE6MDAifSwgImNvbnRlbnQiOiAiVGhpcyBoaWdoLWZyZXF1ZW5jeSBsb29wIGhhbmRsZXMgdGhlIGF1dG9ub21vdXMgb3B0aW1pemF0aW9uIHN5c3RlbTpcbjEuICAqKlRlbGVtZXRyeSBJbmdlc3QqKjogUmF3IGRhdGEgc3RyZWFtcyBmcm9tIHRoZSBDbGllbnQgQXBwL1dhcmVob3VzZSBhcmUgaW5nZXN0ZWQgaW50byBCaWdRdWVyeS5cbjIuICAqKlN0YXRlIEVzdGltYXRpb24qKjogUHJvY2Vzc2luZyBhbGdvcml0aG1zIGNvbnZlcnQgcmF3IHRlbGVtZXRyeSBpbnRvIHN0YXRlIHZlY3RvcnMgKCRzX3QkKSBzdWl0YWJsZSBmb3IgbW9kZWwgaW5wdXQuXG4zLiAgKipEZWNpc2lvbioqOiBUaGUgUG9saWN5IG5ldHdvcmsgKCRcXHBpJCkgb3IgUGxhbmVyIHNlbGVjdHMgdGhlIG9wdGltYWwgYWN0aW9uICgkYV90JCkgYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGUuXG40LiAgKipFeGVjdXRpb24gJiBGZWVkYmFjayoqOiBUaGUgYWN0aW9uIGlzIHNlbnQgdG8gdGhlIENvbnRyb2xsZXIgZm9yIGV4ZWN1dGlvbiwgYW5kIHRoZSBvdXRjb21lIGlzIHJlY29yZGVkIGZvciBvZmZsaW5lIHJlLXRyYWluaW5nIGFuZCByZWZpbmVtZW50LiIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJIdW1hbi1BSSBJbnRlcmFjdGlvbiIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImFjdGl2ZSIsICJ0eXBlIjogImNvbnRleHQiLCAiaWQiOiAicHJvZHVjdC5zYWFzLmFyY2guZmxvdy5odW1hbl9haSIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QxOTo1MTowNyswMTowMCJ9LCAiY29udGVudCI6ICJEZWZpbmVzIHRoZSBwcm90b2NvbHMgZm9yIGhvdyBodW1hbnMgaW50ZXJhY3Qgd2l0aCB0aGUgQUkgYWdlbnRzLiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIkRldmVsb3Blci1BSSBJbnRlcmFjdGlvbiIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImFjdGl2ZSIsICJ0eXBlIjogInByb3RvY29sIiwgImlkIjogInByb2R1Y3Quc2Fhcy5hcmNoLmZsb3cuaHVtYW5fYWkuZGV2ZWxvcGVyIiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTIzVDE5OjUxOjA3KzAxOjAwIn0sICJjb250ZW50IjogIlByb3RvY29sIGZvciBkZXZlbG9wZXJzIHRvIGNvbmZpZ3VyZSwgdHJhaW4sIGFuZCBkZWJ1ZyBhZ2VudHMuIEludm9sdmVzIGRpcmVjdCBhY2Nlc3MgdG8gaW50ZXJuYWwgbG9ncywgbW9kZWwgd2VpZ2h0cywgYW5kIHRoZSAnQW5hbHlzaXMgU2FuZGJveCcgZm9yIHNhZmUgY29kZSB0ZXN0aW5nLiIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJDbGllbnQtQUkgSW50ZXJhY3Rpb24iLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJhY3RpdmUiLCAidHlwZSI6ICJwcm90b2NvbCIsICJpZCI6ICJwcm9kdWN0LnNhYXMuYXJjaC5mbG93Lmh1bWFuX2FpLmNsaWVudCIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QxOTo1MTowNyswMTowMCJ9LCAiY29udGVudCI6ICJQcm90b2NvbCBmb3IgZW5kLXVzZXJzLiBSZXN0cmljdGVkIHRvIG5hdHVyYWwgbGFuZ3VhZ2UgdmlhIHRoZSBDaGF0Ym90IEFwcC4gTm8gZGlyZWN0IGNvZGUgZXhlY3V0aW9uIGFsbG93ZWQuIEludGVudCBpcyBwYXJzZWQgYnkgdGhlIE9yY2hlc3RyYXRvci4iLCAiY2hpbGRyZW4iOiBbXX1dfSwgeyJ0aXRsZSI6ICJBSS1Ub29scyBQcm90b2NvbHMiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJhY3RpdmUiLCAidHlwZSI6ICJwcm90b2NvbCIsICJpZCI6ICJwcm9kdWN0LnNhYXMuYXJjaC5mbG93LnRvb2xzIiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTIzVDE5OjUxOjA3KzAxOjAwIn0sICJjb250ZW50IjogIlByb3RvY29scyBmb3IgaG93IEFJIGFnZW50cyB1dGlsaXplIGV4dGVybmFsIHNvZnR3YXJlIGFuZCBBUElzLiBBZGhlcmVzIHRvIHRoZSAqKk1vZGVsIENvbnRleHQgUHJvdG9jb2wgKE1DUCkqKiB0byBzdGFuZGFyZGl6ZSB0b29sIGRlZmluaXRpb24sIGRpc2NvdmVyeSwgYW5kIGV4ZWN1dGlvbi4iLCAiY2hpbGRyZW4iOiBbXX1dfSwgeyJ0aXRsZSI6ICJLbm93bGVkZ2UgQmFzZXMiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJhY3RpdmUiLCAidHlwZSI6ICJjb250ZXh0IiwgImlkIjogInByb2R1Y3Quc2Fhcy5hcmNoLmtub3dsZWRnZSIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QyMDowMDowMCswMTowMCJ9LCAiY29udGVudCI6ICJSZXBvc2l0b3J5IHJlc291cmNlcyBjYXRlZ29yaXplZCBieSB0aGVpciBmdW5jdGlvbi4iLCAiY2hpbGRyZW4iOiBbeyJ0aXRsZSI6ICJBZ2VudGljIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAiY29udGV4dCIsICJpZCI6ICJwcm9kdWN0LnNhYXMuYXJjaC5rbm93bGVkZ2UuYWdlbnRpYyIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QyMDowMDowMCswMTowMCJ9LCAiY29udGVudCI6ICItIFtNQU5BR0VSX0FHRU5UXShNQU5BR0VSX0FHRU5ULm1kKVxuLSBbQ0xFQU5FUl9BR0VOVF0oLi4vY2xlYW5lci9DTEVBTkVSX0FHRU5ULm1kKVxuLSBbUkVBQ1RfQVNTSVNUQU5UXSguLi8uLi9BSV9BR0VOVFMvc3BlY2lhbGlzdHMvUkVBQ1RfQVNTSVNUQU5ULm1kKVxuLSBbUkVDU1lTX0FHRU5UXSguLi8uLi9BSV9BR0VOVFMvc3BlY2lhbGlzdHMvUkVDU1lTX0FHRU5ULm1kKVxuLSBbQ09OVFJPTF9BR0VOVF0oLi4vLi4vQUlfQUdFTlRTL3NwZWNpYWxpc3RzL0NPTlRST0xfQUdFTlQubWQpXG4tIFtVSV9ERVNJR19BU1NJU1RBTlRdKC4uLy4uL0FJX0FHRU5UUy9zcGVjaWFsaXN0cy9VSV9ERVNJR19BU1NJU1RBTlQubWQpXG4tIFtMSU5FQVJJWkVfQUdFTlRdKC4uLy4uL0FJX0FHRU5UUy9zcGVjaWFsaXN0cy9MSU5FQVJJWkVfQUdFTlQubWQpXG4tIFtNQ19BR0VOVF0oLi4vLi4vQUlfQUdFTlRTL3NwZWNpYWxpc3RzL01DX0FHRU5ULm1kKVxuLSBbQ0xPVURfU0NIRURVTEVSX0FHRU5UXSguLi8uLi9BSV9BR0VOVFMvc3BlY2lhbGlzdHMvQ0xPVURfU0NIRURVTEVSX0FHRU5ULm1kKSIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJLbm93bGVkZ2UiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJhY3RpdmUiLCAidHlwZSI6ICJjb250ZXh0IiwgImlkIjogInByb2R1Y3Quc2Fhcy5hcmNoLmtub3dsZWRnZS5nZW5lcmFsIiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTIzVDIwOjAwOjAwKzAxOjAwIn0sICJjb250ZW50IjogIi0gW1JFQURNRV0oLi4vLi4vUkVBRE1FLm1kKVxuLSBbTURfQ09OVkVOVElPTlNdKC4uLy4uL01EX0NPTlZFTlRJT05TLm1kKVxuLSBbQUdFTlRTXSguLi8uLi9BR0VOVFMubWQpXG4tIFtBR0VOVFNfTE9HXSguLi8uLi9BR0VOVFNfTE9HLm1kKVxuLSBbREFHX0V4YW1wbGVdKC4uLy4uL2xhbmd1YWdlL2V4YW1wbGUvREFHX0V4YW1wbGUubWQpIiwgImNoaWxkcmVuIjogW119XX1dfSwgeyJ0aXRsZSI6ICJJbXBsZW1lbnRhdGlvbiBSb2FkbWFwIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAicGxhbiIsICJpZCI6ICJwcm9kdWN0LnNhYXMucm9hZG1hcCIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QyMTo0NDoyMyswMTowMCJ9LCAiY29udGVudCI6ICJUaGlzIHJvYWRtYXAgc3RyaXBzIGF3YXkgZW50ZXJwcmlzZSBjb21wbGV4aXR5IHRvIGZvY3VzIG9uIHRoZSBjb3JlIHZhbHVlIHByb3Bvc2l0aW9uOiBhIGxvY2FsIGFwcCB0aGF0IGFjdHMgYXMgYSBkYXRhIGh1YiBhbmQgYSBjaGF0IGludGVyZmFjZSwgY29ubmVjdGVkIHRvIHBvd2VyZnVsIGNsb3VkIGFnZW50cyBmb3IgZXhlY3V0aW9uLiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIlBoYXNlIDE6IExvY2FsIE5leHVzIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAicGxhbiIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTEiLCAib3duZXIiOiAidXNlciIsICJwcmlvcml0eSI6ICJjcml0aWNhbCIsICJlc3RpbWF0ZSI6ICI0dyIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yNFQxMTo1NDowMCswMTowMCJ9LCAiY29udGVudCI6ICJUaGlzIGRvY3VtZW50IG91dGxpbmVzIHRoZSB0YWN0aWNhbCBleGVjdXRpb24gcGxhbiBmb3IgYnVpbGRpbmcgdGhlICoqTG9jYWwgTmV4dXMqKiwgdGhlIGNsaWVudC1zaWRlIGFwcGxpY2F0aW9uIG9mIHRoZSBJbnRlbGxpZ2VudCBDb250cm9sIFNhYVMuXG5cbioqT2JqZWN0aXZlKio6IENyZWF0ZSBhIHNlbGYtY29udGFpbmVkIGxvY2FsIGFwcGxpY2F0aW9uIHRoYXQgZnVuY3Rpb25zIGFzOlxuMS4gKipEYXRhIFdhcmVob3VzZSoqOiBJbmdlc3RzIGFuZCBzdHJ1Y3R1cmVzIHJhdyBDU1YvRXhjZWwgZmlsZXMgbG9jYWxseSAoRHVja0RCKS5cbjIuICoqSW50ZXJmYWNlKio6IEEgY2hhdC1iYXNlZCBVSSBmb3IgcXVlcnlpbmcgdGhhdCBkYXRhIChTdHJlYW1saXQpLlxuXG4qKlRlY2ggU3RhY2sgU2VsZWN0aW9uKio6XG4qICoqTGFuZ3VhZ2UqKjogUHl0aG9uIDMuMTArXG4qICoqRnJvbnRlbmQqKjogU3RyZWFtbGl0IChDaG9zZW4gZm9yIHJhcGlkIGl0ZXJhdGlvbiBhbmQgbmF0aXZlIGRhdGEgc3VwcG9ydCkuXG4qICoqRGF0YWJhc2UqKjogRHVja0RCIChFbWJlZGRlZCBPTEFQLCB6ZXJvLWRlcGVuZGVuY3ksIFNRTCBjb21wYXRpYmxlKS5cbioqVGVjaCBTdGFjayBTZWxlY3Rpb24qKjpcbiogKipMYW5ndWFnZSoqOiBQeXRob24gMy4xMCtcbiogKipGcm9udGVuZCoqOiBTdHJlYW1saXQgKENob3NlbiBmb3IgcmFwaWQgaXRlcmF0aW9uIGFuZCBuYXRpdmUgZGF0YSBzdXBwb3J0KS5cbiogKipEYXRhYmFzZSoqOiBEdWNrREIgKEVtYmVkZGVkIE9MQVAsIHplcm8tZGVwZW5kZW5jeSwgU1FMIGNvbXBhdGlibGUpLlxuKiAqKkRhdGEgUHJvY2Vzc2luZyoqOiBQYW5kYXMgLyBQb2xhcnMuXG4qICoqQWdlbnQgRnJhbWV3b3JrKio6ICoqR29vZ2xlIEFESyAoTG9jYWwgTW9kZSkqKi4gRXZlbiBpbiBQaGFzZSAxLCB3ZSB3aWxsIHN0cnVjdHVyZSBcIk1vY2sgdG9vbHNcIiB1c2luZyB0aGUgQURLIHBhdHRlcm4gKFB5dGhvbiBmdW5jdGlvbnMgKyB0eXBlIGhpbnRzKSB0byBtYWtlIHRoZSB0cmFuc2l0aW9uIHRvIFBoYXNlIDMgc2VhbWxlc3MuIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiUHJvamVjdCBJbml0aWFsaXphdGlvbiAmIFN0cnVjdHVyZSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImRvbmUiLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMS5pbml0IiwgImVzdGltYXRlIjogIjFkIiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTI0VDExOjU4OjAwKzAxOjAwIn0sICJjb250ZW50IjogIkVzdGFibGlzaCB0aGUgcmVwb3NpdG9yeSBzdHJ1Y3R1cmUgdG8gc3VwcG9ydCBtb2R1bGFyIGdyb3d0aCBpbnRvIFBoYXNlcyAyIGFuZCAzLlxuXG4qKkRpcmVjdG9yeSBTdHJ1Y3R1cmUqKjpcbmBgYFxuL3NyY1xuICAvYXBwLnB5ICAgICAgICAgICAgIyBNYWluIFN0cmVhbWxpdCBlbnRyeSBwb2ludFxuICAvY29yZVxuICAgIC9kYXRhYmFzZS5weSAgICAgIyBEdWNrREIgc2luZ2xldG9uIHdyYXBwZXJcbiAgICAvaW5nZXN0aW9uLnB5ICAgICMgRmlsZSBwcm9jZXNzaW5nIGxvZ2ljXG4gIC9jb21wb25lbnRzXG4gICAgL2NoYXQucHkgICAgICAgICAjIFVJIGNvbXBvbmVudCBmb3IgY2hhdCBoaXN0b3J5XG4gICAgL3NpZGViYXIucHkgICAgICAjIFVJIGNvbXBvbmVudCBmb3IgZmlsZSBtYW5hZ2VtZW50XG4gIC91dGlsc1xuICAgIC9sb2dnZXIucHkgICAgICAgIyBUZWxlbWV0cnkgbG9nZ2luZyAoZm9yIGZ1dHVyZSBSTClcbi90ZXN0cyAgICAgICAgICAgICAgICMgVW5pdCBhbmQgaW50ZWdyYXRpb24gdGVzdHNcbi9kYXRhXG4gIC9yYXcgICAgICAgICAgICAgICAjIFN0YWdpbmcgYXJlYSBmb3IgdXNlciB1cGxvYWRzXG4gIC93YXJlaG91c2UuZGIgICAgICAjIFBlcnNpc3RlbnQgRHVja0RCIGZpbGVcbmBgYCIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJNb2R1bGUgMTogVGhlIExvY2FsIERhdGEgV2FyZWhvdXNlIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiZG9uZSIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLndhcmVob3VzZSIsICJibG9ja2VkX2J5IjogWyJpbXBsZW1lbnRhdGlvbi5waGFzZTEuaW5pdCJdLCAiZXN0aW1hdGUiOiAiMXciLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjRUMTE6NTQ6MDArMDE6MDAifSwgImNvbnRlbnQiOiAiSW1wbGVtZW50IHRoZSBwZXJzaXN0ZW5jZSBsYXllciB1c2luZyBEdWNrREIuIFRoaXMgaXMgdGhlIFwiTG9uZy1UZXJtIE1lbW9yeVwiIG9mIHRoZSBzeXN0ZW0uIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiRGF0YWJhc2UgTWFuYWdlciBDbGFzcyIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImRvbmUiLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMS53YXJlaG91c2UubWFuYWdlciIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yNFQxMTo1NDowMCswMTowMCJ9LCAiY29udGVudCI6ICJDcmVhdGUgYSBEYXRhYmFzZU1hbmFnZXIgY2xhc3MgaW4gc3JjL2NvcmUvZGF0YWJhc2UucHkuXG5cbiogKipDb25uZWN0aW9uKio6IE1haW50YWluIGEgcGVyc2lzdGVudCBjb25uZWN0aW9uIHRvIGRhdGEvd2FyZWhvdXNlLmRiLlxuKiAqKlNjaGVtYSBEZWZpbml0aW9uKio6XG4gICAgKiAqKmBtZXRhZGF0YV9yZWdpc3RyeWAqKjpcbiAgICAgICAgKiBgZmlsZV9pZGAgKFVVSUQsIFBLKVxuICAgICAgICAqIGBmaWxlbmFtZWAgKFZBUkNIQVIpXG4gICAgICAgICogYHVwbG9hZF90aW1lc3RhbXBgIChUSU1FU1RBTVApXG4gICAgICAgICogYGZpbGVfaGFzaGAgKFZBUkNIQVIpXG4gICAgICAgICogYHJvd19jb3VudGAgKElOVEVHRVIpXG4gICAgKiAqKmB0ZWxlbWV0cnlfbG9nYCoqOlxuICAgICAgICAqIGBsb2dfaWRgIChVVUlELCBQSylcbiAgICAgICAgKiBgdXNlcl9pZGAgKFZBUkNIQVIsIG51bGxhYmxlKSAtLSBQcmVwYXJlIGZvciBQaGFzZSAyIEF1dGhcbiAgICAgICAgKiBgdGltZXN0YW1wYCAoVElNRVNUQU1QKVxuICAgICAgICAqIGBxdWVyeV90ZXh0YCAoVkFSQ0hBUilcbiAgICAgICAgKiBgcmVzcG9uc2VfdHlwZWAgKFZBUkNIQVIpXG4gICAgICAgICogYHVzZXJfZmVlZGJhY2tgIChJTlRFR0VSLCBudWxsYWJsZSlcbiAgICAgICAgKiBgc3luY2VkX2F0YCAoVElNRVNUQU1QLCBudWxsYWJsZSkgLS0gRm9yIFBoYXNlIDIgU3luYyBMb2dpY1xuKiAqKk1ldGhvZHMqKjogYGdldF9jb25uZWN0aW9uKClgLCBgZXhlY3V0ZV9xdWVyeSgpYCwgYGdldF90YWJsZV9zY2hlbWEoKWAuIiwgImNoaWxkcmVuIjogW119LCB7InRpdGxlIjogIkluZ2VzdGlvbiBTZXJ2aWNlIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiZG9uZSIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLndhcmVob3VzZS5pbmdlc3QiLCAiYmxvY2tlZF9ieSI6IFsiaW1wbGVtZW50YXRpb24ucGhhc2UxLndhcmVob3VzZS5tYW5hZ2VyIl0sICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yNFQxMTo1NDowMCswMTowMCJ9LCAiY29udGVudCI6ICJDcmVhdGUgbG9naWMgdG8gaGFuZGxlIHVzZXIgZmlsZSB1cGxvYWRzLlxuXG4xLiAqKk5vcm1hbGl6YXRpb24qKjogQ29udmVydCBpbmNvbWluZyBFeGNlbC9DU1YgdG8gYSBzdHJpY3QgUGFuZGFzIERhdGFGcmFtZS5cbjIuICoqVHlwZSBFbmZvcmNlbWVudCoqOiBDYXN0IGdlbmVyaWMgYG9iamVjdGAgY29sdW1ucyB0byBzcGVjaWZpYyB0eXBlcyAoU3RyaW5nLCBJbnQsIEZsb2F0LCBCb29sLCBUaW1lc3RhbXApIHRvIGVuc3VyZSBmdXR1cmUgQmlnUXVlcnkgY29tcGF0aWJpbGl0eS5cbjMuICoqU2FuaXRpemF0aW9uKio6IENsZWFuIGNvbHVtbiBuYW1lcyAobG93ZXJjYXNlLCBzbmFrZV9jYXNlKSB0byBtYWtlIHRoZW0gU1FMLWZyaWVuZGx5IGZvciB0aGUgTExNIGxhdGVyLlxuNC4gKipTdG9yYWdlKio6IFVzZSBgZHVja2RiLnNxbChcIkNSRUFURSBUQUJMRSAuLi4gQVMgU0VMRUNUIC4uLlwiKWAgdG8gcGVyc2lzdCBkYXRhLlxuNS4gKipWZXJzaW9uaW5nKio6IENhbGN1bGF0ZSBhIGNvbnRlbnQgaGFzaCAoU0hBLTI1Nikgb2YgdGhlIGZpbGUuIElmIHRoZSBoYXNoIGV4aXN0cywgc2tpcDsgaWYgdGhlIGZpbGVuYW1lIGV4aXN0cyBidXQgaGFzaCBkaWZmZXJzLCBjcmVhdGUgYSBuZXcgdmVyc2lvbiAoZS5nLiwgYHNhbGVzX2RhdGFfdjJgKS4iLCAiY2hpbGRyZW4iOiBbXX1dfSwgeyJ0aXRsZSI6ICJNb2R1bGUgMjogVGhlIENoYXQgSW50ZXJmYWNlIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiZG9uZSIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLnVpIiwgImJsb2NrZWRfYnkiOiBbImltcGxlbWVudGF0aW9uLnBoYXNlMS53YXJlaG91c2UiXSwgImVzdGltYXRlIjogIjF3IiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTI0VDExOjU0OjAwKzAxOjAwIn0sICJjb250ZW50IjogIkltcGxlbWVudCB0aGUgU3RyZWFtbGl0IGZyb250ZW5kLiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIkxheW91dCAmIFNlc3Npb24gU3RhdGUiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJkb25lIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTEudWkubGF5b3V0IiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTI0VDExOjU0OjAwKzAxOjAwIn0sICJjb250ZW50IjogIiogKipTaWRlYmFyKio6IFwiRGF0YSBNYW5hZ2VtZW50XCIuIEEgZmlsZSB1cGxvYWRlciB3aWRnZXQgYW5kIGEgbGlzdCBvZiBjdXJyZW50bHkgYXZhaWxhYmxlIHRhYmxlcyBpbiBEdWNrREIuXG4qICoqTWFpbiBBcmVhKio6IENoYXQgY29udGFpbmVyLlxuKiAqKlN0YXRlIE1hbmFnZW1lbnQqKjogSW5pdGlhbGl6ZSBgc3Quc2Vzc2lvbl9zdGF0ZWAgdG8gaG9sZDpcbiAgKiBgbWVzc2FnZXNgOiBMaXN0IG9mIGB7J3JvbGUnOiAndXNlcid8J2Fzc2lzdGFudCcsICdjb250ZW50Jzogc3RyLCAnZGF0YV9yZWYnOiAuLi59YC5cbiAgKiBgYWN0aXZlX3RhYmxlc2A6IExpc3Qgb2YgdGFibGVzIGN1cnJlbnRseSBpbiBjb250ZXh0LlxuICAqIGB1c2VyX2lkZW50aXR5YDogRGljdCBgeydpZCc6ICdsb2NhbC1kZXYnLCAncm9sZSc6ICdhZG1pbid9YCAoTW9jayBmb3IgUGhhc2UgMiBBdXRoKS4iLCAiY2hpbGRyZW4iOiBbXX0sIHsidGl0bGUiOiAiQ2hhdCBMb2dpYyAmIE1vY2sgT3JjaGVzdHJhdG9yIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiZG9uZSIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLnVpLmNoYXQiLCAiYmxvY2tlZF9ieSI6IFsiaW1wbGVtZW50YXRpb24ucGhhc2UxLnVpLmxheW91dCJdLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjRUMTE6NTQ6MDArMDE6MDAifSwgImNvbnRlbnQiOiAiU2luY2UgdGhlIENsb3VkIEFnZW50cyAoUGhhc2UgMykgYXJlIG5vdCByZWFkeSwgYnVpbGQgYSAqKkxvY2FsIExvb3BiYWNrKiogZm9yIHRlc3RpbmcuXG5cbjEuICoqSW5wdXQqKjogVXNlciB0eXBlcyBcIlNob3cgbWUgdGhlIGxhc3QgNSByb3dzIG9mIHNhbGVzXCIuXG4yLiAqKk1vY2sgUHJvY2Vzc29yIChBREsgUGF0dGVybikqKjpcbiAgICogSW5zdGVhZCBvZiByYW5kb20gcmVnZXgsIGRlZmluZSBhIGNsYXNzIGBMb2NhbEFuYWx5c3RgIHdpdGggbWV0aG9kcyBsaWtlIGBnZXRfc2FsZXNfZGF0YShsaW1pdDogaW50KWAuXG4gICAqIFVzZSAqKlB5ZGFudGljKiogdG8gZGVmaW5lIHRoZSBpbnB1dCBzY2hlbWEgZm9yIHRoZXNlIG1ldGhvZHMsIG1pcnJvcmluZyBob3cgQURLIGhhbmRsZXMgdG9vbCBhcmd1bWVudHMuXG4gICAqIFRoaXMgYWxsb3dzIHVzIHRvIFwic3dhcFwiIHRoaXMgTW9jayBQcm9jZXNzb3IgZm9yIGEgcmVhbCBgYWRrLkFnZW50YCBpbiBQaGFzZSAzIHdpdGhvdXQgcmV3cml0aW5nIHRoZSBmcm9udGVuZC5cbjMuICoqUmVuZGVyaW5nKio6XG4gICAqIElmIHJlc3BvbnNlIGlzIFRleHQ6IGBzdC5tYXJrZG93bigpYC5cbiAgICogSWYgcmVzcG9uc2UgaXMgRGF0YTogYHN0LmRhdGFmcmFtZSgpYCBvciBgc3QuYmFyX2NoYXJ0KClgLiIsICJjaGlsZHJlbiI6IFtdfV19LCB7InRpdGxlIjogIk1vZHVsZSAzOiBUZXN0aW5nICYgUXVhbGl0eSBBc3N1cmFuY2UiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTEudGVzdGluZyIsICJibG9ja2VkX2J5IjogWyJpbXBsZW1lbnRhdGlvbi5waGFzZTEudWkiXSwgImVzdGltYXRlIjogIjNkIiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTI0VDA4OjM1OjAwKzAxOjAwIn0sICJjb250ZW50IjogIkVzdGFibGlzaCBjb21wcmVoZW5zaXZlIHRlc3RpbmcgdG8gZW5zdXJlIHJlbGlhYmlsaXR5IGJlZm9yZSBwYWNrYWdpbmcuIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiVW5pdCBUZXN0cyIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMS50ZXN0aW5nLnVuaXQifSwgImNvbnRlbnQiOiAiLSA8IS0tIGNvbnRlbnQgLS0+XG4tICoqRnJhbWV3b3JrKio6IGBweXRlc3RgXG4tICoqQ292ZXJhZ2UqKjpcbiAgICAtIGBpbmdlc3Rpb24ucHlgOiBWZXJpZnkgZmlsZSBoYXNoIGFzc2VydGlvbnMgYW5kIHNjaGVtYSBub3JtYWxpemF0aW9uLlxuICAgIC0gYGRhdGFiYXNlLnB5YDogVGVzdCBjb25uZWN0aW9uIHBlcnNpc3RlbmNlIGFuZCBxdWVyeSBleGVjdXRpb24gd2l0aCBtb2NrIGRhdGEuIiwgImNoaWxkcmVuIjogW119LCB7InRpdGxlIjogIkludGVncmF0aW9uIFRlc3RzIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLnRlc3RpbmcuaW50ZWdyYXRpb24iLCAiYmxvY2tlZF9ieSI6IFsiaW1wbGVtZW50YXRpb24ucGhhc2UxLnRlc3RpbmcudW5pdCJdfSwgImNvbnRlbnQiOiAiLSA8IS0tIGNvbnRlbnQgLS0+XG4tICoqRmxvdyoqOiBTaW11bGF0ZSBhIGZ1bGwgdXNlciBmbG93OiBVc2VyIHVwbG9hZHMgQ1NWIC0+IEluZ2VzdGlvbiAtPiBzdG9yZWQgaW4gREIgLT4gUXVlcnkgcmV0cmlldmVzIGl0LiIsICJjaGlsZHJlbiI6IFtdfV19LCB7InRpdGxlIjogIk1vZHVsZSA0OiBQYWNrYWdpbmcgJiBEaXN0cmlidXRpb24iLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTEucGFja2FnaW5nIiwgImJsb2NrZWRfYnkiOiBbImltcGxlbWVudGF0aW9uLnBoYXNlMS50ZXN0aW5nIl0sICJlc3RpbWF0ZSI6ICIyZCIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yNFQwODozNTowMCswMTowMCJ9LCAiY29udGVudCI6ICJQcmVwYXJlIHRoZSBhcHBsaWNhdGlvbiBmb3IgZWFzeSBsb2NhbCBkZXBsb3ltZW50LiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIkRlcGVuZGVuY3kgTWFuYWdlbWVudCIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMS5wYWNrYWdpbmcuZGVwcyJ9LCAiY29udGVudCI6ICItIDwhLS0gY29udGVudCAtLT5cbi0gQ3JlYXRlIGByZXF1aXJlbWVudHMudHh0YCB3aXRoIGxvY2tlZCB2ZXJzaW9ucy5cbi0gQ3JlYXRlIGBlbnZpcm9ubWVudC55bWxgIGZvciBDb25kYSB1c2Vycy4iLCAiY2hpbGRyZW4iOiBbXX0sIHsidGl0bGUiOiAiRXhlY3V0aW9uIFNjcmlwdHMiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTEucGFja2FnaW5nLnNjcmlwdHMifSwgImNvbnRlbnQiOiAiLSA8IS0tIGNvbnRlbnQgLS0+XG4tIENyZWF0ZSBgcnVuX2FwcC5zaGAgKE1hYy9MaW51eCkgYW5kIGBydW5fYXBwLmJhdGAgKFdpbmRvd3MpIHRvIHNldCB1cCB0aGUgZW52aXJvbm1lbnQgYW5kIGxhdW5jaCBgc3RyZWFtbGl0IHJ1biBzcmMvYXBwLnB5YC4iLCAiY2hpbGRyZW4iOiBbXX1dfSwgeyJ0aXRsZSI6ICJSZXNlYXJjaCBJbnN0cnVtZW50YXRpb24gKFByZS1STCkiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTEucmVzZWFyY2giLCAicHJpb3JpdHkiOiAiaGlnaCIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yNFQwODozNTowMCswMTowMCJ9LCAiY29udGVudCI6ICJUbyBwcmVwYXJlIGZvciB0aGUgUkwgQWdlbnRzIGluIFBoYXNlIDMsIHdlIG11c3QgdHJlYXQgdGhpcyBwaGFzZSBhcyB0aGUgXCJEYXRhIENvbGxlY3Rpb25cIiBwZXJpb2QuXG5cbiogKipJbnRlcmFjdGlvbiBMb2dnaW5nKio6IEV2ZXJ5IHVzZXIgcXVlcnkgYW5kIHN1YnNlcXVlbnQgc3lzdGVtIG91dHB1dCBtdXN0IGJlIGxvZ2dlZCB0byBhIEpTT05MIGZpbGUgb3IgdGhlIGB0ZWxlbWV0cnlfbG9nYCB0YWJsZS5cbiogKipGb3JtYXQqKjpcbiAgYGBganNvblxuICB7XG4gICAgXCJ0aW1lc3RhbXBcIjogXCJJU084NjAxXCIsXG4gICAgXCJzdGF0ZV9zbmFwc2hvdFwiOiBbXCJsaXN0X29mX2FjdGl2ZV90YWJsZXNcIiwgXCJyb3dfY291bnRzXCJdLFxuICAgIFwiYWN0aW9uX3VzZXJfcXVlcnlcIjogXCJyYXdfdGV4dF9pbnB1dFwiLFxuICAgIFwic3lzdGVtX3Jlc3BvbnNlX3R5cGVcIjogXCJ0YWJsZV9yZW5kZXJcIixcbiAgICBcInVzZXJfZmVlZGJhY2tcIjogbnVsbFxuICB9XG4gIGBgYFxuKiAqKldoeSoqOiBUaGlzIGRhdGFzZXQgd2lsbCBiZSB1c2VkIHRvIG9mZmxpbmUtdHJhaW4gdGhlIE9yY2hlc3RyYXRvciB0byBjbGFzc2lmeSBpbnRlbnQgKEFuYWx5c2lzIHZzLiBDb250cm9sKSBiZWZvcmUgd2UgZGVwbG95IHRoZSBsaXZlIG1vZGVsLiIsICJjaGlsZHJlbiI6IFtdfV19LCB7InRpdGxlIjogIlBoYXNlIDI6IFRoZSBDbG91ZCBCcmlkZ2UiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJhY3RpdmUiLCAidHlwZSI6ICJwbGFuIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMiIsICJvd25lciI6ICJ1c2VyIiwgInByaW9yaXR5IjogImNyaXRpY2FsIiwgImVzdGltYXRlIjogIjJ3IiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTI0VDA4OjUwOjAwKzAxOjAwIiwgImJsb2NrZWRfYnkiOiBbImltcGxlbWVudGF0aW9uLnBoYXNlMSJdfSwgImNvbnRlbnQiOiAiVGhpcyBkb2N1bWVudCBkZXRhaWxzIHRoZSBcIkNsb3VkIEJyaWRnZVwiIGltcGxlbWVudGF0aW9uLiBUaGUgZ29hbCBpcyB0byBlc3RhYmxpc2ggYSBzZWN1cmUsIHNjYWxhYmxlIGNvbW11bmljYXRpb24gY2hhbm5lbCBiZXR3ZWVuIHRoZSBMb2NhbCBOZXh1cyAoUGhhc2UgMSkgYW5kIHRoZSBDbG91ZCBBZ2VudHMgKFBoYXNlIDMpIHVzaW5nIHRoZSBHb29nbGUgQ2xvdWQgRWNvc3lzdGVtLlxuXG4qKk9iamVjdGl2ZSoqOlxuMS4gICoqSW5mcmFzdHJ1Y3R1cmUqKjogUHJvdmlzaW9uIHNlcnZlcmxlc3MgY29tcHV0ZSBhbmQgc3RvcmFnZSBvbiBHQ1AuXG4yLiAgKipDb25uZWN0aXZpdHkqKjogQnVpbGQgYSBzZWN1cmUgQVBJIEdhdGV3YXkgZm9yIHRoZSBsb2NhbCBhcHAgdG8gXCJwaG9uZSBob21lXCIuXG4zLiAgKipTeW5jaHJvbml6YXRpb24qKjogQ3JlYXRlIHBpcGVsaW5lcyB0byBtaXJyb3IgbG9jYWwgZGF0YSB0byB0aGUgY2xvdWQgZm9yIGhlYXZ5IHByb2Nlc3NpbmcuXG5cbioqVGVjaCBTdGFjayoqOlxuKiAgICoqQ29tcHV0ZSoqOiBHb29nbGUgQ2xvdWQgUnVuIChTZXJ2ZXJsZXNzIENvbnRhaW5lcikuXG4qICAgKipEYXRhYmFzZSoqOiBHb29nbGUgQmlnUXVlcnkgKFdhcmVob3VzaW5nKSAmIEZpcmVzdG9yZSAoTm9TUUwgTWV0YWRhdGEpLlxuKiAgICoqQVBJKio6IFB5dGhvbiBGYXN0QVBJLlxuKiAgICoqQXV0aCoqOiBGaXJlYmFzZSBBdXRoZW50aWNhdGlvbi5cbiogICAqKkRlcGxveW1lbnQqKjogVGVycmFmb3JtIC8gZ2Nsb3VkIENMSSAodmlhIEFudGlncmF2aXR5IE1DUCkuIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiTW9kdWxlIDA6IFNuYWtlIEdhbWUgVHJpYWwiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIuc25ha2UiLCAiZXN0aW1hdGUiOiAiM2QifSwgImNvbnRlbnQiOiAiVGhlIGlkZWEgaXMgdGhhdCB3ZSBhcmUgZ29pbmcgdG8gcHV0IGEgc21hbGwgYXBwIGluIHRoZSBjbG91ZCB0byB0ZXN0IGZ1bmN0aW9uYWxpdGllcy4gQWZ0ZXIgdGhhdCB3ZSBhcmUgZ29pbmcgdG8gc3RhcnQgd2l0aCB0aGUgaW5mcmFzdHJ1Y3R1cmUgaW5pdGlhbGl6YXRpb24iLCAiY2hpbGRyZW4iOiBbXX0sIHsidGl0bGUiOiAiTW9kdWxlIDE6IEluZnJhc3RydWN0dXJlIEluaXRpYWxpemF0aW9uIChHQ1ApIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UyLmluZnJhIiwgImVzdGltYXRlIjogIjNkIiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTI0VDA4OjUwOjAwKzAxOjAwIn0sICJjb250ZW50IjogIlByb3Zpc2lvbiB0aGUgbmVjZXNzYXJ5IEdvb2dsZSBDbG91ZCByZXNvdXJjZXMuIFdlIHdpbGwgZmF2b3IgXCJJbmZyYXN0cnVjdHVyZSBhcyBDb2RlXCIgcHJhY3RpY2VzLiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIlByb2plY3QgU2V0dXAgJiBBUEkgRW5hYmxlbWVudCIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMi5pbmZyYS5zZXR1cCIsICJwcmlvcml0eSI6ICJoaWdoIn0sICJjb250ZW50IjogIiogICAqKkFjdGlvbioqOiBDcmVhdGUgYSBuZXcgR0NQIFByb2plY3QgKGUuZy4sIGBpbnRlbGxpZ2VudC1jb250cm9sLXByb2RgKS5cbiogICAqKkVuYWJsZSBBUElzKio6XG4gICAgKiAgIGBydW4uZ29vZ2xlYXBpcy5jb21gIChDbG91ZCBSdW4pXG4gICAgKiAgIGBhcnRpZmFjdHJlZ2lzdHJ5Lmdvb2dsZWFwaXMuY29tYCAoRG9ja2VyIEltYWdlcylcbiAgICAqICAgYGJpZ3F1ZXJ5Lmdvb2dsZWFwaXMuY29tYCAoRGF0YSBXYXJlaG91c2UpXG4gICAgKiAgIGBmaXJlc3RvcmUuZ29vZ2xlYXBpcy5jb21gIChBcHAgU3RhdGUpIiwgImNoaWxkcmVuIjogW119LCB7InRpdGxlIjogIklhQyAmIERlcGxveW1lbnQgV29ya2Zsb3ciLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIuaW5mcmEuaWFjIiwgImJsb2NrZWRfYnkiOiBbImltcGxlbWVudGF0aW9uLnBoYXNlMi5pbmZyYS5zZXR1cCJdfSwgImNvbnRlbnQiOiAiRGVmaW5lIHRoZSBpbmZyYXN0cnVjdHVyZSB1c2luZyBUZXJyYWZvcm0gb3Igc2NyaXB0YWJsZSBgZ2Nsb3VkYCBjb21tYW5kcy5cbiogICAqKldvcmtmbG93Kio6XG4gICAgMS4gIFVzZXIgcHJvbXB0cyBBbnRpZ3Jhdml0eSB0byBcIkRlcGxveSBJbmZyYXN0cnVjdHVyZVwiLlxuICAgIDIuICBBbnRpZ3Jhdml0eSB1c2VzIHRoZSB0ZXJtaW5hbCB0b29sIChvciBgZ2Nsb3VkYCBNQ1ApIHRvIGV4ZWN1dGUgdGhlIHByb3Zpc2lvbmluZyBzY3JpcHRzLlxuICAgIDMuICBPdXRwdXRzIChTZXJ2aWNlIFVSTHMsIEJ1Y2tldCBOYW1lcykgYXJlIHNhdmVkIHRvIGBkZXBsb3ltZW50X2NvbmZpZy5qc29uYC4iLCAiY2hpbGRyZW4iOiBbXX1dfSwgeyJ0aXRsZSI6ICJNb2R1bGUgMjogQXV0aGVudGljYXRpb24gJiBTZWN1cml0eSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMi5hdXRoIiwgImJsb2NrZWRfYnkiOiBbImltcGxlbWVudGF0aW9uLnBoYXNlMi5pbmZyYSJdLCAiZXN0aW1hdGUiOiAiMXciLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjRUMDg6NTA6MDArMDE6MDAifSwgImNvbnRlbnQiOiAiU2VjdXJlIHRoZSBicmlkZ2UuIFRoZSBMb2NhbCBBcHAgbXVzdCBhdXRoZW50aWNhdGUgYmVmb3JlIHNlbmRpbmcgZGF0YS4iLCAiY2hpbGRyZW4iOiBbeyJ0aXRsZSI6ICJJZGVudGl0eSBNYW5hZ2VtZW50IChGaXJlYmFzZSkiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIuYXV0aC5maXJlYmFzZSJ9LCAiY29udGVudCI6ICIqICAgKipTZXR1cCoqOiBJbml0aWFsaXplIGEgRmlyZWJhc2UgcHJvamVjdCBsaW5rZWQgdG8gdGhlIEdDUCBwcm9qZWN0LlxuKiAgICoqQ2xpZW50Kio6IEludGVncmF0ZSBgZmlyZWJhc2UtYWRtaW5gIGluIHRoZSBDbG91ZCBBUEkgYW5kIHRoZSBKUy9QeXRob24gU0RLIGluIHRoZSBMb2NhbCBBcHAuXG4qICAgKipGbG93Kio6XG4gICAgMS4gIExvY2FsIFVzZXIgbG9ncyBpbi5cbiAgICAyLiAgTG9jYWwgQXBwIGdldHMgSldUIFRva2VuLlxuICAgIDMuICBBUEkgR2F0ZXdheSB2ZXJpZmllcyBKV1QgVG9rZW4gb24gZXZlcnkgcmVxdWVzdC4iLCAiY2hpbGRyZW4iOiBbXX0sIHsidGl0bGUiOiAiU2VydmljZSBTZWN1cml0eSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMi5hdXRoLmlhbSJ9LCAiY29udGVudCI6ICIqICAgKipTZXJ2aWNlIEFjY291bnRzKio6IENyZWF0ZSBhIHNwZWNpZmljIFNlcnZpY2UgQWNjb3VudCBmb3IgdGhlIENsb3VkIFJ1biBpbnN0YW5jZS5cbiogICAqKlBlcm1pc3Npb25zKio6IEdyYW50IHN0cmljdGx5IG5lY2Vzc2FyeSByb2xlcyAoZS5nLiwgYHJvbGVzL2JpZ3F1ZXJ5LmRhdGFFZGl0b3JgLCBgcm9sZXMvc3RvcmFnZS5vYmplY3RDcmVhdG9yYCkuICoqRG8gbm90IHVzZSBPd25lciByb2xlLioqIiwgImNoaWxkcmVuIjogW119XX0sIHsidGl0bGUiOiAiTW9kdWxlIDM6IFRoZSBBUEkgR2F0ZXdheSAoQ29ubmVjdG9yKSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMi5hcGkiLCAiYmxvY2tlZF9ieSI6IFsiaW1wbGVtZW50YXRpb24ucGhhc2UyLmF1dGgiXSwgImVzdGltYXRlIjogIjF3IiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTI0VDA4OjUwOjAwKzAxOjAwIn0sICJjb250ZW50IjogIkRldmVsb3AgYW5kIGRlcGxveSB0aGUgY2VudHJhbCBSRVNUIEFQSS4iLCAiY2hpbGRyZW4iOiBbeyJ0aXRsZSI6ICJTZXJ2aWNlIFNrZWxldG9uIChGYXN0QVBJKSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMi5hcGkuZGV2In0sICJjb250ZW50IjogIkNyZWF0ZSBgc3JjL2Nsb3VkL21haW4ucHlgLlxuKiAgICoqRW5kcG9pbnRzKio6XG4gICAgKiAgIGBQT1NUIC92MS90ZWxlbWV0cnlgOiBBY2NlcHRzIEpTT04gcGF5bG9hZHMgb2YgdXNlciBpbnRlcmFjdGlvbnMuXG4gICAgKiAgIGBQT1NUIC92MS9hZ2VudC90YXNrYDogU3VibWl0cyBhIGNvbXBsZXggdGFzayBmb3IgdGhlIENsb3VkIEFnZW50cy5cbiAgICAqICAgYEdFVCAvdjEvYWdlbnQvc3RhdHVzL3t0YXNrX2lkfWA6IFBvbGxpbmcgZW5kcG9pbnQgZm9yIGxvbmctcnVubmluZyBqb2JzLiIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJDb250YWluZXJpemF0aW9uICYgRGVwbG95IiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UyLmFwaS5kZXBsb3kiLCAiYmxvY2tlZF9ieSI6IFsiaW1wbGVtZW50YXRpb24ucGhhc2UyLmFwaS5kZXYiXX0sICJjb250ZW50IjogIiogICAqKkRvY2tlcioqOiBDcmVhdGUgYERvY2tlcmZpbGVgIG9wdGltaXplZCBmb3IgUHl0aG9uIChtdWx0aS1zdGFnZSBidWlsZCkuXG4qICAgKipDSS9DRCoqOiBEZWZpbmUgYSBzaW1wbGUgZGVwbG95bWVudCBzY3JpcHQ6IGBnY2xvdWQgcnVuIGRlcGxveSAtLXNvdXJjZSAuYC4iLCAiY2hpbGRyZW4iOiBbXX1dfSwgeyJ0aXRsZSI6ICJNb2R1bGUgNDogRGF0YSBTeW5jaHJvbml6YXRpb24gUGlwZWxpbmUiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIucGlwZWxpbmUiLCAiYmxvY2tlZF9ieSI6IFsiaW1wbGVtZW50YXRpb24ucGhhc2UyLmFwaSJdLCAiZXN0aW1hdGUiOiAiMXciLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjRUMDg6NTA6MDArMDE6MDAifSwgImNvbnRlbnQiOiAiTWVjaGFuaXNtcyB0byBtb3ZlIGxhcmdlIGRhdGFzZXRzIGZyb20gTG9jYWwgRHVja0RCIHRvIENsb3VkIEJpZ1F1ZXJ5LiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIkJsb2IgU3RvcmFnZSBJbmdyZXNzIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UyLnBpcGVsaW5lLmdjcyJ9LCAiY29udGVudCI6ICJGb3IgcmF3IGZpbGVzIChDU1YvRXhjZWwpIHRoYXQgYXJlIHRvbyBsYXJnZSBmb3IgSlNPTiBwYXlsb2Fkcy5cbiogICAqKk1lY2hhbmlzbSoqOiBMb2NhbCBBcHAgcmVxdWVzdHMgYSBTaWduZWQgVXBsb2FkIFVSTCBmcm9tIHRoZSBBUEkuXG4qICAgKipBY3Rpb24qKjogTG9jYWwgQXBwIFBVVHMgdGhlIGZpbGUgZGlyZWN0bHkgdG8gYSBHQ1MgQnVja2V0IChgcmF3LWRhdGEtaW5ncmVzc2ApLiIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJXYXJlaG91c2UgU3luYyAoQmlnUXVlcnkpIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UyLnBpcGVsaW5lLmJpZ3F1ZXJ5IiwgImJsb2NrZWRfYnkiOiBbImltcGxlbWVudGF0aW9uLnBoYXNlMi5waXBlbGluZS5nY3MiXX0sICJjb250ZW50IjogIiogICAqKlNjaGVtYSBNYXBwaW5nKio6IE1hcCBEdWNrREIgdHlwZXMgdG8gQmlnUXVlcnkgdHlwZXMuXG4qICAgKipWYWxpZGF0aW9uKio6IENoZWNrIGluY29taW5nIHNjaGVtYSBhZ2FpbnN0IGV4aXN0aW5nIEJpZ1F1ZXJ5IHNjaGVtYSB0byByZWplY3QgYnJlYWtpbmcgY2hhbmdlcyAoU2NoZW1hIERyaWZ0IGRlZmVuc2UpLlxuKiAgICoqVmFsaWRhdGlvbioqOiBDaGVjayBpbmNvbWluZyBzY2hlbWEgYWdhaW5zdCBleGlzdGluZyBCaWdRdWVyeSBzY2hlbWEgdG8gcmVqZWN0IGJyZWFraW5nIGNoYW5nZXMgKFNjaGVtYSBEcmlmdCBkZWZlbnNlKS5cbiogICAqKlRyaWdnZXIqKjogV2hlbiBhIGZpbGUgbGFuZHMgaW4gR0NTLCBhIENsb3VkIEV2ZW50IHRyaWdnZXJzIGEgXCJMb2FkZXJcIiBmdW5jdGlvbiAob3IgdGhlIEFQSSBpdHNlbGYpIHRvIGxvYWQgdGhlIENTViBpbnRvIEJpZ1F1ZXJ5LlxuKiAgICoqQURLIENvbXBhdGliaWxpdHkqKjogRW5zdXJlIHRoZSBCaWdRdWVyeSBkYXRhc2V0IGxhYmVscyBhbmQgZGVzY3JpcHRpb25zIGFyZSB2ZXJib3NlLiBBREsncyBgQmlnUXVlcnlUb29sYCB1c2VzIHRoZXNlIHNjaGVtYSBkZXNjcmlwdGlvbnMgdG8gdW5kZXJzdGFuZCBob3cgdG8gcXVlcnkgdGhlIGRhdGEuIiwgImNoaWxkcmVuIjogW119XX1dfSwgeyJ0aXRsZSI6ICJQaGFzZSAzOiBUaGUgQ2xvdWQgQWdlbnRzIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInBsYW4iLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UzIiwgIm93bmVyIjogInVzZXIiLCAicHJpb3JpdHkiOiAiY3JpdGljYWwiLCAiZXN0aW1hdGUiOiAiNnciLCAiYmxvY2tlZF9ieSI6IFsiaW1wbGVtZW50YXRpb24ucGhhc2UyIl19LCAiY29udGVudCI6ICJUaGlzIGRvY3VtZW50IGRldGFpbHMgdGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBcIkJyYWluXCIgb2YgdGhlIEludGVsbGlnZW50IENvbnRyb2wgU2FhUzogYSBtdWx0aS1hZ2VudCBzeXN0ZW0gYnVpbHQgdXNpbmcgdGhlICoqR29vZ2xlIEFnZW50IERldmVsb3BtZW50IEtpdCAoQURLKSoqLlxuXG4qKk9iamVjdGl2ZSoqOiBEZXBsb3kgYSByb2J1c3QsIG9ic2VydmFibGUsIGFuZCBzY2FsYWJsZSBhZ2VudCBlY29zeXN0ZW0gaGFuZGxpbmc6XG4xLiAgKipBbmFseXNpcyoqOiBQeXRob24tYmFzZWQgZGF0YSBzY2llbmNlIGFuZCB2aXN1YWxpemF0aW9uLlxuMi4gICoqQ29udHJvbCoqOiBSTC9Db250cm9sLXRoZW9yeSBvcHRpbWl6YXRpb24gdXNpbmcgYSBjdXN0b20gYWxnb3JpdGhtIHJlcG9zaXRvcnkuXG4zLiAgKipPcmNoZXN0cmF0aW9uKio6IEludGVsbGlnZW50IHJvdXRpbmcgYW5kIHN0YXRlIG1hbmFnZW1lbnQuXG5cbioqVGVjaCBTdGFjayoqOlxuKiAgICoqRnJhbWV3b3JrKio6IEdvb2dsZSBBREsgKFB5dGhvbiBTREspLlxuKiAgICoqTW9kZWwqKjogR2VtaW5pIDEuNSBQcm8gKHZpYSBWZXJ0ZXggQUkpLlxuKiAgICoqUnVudGltZSoqOiBDbG91ZCBSdW4gKENvbnRhaW5lcml6ZWQgQWdlbnRzKS5cbiogICAqKkV2YWx1YXRpb24qKjogVmVydGV4IEFJIEdlbiBBSSBFdmFsdWF0aW9uIFNlcnZpY2UuIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiQXJjaGl0ZWN0dXJlOiBUaGUgQURLIEVjb3N5c3RlbSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJwbGFuIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMy5hcmNoIiwgImVzdGltYXRlIjogIjF3In0sICJjb250ZW50IjogIldlIHdpbGwgbGV2ZXJhZ2UgQURLJ3MgcGF0dGVybiBmb3IgY29tcG9zYWJsZSBhZ2VudHMuIFRoZSBzeXN0ZW0gd2lsbCBjb25zaXN0IG9mIGEgdG9wLWxldmVsICoqQ29vcmRpbmF0b3IgQWdlbnQqKiBhbmQgdHdvIHNwZWNpYWxpemVkIHdvcmtlciBhZ2VudHMuIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiVGhlIENvb3JkaW5hdG9yIFBhdHRlcm4iLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAicHJvdG9jb2wiLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UzLmFyY2guY29vcmRpbmF0b3IifSwgImNvbnRlbnQiOiAiSW5zdGVhZCBvZiBhIG1vbm9saXRoaWMgY2hhaW4sIHdlIHVzZSBhIGNlbnRyYWwgYExsbUFnZW50YCBhY3RpbmcgYXMgYSByb3V0ZXIuXG4qICAgKipJbnB1dCoqOiBOYXR1cmFsIGxhbmd1YWdlIHVzZXIgcXVlcmllcyArIFN0YXRlIENvbnRleHQgKGZyb20gUGhhc2UgMikuXG4qICAgKipEZWNpc2lvbioqOiBVc2VzIGEgYGNsYXNzaWZ5X2ludGVudGAgdG9vbCBvciBmZXctc2hvdCBwcm9tcHRpbmcgdG8gZGVjaWRlOlxuICAgICogICBgQU5BTFlTSVNfUkVRVUlSRURgIC0+IERlbGVnYXRlIHRvIEFuYWx5c3QgQWdlbnQuXG4gICAgKiAgIGBDT05UUk9MX1JFUVVJUkVEYCAtPiBEZWxlZ2F0ZSB0byBDb250cm9sbGVyIEFnZW50LlxuICAgICogICBgQU1CSUdVT1VTYCAtPiBBc2sgY2xhcmlmeWluZyBxdWVzdGlvbnMuXG4qICAgKipPdXRwdXQqKjogQWdncmVnYXRlcyByZXNwb25zZXMgZnJvbSB3b3JrZXJzIGFuZCBmb3JtYXRzIHRoZSBmaW5hbCBhbnN3ZXIgZm9yIHRoZSB1c2VyLiIsICJjaGlsZHJlbiI6IFtdfV19LCB7InRpdGxlIjogIk1vZHVsZSAxOiBUaGUgQW5hbHlzdCBBZ2VudCAoRGF0YSBTY2llbnRpc3QpIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UzLmFuYWx5c3QiLCAiYmxvY2tlZF9ieSI6IFsiaW1wbGVtZW50YXRpb24ucGhhc2UzLmFyY2giXSwgImVzdGltYXRlIjogIjJ3In0sICJjb250ZW50IjogIioqUm9sZSoqOiBcIldoeSBpcyB0aGlzIGhhcHBlbmluZz9cIlxuKipUb29scyoqOiBDb2RlIEV4ZWN1dGlvbiwgRGF0YSBWaXN1YWxpemF0aW9uLiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIkRhdGEgU2NpZW5jZSBUb29sIFJlcG9zaXRvcnkiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTMuYW5hbHlzdC5yZXBvIn0sICJjb250ZW50IjogIldlIHdpbGwgYnVpbGQgYSBkZWRpY2F0ZWQgUHl0aG9uIGxpYnJhcnkgKGBzcmMvbGliX2FuYWx5c2lzYCkgdGhhdCB0aGUgYWdlbnQgbGVhcm5zIHRvIHVzZS5cbiogICAqKlN0cnVjdHVyZSoqOlxuICAgIGBgYHB5dGhvblxuICAgIC9zcmMvbGliX2FuYWx5c2lzXG4gICAgICAgL3Zpc3VhbGl6ZS5weSAgICMgSGlnaC1sZXZlbCBwbG90IHdyYXBwZXJzIChwbG90X3RpbWVfc2VyaWVzLCBwbG90X2Rpc3RyaWJ1dGlvbilcbiAgICAgICAvc3RhdHMucHkgICAgICAgIyBIeXBvdGhlc2lzIHRlc3RpbmcgKGFub3ZhLCB0X3Rlc3QpXG4gICAgICAgL2NsZWFuLnB5ICAgICAgICMgQXV0by1jbGVhbmluZyB1dGlsaXRpZXNcbiAgICBgYGBcbiogICAqKkludGVncmF0aW9uKio6XG4gICAgKiAgIEV4cG9zZSB0aGVzZSBmdW5jdGlvbnMgYXMgKipBREsgVG9vbHMqKi5cbiAgICAqICAgVXNlIHR5cGUgaGludHMgYW5kIGRvY3N0cmluZ3MgaGVhdmlseSwgYXMgQURLIHVzZXMgdGhlc2UgZm9yIHRvb2wgZGVmaW5pdGlvbiB2ZXJpZmljYXRpb24uIiwgImNoaWxkcmVuIjogW119LCB7InRpdGxlIjogIkNvZGUgRXhlY3V0aW9uIFNhbmRib3giLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTMuYW5hbHlzdC5zYW5kYm94In0sICJjb250ZW50IjogIiogICAqKk1lY2hhbmlzbSoqOiBUaGUgYWdlbnQgd3JpdGVzIGNvZGUgdGhhdCBpbXBvcnRzIGBsaWJfYW5hbHlzaXNgLlxuKiAgICoqU2VjdXJpdHkqKjogVXNlIEFESydzIGBDb2RlRXhlY3V0aW9uVG9vbGAgY29uZmlndXJlZCB3aXRoIGEgcmVzdHJpY3RlZCBlbnZpcm9ubWVudCAob3IgRTJCIGludGVncmF0aW9uIGlmIEFESyBuYXRpdmUgc3VwcG9ydCBpcyBpbnN1ZmZpY2llbnQpLlxuKiAgICoqT3V0cHV0IEhhbmRsaW5nKio6IENhcHR1cmUgYHN0ZG91dGAgKHRleHQpIGFuZCBnZW5lcmF0ZWQgYXJ0aWZhY3RzIChQTkcvSlNPTikgdG8gcGFzcyBiYWNrIHRvIHRoZSBDb29yZGluYXRvci4iLCAiY2hpbGRyZW4iOiBbXX1dfSwgeyJ0aXRsZSI6ICJNb2R1bGUgMjogVGhlIENvbnRyb2xsZXIgQWdlbnQgKE9wdGltaXplcikiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTMuY29udHJvbGxlciIsICJibG9ja2VkX2J5IjogWyJpbXBsZW1lbnRhdGlvbi5waGFzZTMuYW5hbHlzdCJdLCAiZXN0aW1hdGUiOiAiMncifSwgImNvbnRlbnQiOiAiKipSb2xlKio6IFwiT3B0aW1pemUgZm9yIFguXCJcbioqVG9vbHMqKjogT3B0aW1pemF0aW9uIEFsZ29yaXRobXMsIFNpbXVsYXRpb24uIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiQ29udHJvbCBBbGdvcml0aG1zIEludGVncmF0aW9uIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UzLmNvbnRyb2xsZXIuaW50ZWdyYXRpb24ifSwgImNvbnRlbnQiOiAiSW50ZWdyYXRlIHRoZSBleHRlcm5hbCByZXBvc2l0b3J5IFtjb250cm9sX2FsZ29yaXRobXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9JZ25hY2lvT1EvY29udHJvbF9hbGdvcml0aG1zKS5cbiogICAqKlN0ZXAgMSoqOiBTdWJtb2R1bGUgb3IgUGFja2FnZSBpbnRlZ3JhdGlvbiBvZiB0aGUgdXNlcidzIHJlcG9zaXRvcnkuXG4qICAgKipTdGVwIDIqKjogQ3JlYXRlIGFuICoqQURLIFRvb2wgV3JhcHBlcioqIChgc3JjL3Rvb2xzL2NvbnRyb2xfdG9vbHMucHlgKSB0aGF0IGV4cG9zZXMga2V5IGFsZ29yaXRobXMgYXMgY2FsbGFibGUgZnVuY3Rpb25zOlxuICAgICogICBgcnVuX21wY19vcHRpbWl6YXRpb24oc3RhdGVfdmVjdG9yLCBjb25zdHJhaW50cylgXG4gICAgKiAgIGBzb2x2ZV9uZXdzdmVuZG9yKGRlbWFuZF9kaXN0LCBjb3N0cylgXG4gICAgKiAgIGBzaW11bGF0ZV9zY2VuYXJpbyhpbml0aWFsX3N0YXRlLCBob3Jpem9uKWBcbiogICAqKlN0ZXAgMyoqOiBEZWZpbmUgdGhlIFwiU3RhdGUgU2NoZW1hXCIuIFRoZSBBZ2VudCBtdXN0IGtub3cgaG93IHRvIG1hcCB0aGUgcmF3IHRlbGVtZXRyeSAoZnJvbSBCaWdRdWVyeS9QaGFzZSAyKSBpbnRvIHRoZSBpbnB1dHMgcmVxdWlyZWQgYnkgdGhlc2UgYWxnb3JpdGhtcy4iLCAiY2hpbGRyZW4iOiBbXX1dfSwgeyJ0aXRsZSI6ICJNb2R1bGUgMzogQWdlbnQgRGV2ZWxvcG1lbnQgJiBPcHMgKEFESykiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTMub3BzIiwgImJsb2NrZWRfYnkiOiBbImltcGxlbWVudGF0aW9uLnBoYXNlMy5jb250cm9sbGVyIl0sICJlc3RpbWF0ZSI6ICIxdyJ9LCAiY29udGVudCI6ICJFc3RhYmxpc2ggdGhlIGxpZmVjeWNsZSBmb3IgZGV2ZWxvcGluZyBhbmQgaW1wcm92aW5nIHRoZXNlIGFnZW50cy4iLCAiY2hpbGRyZW4iOiBbeyJ0aXRsZSI6ICJFdmFsdWF0aW9uIFBpcGVsaW5lIChHZW5BSSBFdmFsKSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMy5vcHMuZXZhbCJ9LCAiY29udGVudCI6ICJVc2UgR29vZ2xlJ3MgR2VuIEFJIEV2YWx1YXRpb24gU2VydmljZSB0byBtb3ZlIGJleW9uZCBcInZpYmVzLWJhc2VkXCIgdGVzdGluZy5cbiogICAqKlRyYWplY3RvcnkgRXZhbHVhdGlvbioqOiBjaGVjayBpZiB0aGUgQW5hbHlzdCBBZ2VudCAqYWN0dWFsbHkqIHVzZWQgdGhlIGB2aXN1YWxpemUucHlgIHRvb2wgb3IgaWYgaXQgdHJpZWQgdG8gaGFsbHVjaW5hdGUgYSBwbG90LlxuKiAgICoqR29sZGVuIERhdGFzZXRzKio6IENyZWF0ZSBhIHNldCBvZiAoUXVlcnksIEV4cGVjdGVkX1Rvb2xfQ2FsbCwgRXhwZWN0ZWRfT3V0Y29tZSkgdHVwbGVzLlxuKiAgICoqQ0kvQ0QqKjogUnVuIGBhZGsgZXZhbGAgYXMgcGFydCBvZiB0aGUgZGVwbG95bWVudCBwaXBlbGluZS4iLCAiY2hpbGRyZW4iOiBbXX0sIHsidGl0bGUiOiAiRGVwbG95bWVudCAoVmVydGV4IEFJKSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMy5vcHMuZGVwbG95In0sICJjb250ZW50IjogIiogICAqKkNvbnRhaW5lcml6ZSoqOiBXcmFwIHRoZSBBREsgYWdlbnQgc2VydmVyIGluIGEgRG9ja2VyIGNvbnRhaW5lci5cbiogICAqKkRlcGxveSoqOiBQdXNoIHRvIENsb3VkIFJ1bi5cbiogICAqKkV4cG9zZSoqOiBDb25uZWN0IHRoZSBDbG91ZCBSdW4gZW5kcG9pbnQgdG8gdGhlIEFQSSBHYXRld2F5IGNyZWF0ZWQgaW4gUGhhc2UgMi4iLCAiY2hpbGRyZW4iOiBbXX1dfV19XX0sIHsidGl0bGUiOiAiQ29tbWVyY2lhbCBTdHJhdGVneSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImFjdGl2ZSIsICJ0eXBlIjogInBsYW4iLCAiaWQiOiAicHJvZHVjdC5zYWFzLmNvbW1lcmNpYWwiLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjRUMDk6NDA6NTUrMDE6MDAifSwgImNvbnRlbnQiOiAiVGhpcyBzZWN0aW9uIG91dGxpbmVzIHRoZSBzdHJhdGVneSBmb3IgbW9uZXRpemF0aW9uLCB1c2VyIGFjcXVpc2l0aW9uLCBhbmQgbWFya2V0IHZhbGlkYXRpb24uIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiRnJvbnRsaW5lIFRyaWFscyIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJwbGFuIiwgImlkIjogInByb2R1Y3Quc2Fhcy5jb21tZXJjaWFsLmZyb250bGluZSIsICJlc3RpbWF0ZSI6ICI0dyJ9LCAiY29udGVudCI6ICIqKk9iamVjdGl2ZSoqOiBWYWxpZGF0ZSB0aGUgcHJvZHVjdCB2YWx1ZSBwcm9wb3NpdGlvbiB3aXRoIHJlYWwgdXNlcnMgaW4gYSBsb3ctc3Rha2VzIGVudmlyb25tZW50LlxuKiAgICoqQXBwcm9hY2gqKjogXCJEbyB0aGluZ3MgdGhhdCBkb24ndCBzY2FsZS5cIiBEaXJlY3Qgb3V0cmVhY2ggdG8gZnJpZW5kbHkgU01CcyAoUmV0YWlsL0xvZ2lzdGljcykuXG4qICAgKipHb2FsKio6IDUtMTAgYWN0aXZlIHVzZXJzIHByb3ZpZGluZyB3ZWVrbHkgZmVlZGJhY2suXG4qICAgKipNb25ldGl6YXRpb24qKjogRnJlZSBvciBoZWF2aWx5IGRpc2NvdW50ZWQgaW4gZXhjaGFuZ2UgZm9yIGZlZWRiYWNrL3Rlc3RpbW9uaWFscy5cbiogICAqKk1ldHJpY3MqKjogRW5nYWdlbWVudCAoRGFpbHkgQWN0aXZlIFVzZXJzKSwgXCJNYWdpYyBNb21lbnRzXCIgKGUuZy4sIFwiVGhpcyBzYXZlZCBtZSAyIGhvdXJzXCIpLiIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJQYXltZW50IFNjaGVtYSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJwbGFuIiwgImlkIjogInByb2R1Y3Quc2Fhcy5jb21tZXJjaWFsLnBheW1lbnQiLCAiYmxvY2tlZF9ieSI6IFsicHJvZHVjdC5zYWFzLmNvbW1lcmNpYWwuZnJvbnRsaW5lIl0sICJlc3RpbWF0ZSI6ICIydyJ9LCAiY29udGVudCI6ICIqKk9iamVjdGl2ZSoqOiBCdWlsZCB0aGUgaW5mcmFzdHJ1Y3R1cmUgdG8gY2FwdHVyZSB2YWx1ZS5cbiogICAqKlRlY2gqKjogU3RyaXBlIC8gTGVtb24gU3F1ZWV6eSBpbnRlZ3JhdGlvbi5cbiogICAqKk1vZGVscyoqOlxuICAgICogICAqKkZyZWVtaXVtKio6IExvY2FsLW9ubHkgZmVhdHVyZXMgYXJlIGZyZWUuXG4gICAgKiAgICoqUHJvICgkMjkvbW8pKio6IENsb3VkIHN5bmMgKyBiYXNpYyBBbmFseXN0IEFnZW50IHVzYWdlICh0b2tlbiBjYXBwZWQpLlxuICAgICogICAqKkVudGVycHJpc2UgKEN1c3RvbSkqKjogRnVsbCBDb250cm9sbGVyIEFnZW50IGFjY2VzcyArIGRlZGljYXRlZCBzdXBwb3J0LlxuKiAgICoqRGVsaXZlcmFibGUqKjogQSBzZWFtbGVzcyBcIlVwZ3JhZGVcIiBmbG93IHdpdGhpbiB0aGUgU3RyZWFtbGl0IGFwcC4iLCAiY2hpbGRyZW4iOiBbXX0sIHsidGl0bGUiOiAiTWFya2V0aW5nICYgR3Jvd3RoIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInBsYW4iLCAiaWQiOiAicHJvZHVjdC5zYWFzLmNvbW1lcmNpYWwubWFya2V0aW5nIiwgImJsb2NrZWRfYnkiOiBbInByb2R1Y3Quc2Fhcy5jb21tZXJjaWFsLnBheW1lbnQiXX0sICJjb250ZW50IjogIioqT2JqZWN0aXZlKio6IFNjYWxlIGF3YXJlbmVzcyBhbmQgYWNxdWlzaXRpb24uXG4qICAgKipDb250ZW50IE1hcmtldGluZyoqOiBCbG9nIHBvc3RzL1ZpZGVvcyBkZW1vbnN0cmF0aW5nIFwiRGF0YSBTY2llbmNlIGZvciBOb24tRGF0YSBTY2llbnRpc3RzXCIgdXNpbmcgb3VyIGFwcC5cbiogICAqKk91dHJlYWNoKio6IFRhcmdldGVkIExpbmtlZEluIG91dHJlYWNoIHRvIE9wZXJhdGlvbnMgTWFuYWdlcnMgaW4gTG9naXN0aWNzL1JldGFpbC5cbiogICAqKkNoYW5uZWxzKio6XG4gICAgKiAgICoqT3JnYW5pYyoqOiBTRU8sIEdpdEh1YiAoT3BlbiBTb3VyY2UgY29yZT8pLlxuICAgICogICAqKlBhaWQqKjogVGFyZ2V0ZWQgYWRzIG9uIG5pY2hlIGluZHVzdHJ5IGZvcnVtcyAobGF0ZXIgc3RhZ2UpLiIsICJjaGlsZHJlbiI6IFtdfV19LCB7InRpdGxlIjogIkxlZ2FscyAmIEFkbWluIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInBsYW4iLCAiaWQiOiAibGVnYWwiLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjRUMDk6NTc6MjUrMDE6MDAifSwgImNvbnRlbnQiOiAiVGhpcyBzZWN0aW9uIGRldGFpbHMgdGhlIGFkbWluaXN0cmF0aXZlIGFuZCBsZWdhbCBpbmZyYXN0cnVjdHVyZSwgZGl2aWRlZCBieSBqdXJpc2RpY3Rpb24uIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiVVMgQnJhbmNoIChIZWFkcXVhcnRlcnMpIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAicGxhbiIsICJpZCI6ICJsZWdhbC51cyIsICJvd25lciI6ICJ1c2VyIn0sICJjb250ZW50IjogIioqUm9sZSoqOiBHbG9iYWwgUmV2ZW51ZSBDb2xsZWN0aW9uLCBDbG91ZCBTZXJ2aWNlcyBDb250cmFjdGluZywgSW50ZWxsZWN0dWFsIFByb3BlcnR5IEhvbGRlci4iLCAiY2hpbGRyZW4iOiBbeyJ0aXRsZSI6ICJCYW5raW5nICYgQ2xvdWQgQWNjb3VudGluZyIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImxlZ2FsLnVzLmJhbmtpbmciLCAiZXN0aW1hdGUiOiAiMXcifSwgImNvbnRlbnQiOiAiKipPYmplY3RpdmUqKjogRXN0YWJsaXNoIHRoZSBmaW5hbmNpYWwgaHViLlxuKiAgICoqQmFua2luZyoqOlxuICAgICogICAqKk1lcmN1cnkqKjogUmVjb21tZW5kZWQgKFplcm8gZmVlcywgaGlnaCB5aWVsZCkuXG4gICAgKiAgICoqQmFja3VwKio6IE5vdm8gLyBHcmFzc2hvcHBlci5cbiAgICAqICAgKipBY3Rpb24qKjogQXBwbHkgd2l0aCBFSU4gYW5kIEFydGljbGVzIG9mIE9yZ2FuaXphdGlvbi5cbiogICAqKkFjY291bnRpbmcqKjpcbiAgICAqICAgKipRdWlja0Jvb2tzIE9ubGluZSoqOiBDb25uZWN0IHRvIE1lcmN1cnkuXG4gICAgKiAgICoqUmV2ZW51ZSoqOiBTdHJpcGUgLyBBcHAgU3RvcmUgcGF5b3V0cyBsYW5kIGhlcmUuXG4gICAgKiAgICoqRXhwZW5zZXMqKjogUGF5IEdvb2dsZSBDbG91ZCAoR0NQL1dvcmtzcGFjZSksIEdpdEh1YiwgYW5kIEVPUi9Db250cmFjdG9yIGZlZXMgZnJvbSB0aGlzIGFjY291bnQuIiwgImNoaWxkcmVuIjogW119XX0sIHsidGl0bGUiOiAiQXJnZW50aW5hIEJyYW5jaCAoVGFsZW50IEh1YikiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAicGxhbiIsICJpZCI6ICJsZWdhbC5hciIsICJvd25lciI6ICJ1c2VyIn0sICJjb250ZW50IjogIioqUm9sZSoqOiBUYWxlbnQgQWNxdWlzaXRpb24sIFNvZnR3YXJlIERldmVsb3BtZW50IENlbnRlci4iLCAiY2hpbGRyZW4iOiBbeyJ0aXRsZSI6ICJFbnRpdHkgU2V0dXA6IFMuUi5MLiAoU29jaWVkYWQgZGUgUmVzcG9uc2FiaWxpZGFkIExpbWl0YWRhKSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImxlZ2FsLmFyLnNldHVwIiwgImVzdGltYXRlIjogIjR3In0sICJjb250ZW50IjogIioqT2JqZWN0aXZlKio6IEVzdGFibGlzaCBhIGxvY2FsIGVudGl0eSB0byBoaXJlIGZ1bGwtdGltZSBlbXBsb3llZXMgd2l0aG91dCBFT1IgbWFya3VwLlxuKiAgICoqU3RydWN0dXJlKio6XG4gICAgKiAgICoqUGFydG5lcnMqKjogUmVxdWlyZXMgMiBwYXJ0bmVycy4gT3B0aW9uczpcbiAgICAgICAgKiAgICoqT3B0aW9uIEEgKENvcnBvcmF0ZSBMaW5rKSoqOiBZb3UgOTUlICsgVVMgTExDIDUlICgqUmVxdWlyZXMgVVMgTExDIElHSiByZWdpc3RyYXRpb24qKS5cbiAgICAgICAgKiAgICoqT3B0aW9uIEIgKEZhc3QgUm91dGUpKio6IFlvdSA5NSUgKyBUcnVzdGVkIEluZGl2aWR1YWwgNSUgKCpBdm9pZHMgVVMgTExDIHBhcGVyd29yayopLlxuICAgICogICAqKkNhcGl0YWwqKjogfkFSUyAxMDAsMDAwIChTeW1ib2xpYykuIDI1JSBwYWlkIGF0IHNpZ25pbmcuXG4gICAgKiAgICoqTWFuYWdlcioqOiBNdXN0IGhhdmUgZG9taWNpbGUgaW4gQXJnZW50aW5hLiAoWW91IGNhbiBzZXJ2ZSBhcyBNYW5hZ2VyIHVzaW5nIHlvdXIgQXJnZW50aW5lIEROSS9QYXNzcG9ydCBpZiB5b3UgbWFpbnRhaW4gYSBsb2NhbCBhZGRyZXNzKS5cbiogICAqKlByb2Nlc3MqKjpcbiAgICAxLiAgKipOYW1lIFJlc2VydmF0aW9uKio6IENoZWNrIGF2YWlsYWJpbGl0eSB3aXRoIElHSi5cbiAgICAyLiAgKipCeWxhd3MgKENvbnRyYXRvIFNvY2lhbCkqKjogRHJhZnRlZCBieSBhIGxvY2FsIE5vdGFyeSBQdWJsaWMgKCpFc2NyaWJhbm8qKS5cbiAgICAzLiAgKipSZWdpc3RyYXRpb24qKjogRmlsZSB3aXRoIElHSiAoSW5zcGVjY2lcdTAwZjNuIEdlbmVyYWwgZGUgSnVzdGljaWEpLlxuICAgIDQuICAqKlRheCBJRCoqOiBPYnRhaW4gQ1VJVCBmcm9tIEFGSVAuXG4qICAgKipVUyBMTEMgUmVxdWlyZW1lbnQqKjogVG8gYmUgYSBwYXJ0bmVyLCB0aGUgVVMgTExDIG11c3QgcmVnaXN0ZXIgd2l0aCBJR0ogdW5kZXIgXCJBcnRpY2xlIDEyM1wiIChTaW1wbGlmaWVkIGluIDIwMjQsIG5vIGxvbmdlciBuZWVkIHRvIHByb3ZlIGFzc2V0cyBhYnJvYWQpLiIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJIaXJpbmcgJiBQYXlyb2xsIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAibGVnYWwuYXIuaGlyaW5nIiwgImJsb2NrZWRfYnkiOiBbImxlZ2FsLmFyLnNldHVwIl19LCAiY29udGVudCI6ICIqKk9iamVjdGl2ZSoqOiBIaXJlIGxvY2FsIGRldmVsb3BlcnMgbGVnYWxseS5cbiogICAqKlBheXJvbGwqKjpcbiAgICAqICAgKipSZWdpc3RyYXRpb24qKjogUmVnaXN0ZXIgYXMgRW1wbG95ZXIgKCpBbHRhIGRlIEVtcGxlYWRvciopIHdpdGggQUZJUC5cbiAgICAqICAgKipTZXJ2aWNlKio6IFVzZSBhIGxvY2FsIGFjY291bnRpbmcgZmlybSAoRXN0dWRpbyBDb250YWJsZSkgdG8gcHJvY2VzcyBtb250aGx5IHBheXNsaXBzICgqUmVjaWJvcyBkZSBTdWVsZG8qKSBhbmQgRjkzMSAoU29jaWFsIFNlY3VyaXR5KS5cbiogICAqKkJlbmVmaXRzKio6XG4gICAgKiAgICoqTWFuZGF0b3J5Kio6IDEzdGggU2FsYXJ5ICgqQWd1aW5hbGRvKiksIFZhY2F0aW9uICgxNCBkYXlzKSwgSGVhbHRoIEluc3VyYW5jZSAoKk9icmEgU29jaWFsKikuXG4gICAgKiAgICoqUGVya3MqKjogVVNEIFNwbGl0LXBheW1lbnQgKHBhcnQgb2Ygc2FsYXJ5IHBhaWQgYWJyb2FkKSBpcyBjb21tb24gZm9yIHJldGVudGlvbiwgYnV0IHJlcXVpcmVzIGNhcmVmdWwgdGF4IHN0cnVjdHVyaW5nICgqY29uc3VsdCBsb2NhbCBDUEEqKS4iLCAiY2hpbGRyZW4iOiBbXX1dfV19LCB7InRpdGxlIjogIlNlY3VyaXR5ICYgU2FmZXR5IENoZWNrcyIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImFjdGl2ZSIsICJ0eXBlIjogImd1aWRlbGluZSIsICJpZCI6ICJwcm9kdWN0LnNhYXMuc2VjdXJpdHkiLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjNUMTM6NDc6MDcrMDE6MDAifSwgImNvbnRlbnQiOiAiLSAgICoqSW5kaXJlY3QgRXhlY3V0aW9uKio6IENsaWVudHMgb25seSBzdWJtaXQgbmF0dXJhbCBsYW5ndWFnZSwgbmV2ZXIgY29kZS5cbi0gICAqKlJlcG9zaXRvcnkgU2NvcGluZyoqOiBHZW5lcmF0ZWQgY29kZSBjYW4gb25seSBpbXBvcnQgd2hpdGVsaXN0ZWQgbGlicmFyaWVzIChgcGFuZGFzYCwgYG51bXB5YCwgYGxpYl9hbmFseXNpc2ApLiBObyBgb3NgIG9yIGBzeXNgLlxuLSAgICoqU2ltdWxhdGlvbiBJc29sYXRpb24qKjogVXNlci1wcm92aWRlZCBsb2dpYyBydW5zIGluIGBnVmlzb3JgIHNhbmRib3hlcy5cbi0gICAqKkFjdGlvbiBCb3VuZGluZyoqOiBEZXRlcm1pbmlzdGljIGxvZ2ljIGxheWVyIHZhbGlkYXRlcyBhY3Rpb25zIGFnYWluc3Qgc2FmZXR5IGNvbnN0cmFpbnRzIChlLmcuLCBgTUFYX09SREVSX0xJTUlUYCkgYmVmb3JlIGV4ZWN1dGlvbi4iLCAiY2hpbGRyZW4iOiBbXX0sIHsidGl0bGUiOiAiUmVzZWFyY2ggRGlyZWN0aW9ucyIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImFjdGl2ZSIsICJ0eXBlIjogInBsYW4iLCAiaWQiOiAicHJvZHVjdC5zYWFzLnJlc2VhcmNoIiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTIzVDEzOjQ3OjA3KzAxOjAwIn0sICJjb250ZW50IjogIiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIkJyYWluc3Rvcm1pbmciLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJhY3RpdmUiLCAidHlwZSI6ICJwbGFuIiwgImlkIjogInByb2R1Y3Quc2Fhcy5yZXNlYXJjaC5icmFpbnN0b3JtaW5nIn0sICJjb250ZW50IjogIi0gICAqKk1CUkwgKERyZWFtZXJWMykqKjogTGVhcm5pbmcgV29ybGQgTW9kZWxzIGZyb20gdGVsZW1ldHJ5IHRvIHNpbXVsYXRlIGVudmlyb25tZW50cy5cbi0gICAqKlNhZmUgUkwqKjogQ29uc3RyYWluZWQgTURQcyAoTGFncmFuZ2lhbiBSZWxheGF0aW9uKSB0byBlbnN1cmUgc2FmZXR5IGR1cmluZyBleHBsb3JhdGlvbi5cbi0gICAqKlJlZmxleGlvbioqOiBBZ2VudHMgdGhhdCBhbmFseXplIHRoZWlyIG93biB0cmFjZWJhY2tzIHRvIGl0ZXJhdGl2ZWx5IGZpeCBjb2RlLiIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJSTCBQcm90b2NvbHMiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAicGxhbiIsICJpZCI6ICJwcm9kdWN0LnNhYXMucmVzZWFyY2gucmxfcHJvdG9jb2xzIn0sICJjb250ZW50IjogIltTb3VyY2UgRGlzY3Vzc2lvbl0oaHR0cHM6Ly9jbGF1ZGUuYWkvc2hhcmUvYjg5YWMwOTUtM2RiMi00ZjFjLTliYzEtMzE2ZDhmNjkxNjM3KVxuXG4qKlByb3RvY29sIEV2b2x1dGlvbiB2aWEgUmVpbmZvcmNlbWVudCBMZWFybmluZyoqXG5cbioqQ29yZSBJZGVhKipcblxuVHJlYXQgY29tbXVuaWNhdGlvbiBwcm90b2NvbHMgKGxpa2UgTUNQKSBhcyAqKnNpZ25hbGluZyBzeXN0ZW1zKiogdGhhdCBjYW4gYmUgb3B0aW1pemVkIHVzaW5nIHJlaW5mb3JjZW1lbnQgbGVhcm5pbmcuIEluc3RlYWQgb2YgZGVzaWduaW5nIHByb3RvY29scyB0b3AtZG93biwgbGV0IHRoZW0gZXZvbHZlIGJhc2VkIG9uIHRhc2sgc3VjY2VzcyBzaWduYWxzIGZyb20gUkxIRi5cblxuVGhlIGluc2lnaHQgY29tZXMgZnJvbSBzaWduYWwtdHJhZGluZyBnYW1lczogbWVhbmluZ2Z1bCBjb21tdW5pY2F0aW9uIGNhbiBlbWVyZ2Ugd2l0aG91dCBleHBsaWNpdGx5IGNvb3BlcmF0aXZlIHBheW9mZnMuIFdoYXQgbWF0dGVycyBpcyB0aGUgbmV0d29yayBzdHJ1Y3R1cmUgKHNpZ25hbCBjaGFubmVscyBleGlzdCkgYW5kIGxlYXJuaW5nIGR5bmFtaWNzIChhZ2VudHMgaW1wcm92ZSBvdmVyIHRpbWUpLlxuXG4qKkZyYW1ld29yayoqXG5cbioqU3RhdGUqKjogVGFzayBjb250ZXh0ICh3aGF0IHRoZSBMTE0gaXMgdHJ5aW5nIHRvIGFjY29tcGxpc2gpXG5cbioqQWN0aW9uKio6IFdoaWNoIGRlc2NyaXB0aW9uIHZhcmlhbnQgdG8gdXNlIGZvciBhIHByb3RvY29sIGZ1bmN0aW9uXG5cbioqUmV3YXJkKio6IFJMSEYgc2lnbmFsICh0YXNrIHN1Y2Nlc3Mgb3IgZmFpbHVyZSlcblxuKipMZWFybmluZyoqOiBEUU4tc3R5bGUgdXBkYXRlcyBvdmVyIGRlc2NyaXB0aW9uIHZhcmlhbnRzXG5cbioqRGVzaWduIENob2ljZXMqKlxuXG58IEFzcGVjdCB8IENob2ljZSB8IFJhdGlvbmFsZSB8XG58LS0tLS0tLS18LS0tLS0tLS18LS0tLS0tLS0tLS18XG58IEdyYW51bGFyaXR5IHwgSW5kaXZpZHVhbCBmdW5jdGlvbiBkZXNjcmlwdGlvbnMgfCBMb2NhbCwgY29tcG9zYWJsZSwgdGVzdGFibGUgZXZvbHV0aW9uIHxcbnwgQ3JlZGl0IGFzc2lnbm1lbnQgfCBCbGFtZSB0aGUgcHJvdG9jb2wgfCBMTE0tYWdub3N0aWM7IGZvcmNlcyBwcm90b2NvbCByb2J1c3RuZXNzIHxcbnwgTGVhcm5pbmcgcnVsZSB8IERRTiB8IEhhbmRsZXMgY29udGludW91cyBkZXNjcmlwdGlvbiBzcGFjZSB2aWEgZnVuY3Rpb24gYXBwcm94aW1hdGlvbiB8XG58IExvY2FsIGNvbnZlbnRpb25zIHwgRmVhdHVyZSwgbm90IGJ1ZyB8IERpZmZlcmVudCBMTE1cdTIxOTRUb29sIHBhaXJzIGNhbiBzcGVjaWFsaXplIHxcblxuKipXaHkgRFFOKipcblxuVGFidWxhciBRLWxlYXJuaW5nIChhcyBpbiB0aGUgc2lnbmFsLXRyYWRpbmcgcGFwZXIpIHdvcmtzIGZvciBzbWFsbCBkaXNjcmV0ZSBzaWduYWwgc3BhY2VzLiBCdXQgZnVuY3Rpb24gZGVzY3JpcHRpb25zIGxpdmUgaW4gaGlnaC1kaW1lbnNpb25hbCBuYXR1cmFsIGxhbmd1YWdlIHNwYWNlLiBEUU4gcHJvdmlkZXM6XG5cbi0gR2VuZXJhbGl6YXRpb24gYWNyb3NzIHNpbWlsYXIgZGVzY3JpcHRpb25zXG4tIEV4cGVyaWVuY2UgcmVwbGF5IGZvciBzdGFibGUgbGVhcm5pbmdcbi0gU2NhbGFiaWxpdHkgdG8gbGFyZ2UgdmFyaWFudCBwb29sc1xuXG4qKkluZm9ybWF0aW9uIEZsb3cgTWVhc3VyZW1lbnQqKlxuXG5BZGFwdCBOb3JtYWxpemVkIE11dHVhbCBJbmZvcm1hdGlvbiAoTk1JKSBmcm9tIHRoZSBzaWduYWwtdHJhZGluZyBwYXBlcjpcblxuKipJKERlc2NyaXB0aW9uOyBUYXNrU3VjY2VzcykqKiBtZWFzdXJlcyBob3cgd2VsbCB0aGUgY2hvaWNlIG9mIGRlc2NyaXB0aW9uIHByZWRpY3RzIHRhc2sgb3V0Y29tZS4gSGlnaGVyIE5NSSBtZWFucyB0aGUgcHJvdG9jb2wgY2FycmllcyBtb3JlIHVzZWZ1bCBpbmZvcm1hdGlvbi5cblxuKipUaGUgRGlzdHJpYnV0ZWQgQXNwZWN0KipcblxuVGhlIG5ldHdvcmsgdG9wb2xvZ3kgbWlycm9ycyBzaWduYWwtdHJhZGluZyBnYW1lczpcblxuYGBgXG4gICAgSHVtYW5cbiAgICAgIFx1MjE5NSAoUkxIRilcbiAgICBMTE0gXHUyMTkwXHUyMDE0cHJvdG9jb2xcdTIwMTRcdTIxOTIgTUNQIEhvc3RcbiAgICAgIFx1MjE5NSAgICAgICAgICAgICAgICAgIFx1MjE5NVxuICAgVG9vbFx1MjA4MSAgICAgICAgICAgICAgVG9vbFx1MjA4MlxuYGBgXG5cbkVhY2ggZWRnZSBpcyBhIHNpZ25hbCBjaGFubmVsIHdpdGggaW5kZXBlbmRlbnQgcmV3YXJkcy4gQ29vcGVyYXRpb24gZW1lcmdlcyBmcm9tIHRoZSBjaGFubmVsIHN0cnVjdHVyZSwgbm90IGFsaWduZWQgcGF5b2Zmc1x1MjAxNGV4YWN0bHkgYXMgdGhlIHBhcGVyIHByZWRpY3RzLlxuXG4qKkNvbm5lY3Rpb24gdG8gR3JpY2UncyBDb29wZXJhdGl2ZSBQcmluY2lwbGUqKlxuXG5UaGUgcGFwZXIgYXJndWVzIHRoYXQgdGhlIENvb3BlcmF0aXZlIFByaW5jaXBsZSBpc24ndCBlbmNvZGVkIGluIHBheW9mZiBtYXRyaWNlcyBidXQgaW4gdGhlIG5ldHdvcmsgb2Ygc2lnbmFsIGNoYW5uZWxzIGl0c2VsZi4gT3BlbmluZyBhIGNvbW11bmljYXRpb24gY2hhbm5lbCBpbXBsaWVzIGNvbW1pdG1lbnQgdG8gaW5mb3JtYXRpb24gZXhjaGFuZ2UuIFRoZSBwcm90b2NvbCBzY2hlbWEgZW1ib2RpZXMgdGhpcyBjb21taXRtZW50OyBSTEhGIHRlYWNoZXMgYWdlbnRzIHRvIGhvbm9yIGl0IGVmZmVjdGl2ZWx5LiIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJDbGF3ZGJvdCArIE1hYyBtaW5pIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInBsYW4iLCAiaWQiOiAicHJvZHVjdC5zYWFzLnJlc2VhcmNoLmNsYXdkYm90IiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTI1VDEzOjQwOjQwKzAxOjAwIn0sICJjb250ZW50IjogIkEgcmVzZWFyY2ggZGlyZWN0aW9uIGluc3BpcmVkIGJ5IHRoZSBbQ2xhd2Rib3QgcHJvamVjdF0oaHR0cHM6Ly9naXRodWIuY29tL2NsYXdkYm90L2NsYXdkYm90KSB0byBjcmVhdGUgYSBcIlBlcnNvbmFsIEFJIEFzc2lzdGFudFwiIHRoYXQgcnVucyBsb2NhbGx5IG9uIGEgTWFjIG1pbmkgYnV0IGludGVyYWN0cyB2aWEgY2hhdCBhcHBzIChUZWxlZ3JhbS9pTWVzc2FnZSkuXG5cbioqS2V5IEltcGxlbWVudGF0aW9uIEZlYXR1cmVzKio6XG4qICAgKipBcmNoaXRlY3R1cmUqKjogSG9zdGVkIG9uIGFuIGFsd2F5cy1vbiBNNCBNYWMgbWluaSB3aXRoIGRpcmVjdCBzaGVsbCBhY2Nlc3MgZm9yIGV4ZWN1dGluZyBjb21tYW5kcywgbWFuYWdpbmcgZmlsZXMsIGFuZCBpbnN0YWxsaW5nIGRlcGVuZGVuY2llcy5cbiogICAqKkdhdGV3YXkgSW50ZXJmYWNlKio6IEEgZGFlbW9uIGJyaWRnaW5nIHRoZSBsb2NhbCBhZ2VudCB0byBUZWxlZ3JhbS9pTWVzc2FnZSwgYWxsb3dpbmcgXCJDaGF0IHdpdGggeW91ciBzZXJ2ZXJcIiBmdW5jdGlvbmFsaXR5IHdpdGhvdXQgYSB3ZWIgVUkuXG4qICAgKipNZW1vcnkgU3lzdGVtKio6IFVzZXMgZGFpbHkgTWFya2Rvd24gbm90ZXMgaW5kZXhlZCBieSB0b29scyBsaWtlIE9ic2lkaWFuIG9yIFJheWNhc3QgZm9yIGxvbmctdGVybSBjb250ZXh0IGFuZCBodW1hbiByZXRyaWV2YWwuXG4qICAgKipSZWN1cnNpdmUgU2VsZi1JbXByb3ZlbWVudCoqOiBUaGUgYWdlbnQgY2FuIHJlc2VhcmNoLCB3cml0ZSwgYW5kIGluc3RhbGwgaXRzIG93biBcIlNraWxsc1wiIChNQ1Agc2VydmVycy9zY3JpcHRzKSB0byBkeW5hbWljYWxseSBleHBhbmQgaXRzIGNhcGFiaWxpdGllcy5cbiogICAqKkludGVncmF0aW9ucyoqOiBQbGFubmVkIHN1cHBvcnQgZm9yIEhvbWUgQ29udHJvbCAoSHVlL1Nvbm9zKSwgUHJvZHVjdGl2aXR5IChOb3Rpb24vR21haWwpLCBhbmQgVm9pY2UvVmlzaW9uIChFbGV2ZW5MYWJzL05hbm8gQmFuYW5hKS4iLCAiY2hpbGRyZW4iOiBbXX1dfV19LCAiZGVwZW5kZW5jaWVzIjogW3sic291cmNlIjogImltcGxlbWVudGF0aW9uLnBoYXNlMS5pbml0IiwgInRhcmdldCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTEud2FyZWhvdXNlIn0sIHsic291cmNlIjogImltcGxlbWVudGF0aW9uLnBoYXNlMS53YXJlaG91c2UubWFuYWdlciIsICJ0YXJnZXQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLndhcmVob3VzZS5pbmdlc3QifSwgeyJzb3VyY2UiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLndhcmVob3VzZSIsICJ0YXJnZXQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLnVpIn0sIHsic291cmNlIjogImltcGxlbWVudGF0aW9uLnBoYXNlMS51aS5sYXlvdXQiLCAidGFyZ2V0IjogImltcGxlbWVudGF0aW9uLnBoYXNlMS51aS5jaGF0In0sIHsic291cmNlIjogImltcGxlbWVudGF0aW9uLnBoYXNlMS51aSIsICJ0YXJnZXQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLnRlc3RpbmcifSwgeyJzb3VyY2UiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLnRlc3RpbmcudW5pdCIsICJ0YXJnZXQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLnRlc3RpbmcuaW50ZWdyYXRpb24ifSwgeyJzb3VyY2UiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLnRlc3RpbmciLCAidGFyZ2V0IjogImltcGxlbWVudGF0aW9uLnBoYXNlMS5wYWNrYWdpbmcifSwgeyJzb3VyY2UiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxIiwgInRhcmdldCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIifSwgeyJzb3VyY2UiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UyLmluZnJhLnNldHVwIiwgInRhcmdldCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIuaW5mcmEuaWFjIn0sIHsic291cmNlIjogImltcGxlbWVudGF0aW9uLnBoYXNlMi5pbmZyYSIsICJ0YXJnZXQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UyLmF1dGgifSwgeyJzb3VyY2UiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UyLmF1dGgiLCAidGFyZ2V0IjogImltcGxlbWVudGF0aW9uLnBoYXNlMi5hcGkifSwgeyJzb3VyY2UiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UyLmFwaS5kZXYiLCAidGFyZ2V0IjogImltcGxlbWVudGF0aW9uLnBoYXNlMi5hcGkuZGVwbG95In0sIHsic291cmNlIjogImltcGxlbWVudGF0aW9uLnBoYXNlMi5hcGkiLCAidGFyZ2V0IjogImltcGxlbWVudGF0aW9uLnBoYXNlMi5waXBlbGluZSJ9LCB7InNvdXJjZSI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIucGlwZWxpbmUuZ2NzIiwgInRhcmdldCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIucGlwZWxpbmUuYmlncXVlcnkifSwgeyJzb3VyY2UiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UyIiwgInRhcmdldCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTMifSwgeyJzb3VyY2UiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UzLmFyY2giLCAidGFyZ2V0IjogImltcGxlbWVudGF0aW9uLnBoYXNlMy5hbmFseXN0In0sIHsic291cmNlIjogImltcGxlbWVudGF0aW9uLnBoYXNlMy5hbmFseXN0IiwgInRhcmdldCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTMuY29udHJvbGxlciJ9LCB7InNvdXJjZSI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTMuY29udHJvbGxlciIsICJ0YXJnZXQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UzLm9wcyJ9LCB7InNvdXJjZSI6ICJwcm9kdWN0LnNhYXMuY29tbWVyY2lhbC5mcm9udGxpbmUiLCAidGFyZ2V0IjogInByb2R1Y3Quc2Fhcy5jb21tZXJjaWFsLnBheW1lbnQifSwgeyJzb3VyY2UiOiAicHJvZHVjdC5zYWFzLmNvbW1lcmNpYWwucGF5bWVudCIsICJ0YXJnZXQiOiAicHJvZHVjdC5zYWFzLmNvbW1lcmNpYWwubWFya2V0aW5nIn0sIHsic291cmNlIjogImxlZ2FsLmFyLnNldHVwIiwgInRhcmdldCI6ICJsZWdhbC5hci5oaXJpbmcifV19";
    if (rawData.startsWith("__DATA")) {
        log("Error: Placeholder not replaced.");
    } else {
        const data = decodeData(rawData);
        if (data && typeof d3 !== 'undefined') {
            log("D3 loaded. Version: " + d3.version);
            document.getElementById('loading').style.display = 'none';
            parsedData = data.tree ? data : { tree: data, dependencies: [] }; // Handle legacy format if needed
            initViz(parsedData);
        } else {
            if (typeof d3 === 'undefined') {
                handleScriptError();
            } else {
                log("Error: Data is null.");
            }
        }
    }
} catch (globalErr) {
    log("Global Error: " + globalErr.message);
}

function initViz(fullData) {
    log("Initializing Visualization...");
    try {
        const width = window.innerWidth;
        const height = window.innerHeight;

        svg = d3.select("svg");
        
        // Clear previous if any
        svg.selectAll("*").remove();
        
        // Defs for arrows
        const defs = svg.append("defs");
        defs.append("marker")
            .attr("id", "arrowhead")
            .attr("refX", 10) /* adjust based on node radius */
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-2.5 L6,0 L0,2.5")
            .style("fill", "#e74c3c");

        g = svg.append("g");

        zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on("zoom", (event) => g.attr("transform", event.transform));

        svg.call(zoom);

        // Define tree layout params
        // nodeSize depends on orientation. 
        // For standard top-down: [width, height]
        // For left-right (projecting y as x): [height, width]
        tree = d3.tree().nodeSize([40, 300]); 

        root = d3.hierarchy(fullData.tree, d => d.children);
        root.x0 = 0;
        root.y0 = 0;

        // Check if root has children
        if (!root.children) {
            log("Warning: Root has no children.");
        } else {
            log("Root children count: " + root.children.length);
        }

        // Collapse
        if(root.children) {
            root.children.forEach(collapseRecursive);
        }

        update(root);
        
        // Initial center
        const initialTransform = d3.zoomIdentity.translate(100, height / 2).scale(1);
        svg.call(zoom.transform, initialTransform);
        
        log("Viz Initialized.");

    } catch (vizErr) {
        log("Viz Error: " + vizErr.message);
        log(vizErr.stack);
    }
}

function collapseRecursive(d) {
  if(d.children) {
    d._children = d.children;
    d.children.forEach(collapseRecursive);
    d.children = null;
  }
}

function expandAll() {
    function recurse(d) {
        if (d._children) {
            d.children = d._children;
            d._children = null;
        }
        if (d.children) d.children.forEach(recurse);
    }
    recurse(root);
    update(root);
}

function collapseAll() {
    if (root.children) root.children.forEach(collapseRecursive);
    update(root);
}

function resetZoom() {
    const height = window.innerHeight;
    svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity.translate(100, height/2).scale(1));
}

function toggleDeps() {
    showDependencies = !showDependencies;
    update(root);
}

function update(source) {
  const treeData = tree(root);

  // Compute the new tree layout.
  const nodes = treeData.descendants();
  const links = treeData.links();

  // Normalize for left-right tree
  // Swap x and y for horizontal layout
  nodes.forEach(d => { d.y = d.depth * 300; });

  // Node Map for calculating dependencies
  const nodeMap = new Map();
  nodes.forEach(d => {
      // Key can be ID or Node Title (fallback)
      if (d.data.metadata && d.data.metadata.id) {
          nodeMap.set(d.data.metadata.id, d);
      }
      // Also map by title for redundancy if needed, but ID is preferred
  });


  // ****************** Links (Hierarchy) ***************************
  const link = g.selectAll('path.link')
      .data(links, d => d.target.id);

  const linkEnter = link.enter().insert('path', "g")
      .attr("class", "link")
      .attr('d', d => {
        const o = {x: source.x0, y: source.y0};
        return diagonal(o, o);
      });

  const linkUpdate = linkEnter.merge(link);

  linkUpdate.transition()
      .duration(duration)
      .attr('d', d => diagonal(d.source, d.target));

  link.exit().transition()
      .duration(duration)
      .attr('d', d => {
        const o = {x: source.x, y: source.y};
        return diagonal(o, o);
      })
      .remove();

  // ****************** Dependency Links (Explicit) ***************************
  // Calculate active dependencies based on current visible nodes
  let depLinksData = [];
  if (showDependencies && parsedData.dependencies) {
      parsedData.dependencies.forEach(dep => {
          const sourceNode = nodeMap.get(dep.source);
          const targetNode = nodeMap.get(dep.target);
          
          if (sourceNode && targetNode) {
              depLinksData.push({source: sourceNode, target: targetNode});
          }
      });
  }

  const depLink = g.selectAll('path.dep-link')
      .data(depLinksData, d => d.source.id + "-" + d.target.id);

  const depLinkEnter = depLink.enter().append('path')
      .attr("class", "dep-link")
      .attr('d', d => {
           // Start from wherever the source is currently (animation) -> usually nice to just fade in or pop in
           // For simplicity, we calculate the curve immediately or use the source position
           return dependencyPath(d.source, d.target);
      })
      .style("opacity", 0);

  depLinkEnter.transition().duration(duration).style("opacity", 0.6);

  depLink.transition().duration(duration)
      .attr('d', d => dependencyPath(d.source, d.target))
      .style("opacity", 0.6);

  depLink.exit().transition().duration(duration).style("opacity", 0).remove();


  // ****************** Nodes ***************************
  const node = g.selectAll('g.node')
      .data(nodes, d => d.id || (d.id = ++i));

  const nodeEnter = node.enter().append('g')
      .attr('class', 'node')
      .attr("transform", d => "translate(" + source.y0 + "," + source.x0 + ")")
      .on('click', click);

  nodeEnter.append('circle')
      .attr('r', 1e-6)
      .attr('class', d => {
          const status = (d.data.metadata && d.data.metadata.status) || 'default';
          return `status-${status.replace(' ', '-')}`;
      });

  nodeEnter.append('text')
      .attr("dy", ".35em")
      .attr("x", d => d.children || d._children ? -13 : 13)
      .attr("text-anchor", d => d.children || d._children ? "end" : "start")
      .text(d => {
          let title = d.data.title;
          return title.length > 30 ? title.substring(0, 30) + '...' : title;
      })
      .style('fill-opacity', 1e-6);

  const nodeUpdate = nodeEnter.merge(node);

  nodeUpdate.transition()
      .duration(duration)
      .attr("transform", d => "translate(" + d.y + "," + d.x + ")");

  nodeUpdate.select('circle')
      .attr('r', 8)
      .style("fill", d => d._children ? "#fff" : "") 
      .attr('class', d => `status-${((d.data.metadata && d.data.metadata.status) || 'default').replace(' ', '-')}`);

  nodeUpdate.select('text').style("fill-opacity", 1);

  const nodeExit = node.exit().transition()
      .duration(duration)
      .attr("transform", d => "translate(" + source.y + "," + source.x + ")")
      .remove();

  nodeExit.select('circle').attr('r', 1e-6);
  nodeExit.select('text').style('fill-opacity', 1e-6);


  nodes.forEach(d => {
    d.x0 = d.x;
    d.y0 = d.y;
  });

  function diagonal(s, d) {
    return `M ${s.y} ${s.x}
            C ${(s.y + d.y) / 2} ${s.x},
              ${(s.y + d.y) / 2} ${d.x},
              ${d.y} ${d.x}`;
  }

  function dependencyPath(s, t) {
      // Custom path for dependencies - larger arc to avoid hierarchy lines?
      // Or just a straightish Bezier
      const dx = t.y - s.y;
      const dy = t.x - s.x;
      const dr = Math.sqrt(dx * dx + dy * dy) * 1.5; // Controls curvature
      
      // Arc path
      return `M${s.y},${s.x}A${dr},${dr} 0 0,1 ${t.y},${t.x}`;
  }

  function click(event, d) {
    showDetails(d.data);
    if (d.children) {
        d._children = d.children;
        d.children = null;
    } else {
        d.children = d._children;
        d._children = null;
    }
    update(d);
  }
}

function showDetails(data) {
    const sidebar = document.getElementById('sidebar');
    const container = document.getElementById('details');
    sidebar.style.display = 'block';

    const status = (data.metadata.status || 'todo').replace(' ', '-');
    
    let metaHtml = '';
    for (const [key, value] of Object.entries(data.metadata)) {
        if (key === 'status') continue;
        metaHtml += `<div><strong>${key}:</strong> ${JSON.stringify(value).replace(/"/g, '')}</div>`;
    }

    container.innerHTML = `
        <span class="meta-tag tag-${status}">${status.toUpperCase().replace('-', ' ')}</span>
        <h2>${data.title}</h2>
        <div style="margin-bottom: 20px; font-size: 0.9em; color: #7f8c8d;">
            ${metaHtml}
        </div>
        <hr style="border: 0; border-top: 1px solid #eee;"/>
        <div class="content-block">
            <pre style="background:none; padding:0; white-space: pre-wrap; font-family: inherit;">${data.content || "No content."}</pre>
        </div>
    `;
}
</script>
</body>
</html>
