
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Master Plan Visualization</title>
  <script src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js"></script>
  <script>
    if (typeof d3 === 'undefined') {
        document.write('<script src="d3.min.js" onerror="handleScriptError()"><\/script>');
    }
  </script>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 0; overflow: hidden; background: #f8f9fa; }
    #container { width: 100vw; height: 100vh; display: flex; }
    #viz { flex-grow: 1; height: 100%; position: relative; }
    #sidebar { width: 400px; height: 100vh; background: white; border-left: 1px solid #ddd; padding: 20px; box-sizing: border-box; overflow-y: auto; display: none; box-shadow: -2px 0 5px rgba(0,0,0,0.05); z-index: 10; transform: translateX(0); transition: transform 0.3s ease; }
    
    .node circle { fill: #fff; stroke: steelblue; stroke-width: 2px; cursor: pointer; transition: all 0.3s; }
    .node circle:hover { stroke-width: 4px; }
    .node text { font: 12px sans-serif; cursor: pointer; text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff; }
    
    .link { fill: none; stroke: #ccc; stroke-width: 1.5px; transition: all 0.5s; stroke-opacity: 0.6; }

    .dep-link { fill: none; stroke: #e74c3c; stroke-width: 1.5px; stroke-dasharray: 4; marker-end: url(#arrowhead); opacity: 0.6; }
    .dep-link:hover { opacity: 1.0; stroke-width: 2.5px; }

    /* Metadata Colors */
    .status-done { stroke: #2ecc71 !important; fill: #e8f8f5; }
    .status-active, .status-in-progress { stroke: #3498db !important; fill: #ebf5fb; }
    .status-todo { stroke: #bdc3c7 !important; fill: #fbfcfc; }
    .status-blocked { stroke: #e74c3c !important; fill: #fdedec; }
    
    h2 { margin-top: 0; font-size: 1.5em; color: #2c3e50; }
    .meta-tag { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 0.85em; margin-right: 5px; margin-bottom: 5px; color: white; font-weight: 500;}
    
    .tag-todo { background: #95a5a6; }
    .tag-active, .tag-in-progress { background: #3498db; }
    .tag-done { background: #2ecc71; }
    .tag-blocked { background: #e74c3c; }
    .tag-default { background: #7f8c8d; }

    pre { background: #f4f6f7; padding: 10px; border-radius: 4px; overflow-x: auto; font-size: 0.9em; white-space: pre-wrap; }
    .content-block { line-height: 1.6; color: #34495e; font-size: 0.95em; }

    .control-panel { position: absolute; top: 20px; left: 20px; background: rgba(255, 255, 255, 0.9); padding: 10px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    button { background: #3498db; color: white; border: none; padding: 5px 12px; border-radius: 4px; cursor: pointer; font-size: 13px; margin-right: 5px; }
    button:hover { background: #2980b9; }

    #debug-log { position: absolute; bottom: 10px; left: 10px; font-family: monospace; font-size: 10px; color: #aaa; pointer-events: none; z-index: 100; max-height: 200px; overflow: hidden; }
    #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1.5em; color: #666; background: rgba(255,255,255,0.8); padding: 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
  </style>
</head>
<body>

<div id="container">
  <div id="viz">
    <div id="loading">Initializing...</div>
    <div id="debug-log"></div>
    <svg width="100%" height="100%"></svg>
    <div class="control-panel">
        <button onclick="expandAll()">Expand All</button>
        <button onclick="collapseAll()">Collapse All</button>
        <button onclick="resetZoom()">Reset Zoom</button>
        <button onclick="toggleDeps()">Toggle Dependencies</button>
    </div>
  </div>
  <div id="sidebar">
    <div id="details">
        <h2 style="color: #bbb;">Select a node...</h2>
    </div>
  </div>
</div>

<script>
// Global Variables - Must be declared before use
let root, svg, g, zoom, tree;
let i = 0;
let duration = 500;
let parsedData = null;
let showDependencies = true;

function log(msg) {
    console.log(msg);
    const logDiv = document.getElementById('debug-log');
    if (logDiv) logDiv.innerHTML += msg + "<br>";
}

function handleScriptError() {
    log("ERROR: Failed to load D3.js. Check if d3.min.js exists in the same folder.");
    document.getElementById('loading').innerHTML = "Error: D3.js missing.<br><small>Ensure d3.min.js is in the folder.</small>";
}

// Base64 Decode
function decodeData(enc) {
    try {
        log("Decoding data...");
        const jsonStr = new TextDecoder().decode(Uint8Array.from(atob(enc), c => c.charCodeAt(0)));
        log("Data decoded. Length: " + jsonStr.length);
        return JSON.parse(jsonStr);
    } catch(e) {
        log("Decoding error: " + e.message);
        document.getElementById('loading').innerText = "Error decoding data";
        return null;
    }
}

// Data Injection
try {
    const rawData = "eyJ0cmVlIjogeyJ0aXRsZSI6ICJNYXN0ZXIgUGxhbjogSW50ZWxsaWdlbnQgQ29udHJvbCBTYWFTIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAicGxhbiIsICJpZCI6ICJtYXN0ZXJfcGxhbi5zYWFzIiwgIm93bmVyIjogInByb2R1Y3QtbWFuYWdlciIsICJwcmlvcml0eSI6ICJjcml0aWNhbCIsICJjb250ZXh0X2RlcGVuZGVuY2llcyI6IHsibWFuYWdlciI6ICJNQU5BR0VSX0FHRU5ULm1kIiwgImNvbnZlbnRpb25zIjogIi4uLy4uL01EX0NPTlZFTlRJT05TLm1kIn0sICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QxNToxNDoyNSswMTowMCJ9LCAiY29udGVudCI6ICJUaGlzIGRvY3VtZW50IHNlcnZlcyBhcyB0aGUgY2VudHJhbCBzdHJhdGVnaWMgcGxhbiBmb3IgdGhlICoqSW50ZWxsaWdlbnQgQ29udHJvbCAmIEFuYWx5c2lzIFBsYXRmb3JtKiouIEl0IGlzIGEgZHVhbC1lbmdpbmUgQUkgc3lzdGVtIGZ1bmN0aW9uaW5nIGFzIGJvdGggYSAqKkJ1c2luZXNzIEFuYWx5c3QqKiBhbmQgYW4gKipBdXRvbm9tb3VzIE9wZXJhdG9yKiogZm9yIFNNQnMgYW5kIGluZHVzdHJpYWwgY2xpZW50cy4gSXQgY29tYmluZXMgTExNIHJlYXNvbmluZyAoQW5hbHlzaXMpIHdpdGggUkwgY29udHJvbCAoT3B0aW1pemF0aW9uKS4iLCAiY2hpbGRyZW4iOiBbeyJ0aXRsZSI6ICJFeGVjdXRpdmUgU3VtbWFyeSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImRvbmUiLCAidHlwZSI6ICJjb250ZXh0IiwgImlkIjogInByb2R1Y3Quc2Fhcy5zdW1tYXJ5IiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTIzVDEzOjQ3OjA3KzAxOjAwIn0sICJjb250ZW50IjogIioqVGhlIFZpc2lvbioqOiBUbyBlbXBvd2VyIGV2ZXJ5IFNNQiB3aXRoIGEgRm9ydHVuZSA1MDAtZ3JhZGUgRGF0YSBTY2llbmNlICYgT3BlcmF0aW9ucyB0ZWFtXHUyMDE0aW5zdGFudGx5LiBXZSBicmlkZ2UgdGhlIGdhcCBiZXR3ZWVuIHJhdyBkYXRhIGFuZCBwcm9maXRhYmxlIGFjdGlvbiBieSBjb21iaW5pbmcgbmF0dXJhbCBsYW5ndWFnZSBpbnR1aXRpb24gd2l0aCByaWdvcm91cyBtYXRoZW1hdGljYWwgaW1wbGVtZW50YXRpb24uXG5cbioqVGhlIFByb2JsZW0qKjogU21hbGwgYW5kIG1pZC1zaXplZCBidXNpbmVzc2VzIChTTUJzKSBhY3Jvc3MgUmV0YWlsIGFuZCBMb2dpc3RpY3MgYXJlIGRyb3duaW5nIGluIHNwcmVhZHNoZWV0cy4gVGhleSBmYWNlIGNvbXBsZXggaW52ZW50b3J5IGRpbGVtbWFzIGFuZCBvcGVyYXRpb25hbCBpbmVmZmljaWVuY2llcyBidXQgY2Fubm90IGFmZm9yZCBhIGRlZGljYXRlZCBEYXRhIFNjaWVuY2UgdGVhbS4gVGhleSBvcGVyYXRlIG9uIFwiZ3V0IGZlZWxpbmdcIiByYXRoZXIgdGhhbiBvcHRpbWFsIGNvbnRyb2wuXG5cbioqVGhlIFNvbHV0aW9uKio6IEFuICoqSW50ZWxsaWdlbnQgQ29udHJvbCBTYWFTKiogdGhhdCBmdW5jdGlvbnMgYXMgYSBkdWFsLWVuZ2luZSBBSSBwYXJ0bmVyOlxuMS4gICoqVGhlIFwiVmlydHVhbCBDaGllZiBBbmFseXN0XCIgKFVuZGVyc3RhbmRpbmcpKio6IEEgQ29kZSBJbnRlcnByZXRlciBhZ2VudCB0aGF0IHR1cm5zIFwiV2h5IGFyZSBzYWxlcyBkb3duP1wiIGludG8gaW5zdGFudCwgdmlzdWFsaXplZCwgc3RhdGlzdGljYWwgdHJ1dGhcdTIwMTRub3QganVzdCB0ZXh0IHN1bW1hcmllcy5cbjIuICAqKlRoZSBcIkF1dG9ub21vdXMgT3BlcmF0b3JcIiAoQWN0aW9uKSoqOiBBbiBSTC1kcml2ZW4gQ29udHJvbGxlciB0aGF0IHR1cm5zIFwiT3B0aW1pemUgbXkgc3RvY2tcIiBpbnRvIHByZWNpc2UsIGV4ZWN1dGVkIGFjdGlvbnMsIHNvbHZpbmcgY29tcGxleCBtYXRoIChsaWtlIHRoZSBOZXdzdmVuZG9yIHByb2JsZW0pIHRvIG1heGltaXplIGNhc2ggZmxvdyBhbmQgbWluaW1pemUgd2FzdGUuXG5cbioqTWFya2V0IFZhbHVlKio6XG4qICAgKipEZW1vY3JhdGl6YXRpb24qKjogQWNjZXNzIHRvIGFkdmFuY2VkIGFuYWx5dGljcyAoVGltZS1zZXJpZXMgZm9yZWNhc3RpbmcsIEh5cG90aGVzaXMgdGVzdGluZykgdmlhIGEgc2ltcGxlIGNoYXQgaW50ZXJmYWNlLlxuKiAgICoqT3BlcmF0aW9uYWwgRXhjZWxsZW5jZSoqOiBUcmFuc2l0aW9uaW5nIGNsaWVudHMgZnJvbSAqcmVhY3RpdmUqIGZpcmUtZmlnaHRpbmcgdG8gKnByb2FjdGl2ZSosIG1hdGhlbWF0aWNhbGx5IG9wdGltYWwgaW52ZW50b3J5IG1hbmFnZW1lbnQuXG4qICAgKipIeWJyaWQgQXJjaGl0ZWN0dXJlKio6IEEgcHJpdmFjeS1jb25zY2lvdXMgTG9jYWwgTmV4dXMgZm9yIGRhaWx5IHdvcmssIGNvbm5lY3RlZCB0byBhIHNjYWxhYmxlIENsb3VkIEJyYWluIGZvciBoZWF2eSBjb21wdXRhdGlvbi4iLCAiY2hpbGRyZW4iOiBbXX0sIHsidGl0bGUiOiAiVGVjaG5pY2FsIEFyY2hpdGVjdHVyZSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImFjdGl2ZSIsICJ0eXBlIjogInBsYW4iLCAiaWQiOiAicHJvZHVjdC5zYWFzLmFyY2giLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjNUMTM6NDc6MDcrMDE6MDAifSwgImNvbnRlbnQiOiAiVGhlIHN5c3RlbSBzZXBhcmF0ZXMgQW5hbHl0aWNhbCBRdWVyaWVzIChDb2RlIEV4ZWN1dGlvbikgZnJvbSBDb250cm9sIFRhc2tzIChNb2RlbCBJbmZlcmVuY2UpLiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIkNvcmUgQ29tcG9uZW50cyIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImFjdGl2ZSIsICJ0eXBlIjogImNvbnRleHQiLCAiaWQiOiAicHJvZHVjdC5zYWFzLmFyY2guY29tcG9uZW50cyIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QxMzo0NzowNyswMTowMCJ9LCAiY29udGVudCI6ICIiLCAiY2hpbGRyZW4iOiBbeyJ0aXRsZSI6ICJDaGF0Ym90IEFzc2lzdGFudCBBcHAiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJhY3RpdmUiLCAidHlwZSI6ICJjb250ZXh0IiwgImlkIjogInByb2R1Y3Quc2Fhcy5hcmNoLmNvbXBvbmVudHMuY2hhdGJvdCIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QxOTo0NzozMSswMTowMCJ9LCAiY29udGVudCI6ICJTZXJ2ZXMgYXMgdGhlIHByaW1hcnkgaW50ZXJmYWNlIGZvciB1c2VycywgZnVuY3Rpb25pbmcgc2ltdWx0YW5lb3VzbHkgYXMgYSBtZWNoYW5pc20gZm9yIGludGVyYWN0aW9uIGFuZCBhIGxvY2FsIGRhdGEgd2FyZWhvdXNlLiBJdCBmYWNpbGl0YXRlcyBkYXRhIGNvbGxlY3Rpb24gYW5kIHVzZXIgaW50ZW50IGNhcHR1cmUuIiwgImNoaWxkcmVuIjogW119LCB7InRpdGxlIjogIkludGVybmFsIEVjb3N5c3RlbSBvZiBBSS1Bc3Npc3RhbnRzIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAiY29udGV4dCIsICJpZCI6ICJwcm9kdWN0LnNhYXMuYXJjaC5jb21wb25lbnRzLmVjb3N5c3RlbSIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QxOTo0NzozMSswMTowMCJ9LCAiY29udGVudCI6ICJBIGJhY2tncm91bmQgb3JjaGVzdHJhdGlvbiBsYXllciB3aGVyZSBtdWx0aXBsZSBzcGVjaWFsaXplZCBBSSBhZ2VudHMgY29sbGFib3JhdGUuIFRoZXNlIGFnZW50cyBhcmUgaW50ZXJuYWwtb25seSBhbmQgaGFuZGxlIHNwZWNpZmljIHN1Yi10YXNrcyB0byBlbnN1cmUgc2VhbWxlc3Mgc3lzdGVtIG9wZXJhdGlvbi4iLCAiY2hpbGRyZW4iOiBbXX0sIHsidGl0bGUiOiAiQ2xvdWQgSW5mcmFzdHJ1Y3R1cmUgKEJpZ1F1ZXJ5ICYgQ29tcHV0ZSkiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJhY3RpdmUiLCAidHlwZSI6ICJjb250ZXh0IiwgImlkIjogInByb2R1Y3Quc2Fhcy5hcmNoLmNvbXBvbmVudHMuY2xvdWQiLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjNUMTk6NDc6MzErMDE6MDAifSwgImNvbnRlbnQiOiAiVGhlIHNjYWxhYmxlIGJhY2tib25lIG9mIHRoZSBwbGF0Zm9ybS4gSXQgaW5jbHVkZXMgKipHb29nbGUgQmlnUXVlcnkqKiBmb3IgbWFzc2l2ZSBkYXRhIHdhcmVob3VzaW5nIGFuZCAqKkdvb2dsZSBDbG91ZCBDb21wdXRlKiogZm9yIHBlcmZvcm1hbnQgcHJvY2Vzc2luZywgZW5zdXJpbmcgcmVsaWFiaWxpdHkgYW5kIHNwZWVkLiIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJJbnRlcm5hbCBBbGdvcml0aG1zIFJlcG9zaXRvcnkiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJhY3RpdmUiLCAidHlwZSI6ICJjb250ZXh0IiwgImlkIjogInByb2R1Y3Quc2Fhcy5hcmNoLmNvbXBvbmVudHMuYWxnb3JpdGhtcyIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QxOTo0NzozMSswMTowMCJ9LCAiY29udGVudCI6ICJUaGUgY2VudHJhbCBsaWJyYXJ5IG9mIGRhdGEgcHJvY2Vzc2luZyBhbmQgY29udHJvbCBhbGdvcml0aG1zLiBUaGlzIGxldmVyYWdlcyAqKlZlcnRleCBBSSoqIGZvciBhZHZhbmNlZCBkYXRhIHNjaWVuY2UgbW9kZWxpbmcgYW5kIG9wdGltaXphdGlvbiB0YXNrcywgcmVwcmVzZW50aW5nIHRoZSBjb3JlIGludGVsbGVjdHVhbCBwcm9wZXJ0eSBvZiB0aGUgYW5hbHlzaXMgZW5naW5lLiIsICJjaGlsZHJlbiI6IFtdfV19LCB7InRpdGxlIjogIkluZm9ybWF0aW9uIEZsb3ciLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJhY3RpdmUiLCAidHlwZSI6ICJjb250ZXh0IiwgImlkIjogInByb2R1Y3Quc2Fhcy5hcmNoLmZsb3ciLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjNUMTM6NDc6MDcrMDE6MDAifSwgImNvbnRlbnQiOiAiIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiQUkgQXNzaXN0YW50IE9yY2hlc3RyYXRpb24iLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJhY3RpdmUiLCAidHlwZSI6ICJjb250ZXh0IiwgImlkIjogInByb2R1Y3Quc2Fhcy5hcmNoLmZsb3cub3JjaGVzdHJhdGlvbiIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QxNToyODo1OSswMTowMCJ9LCAiY29udGVudCI6ICJVc2VyIGludGVyYWN0aW9uIGJlZ2lucyB3aXRoIHRoZSBDaGF0Ym90IEFwcCwgd2hpY2ggZm9yd2FyZHMgcmVxdWVzdHMgdG8gdGhlIE9yY2hlc3RyYXRvciAoVmVydGV4IEFJKS5cbjEuICAqKkludGVudCBSZWNvZ25pdGlvbioqOiBUaGUgT3JjaGVzdHJhdG9yIGRldGVybWluZXMgaWYgdGhlIHJlcXVlc3QgaXMgKipBbmFseXNpcyoqIChpbmZvcm1hdGlvbmFsKSBvciAqKkNvbnRyb2wqKiAoYWN0aW9uYWJsZSkuXG4yLiAgKipSb3V0aW5nKio6XG4gICAgKiAgICoqQW5hbHlzaXMqKjogUm91dGVkIHRvIENvZGUgSW50ZXJwcmV0ZXIgLyBBbmFseXN0IEFnZW50IGZvciBkYXRhIHF1ZXJ5aW5nIGFuZCB2aXN1YWxpemF0aW9uLlxuICAgICogICAqKkNvbnRyb2wqKjogUm91dGVkIHRvIFBsYW5uZXIgLyBSTCBBZ2VudCBmb3Igb3B0aW1pemF0aW9uIGFuZCBkZWNpc2lvbiBtYWtpbmcuXG4zLiAgKipSZXNwb25zZSoqOiBSZXN1bHRzIGFyZSBhZ2dyZWdhdGVkIGFuZCByZXR1cm5lZCB0byB0aGUgQ2hhdGJvdCBhcyBuYXR1cmFsIGxhbmd1YWdlIG9yIFVJIGNvbXBvbmVudHMuIiwgImNoaWxkcmVuIjogW119LCB7InRpdGxlIjogIkNvbnRyb2wgTG9vcCIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImFjdGl2ZSIsICJ0eXBlIjogImNvbnRleHQiLCAiaWQiOiAicHJvZHVjdC5zYWFzLmFyY2guZmxvdy5jb250cm9sIiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTIzVDE1OjI4OjU5KzAxOjAwIn0sICJjb250ZW50IjogIlRoaXMgaGlnaC1mcmVxdWVuY3kgbG9vcCBoYW5kbGVzIHRoZSBhdXRvbm9tb3VzIG9wdGltaXphdGlvbiBzeXN0ZW06XG4xLiAgKipUZWxlbWV0cnkgSW5nZXN0Kio6IFJhdyBkYXRhIHN0cmVhbXMgZnJvbSB0aGUgQ2xpZW50IEFwcC9XYXJlaG91c2UgYXJlIGluZ2VzdGVkIGludG8gQmlnUXVlcnkuXG4yLiAgKipTdGF0ZSBFc3RpbWF0aW9uKio6IFByb2Nlc3NpbmcgYWxnb3JpdGhtcyBjb252ZXJ0IHJhdyB0ZWxlbWV0cnkgaW50byBzdGF0ZSB2ZWN0b3JzICgkc190JCkgc3VpdGFibGUgZm9yIG1vZGVsIGlucHV0LlxuMy4gICoqRGVjaXNpb24qKjogVGhlIFBvbGljeSBuZXR3b3JrICgkXFxwaSQpIG9yIFBsYW5lciBzZWxlY3RzIHRoZSBvcHRpbWFsIGFjdGlvbiAoJGFfdCQpIGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRlLlxuNC4gICoqRXhlY3V0aW9uICYgRmVlZGJhY2sqKjogVGhlIGFjdGlvbiBpcyBzZW50IHRvIHRoZSBDb250cm9sbGVyIGZvciBleGVjdXRpb24sIGFuZCB0aGUgb3V0Y29tZSBpcyByZWNvcmRlZCBmb3Igb2ZmbGluZSByZS10cmFpbmluZyBhbmQgcmVmaW5lbWVudC4iLCAiY2hpbGRyZW4iOiBbXX0sIHsidGl0bGUiOiAiSHVtYW4tQUkgSW50ZXJhY3Rpb24iLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJhY3RpdmUiLCAidHlwZSI6ICJjb250ZXh0IiwgImlkIjogInByb2R1Y3Quc2Fhcy5hcmNoLmZsb3cuaHVtYW5fYWkiLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjNUMTk6NTE6MDcrMDE6MDAifSwgImNvbnRlbnQiOiAiRGVmaW5lcyB0aGUgcHJvdG9jb2xzIGZvciBob3cgaHVtYW5zIGludGVyYWN0IHdpdGggdGhlIEFJIGFnZW50cy4iLCAiY2hpbGRyZW4iOiBbeyJ0aXRsZSI6ICJEZXZlbG9wZXItQUkgSW50ZXJhY3Rpb24iLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJhY3RpdmUiLCAidHlwZSI6ICJwcm90b2NvbCIsICJpZCI6ICJwcm9kdWN0LnNhYXMuYXJjaC5mbG93Lmh1bWFuX2FpLmRldmVsb3BlciIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QxOTo1MTowNyswMTowMCJ9LCAiY29udGVudCI6ICJQcm90b2NvbCBmb3IgZGV2ZWxvcGVycyB0byBjb25maWd1cmUsIHRyYWluLCBhbmQgZGVidWcgYWdlbnRzLiBJbnZvbHZlcyBkaXJlY3QgYWNjZXNzIHRvIGludGVybmFsIGxvZ3MsIG1vZGVsIHdlaWdodHMsIGFuZCB0aGUgJ0FuYWx5c2lzIFNhbmRib3gnIGZvciBzYWZlIGNvZGUgdGVzdGluZy4iLCAiY2hpbGRyZW4iOiBbXX0sIHsidGl0bGUiOiAiQ2xpZW50LUFJIEludGVyYWN0aW9uIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAicHJvdG9jb2wiLCAiaWQiOiAicHJvZHVjdC5zYWFzLmFyY2guZmxvdy5odW1hbl9haS5jbGllbnQiLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjNUMTk6NTE6MDcrMDE6MDAifSwgImNvbnRlbnQiOiAiUHJvdG9jb2wgZm9yIGVuZC11c2Vycy4gUmVzdHJpY3RlZCB0byBuYXR1cmFsIGxhbmd1YWdlIHZpYSB0aGUgQ2hhdGJvdCBBcHAuIE5vIGRpcmVjdCBjb2RlIGV4ZWN1dGlvbiBhbGxvd2VkLiBJbnRlbnQgaXMgcGFyc2VkIGJ5IHRoZSBPcmNoZXN0cmF0b3IuIiwgImNoaWxkcmVuIjogW119XX0sIHsidGl0bGUiOiAiQUktVG9vbHMgUHJvdG9jb2xzIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAicHJvdG9jb2wiLCAiaWQiOiAicHJvZHVjdC5zYWFzLmFyY2guZmxvdy50b29scyIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QxOTo1MTowNyswMTowMCJ9LCAiY29udGVudCI6ICJQcm90b2NvbHMgZm9yIGhvdyBBSSBhZ2VudHMgdXRpbGl6ZSBleHRlcm5hbCBzb2Z0d2FyZSBhbmQgQVBJcy4gQWRoZXJlcyB0byB0aGUgKipNb2RlbCBDb250ZXh0IFByb3RvY29sIChNQ1ApKiogdG8gc3RhbmRhcmRpemUgdG9vbCBkZWZpbml0aW9uLCBkaXNjb3ZlcnksIGFuZCBleGVjdXRpb24uIiwgImNoaWxkcmVuIjogW119XX0sIHsidGl0bGUiOiAiS25vd2xlZGdlIEJhc2VzIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAiY29udGV4dCIsICJpZCI6ICJwcm9kdWN0LnNhYXMuYXJjaC5rbm93bGVkZ2UiLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjNUMjA6MDA6MDArMDE6MDAifSwgImNvbnRlbnQiOiAiUmVwb3NpdG9yeSByZXNvdXJjZXMgY2F0ZWdvcml6ZWQgYnkgdGhlaXIgZnVuY3Rpb24uIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiQWdlbnRpYyIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImFjdGl2ZSIsICJ0eXBlIjogImNvbnRleHQiLCAiaWQiOiAicHJvZHVjdC5zYWFzLmFyY2gua25vd2xlZGdlLmFnZW50aWMiLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjNUMjA6MDA6MDArMDE6MDAifSwgImNvbnRlbnQiOiAiLSBbTUFOQUdFUl9BR0VOVF0oTUFOQUdFUl9BR0VOVC5tZClcbi0gW0NMRUFORVJfQUdFTlRdKC4uL2NsZWFuZXIvQ0xFQU5FUl9BR0VOVC5tZClcbi0gW1JFQUNUX0FTU0lTVEFOVF0oLi4vLi4vQUlfQUdFTlRTL3NwZWNpYWxpc3RzL1JFQUNUX0FTU0lTVEFOVC5tZClcbi0gW1JFQ1NZU19BR0VOVF0oLi4vLi4vQUlfQUdFTlRTL3NwZWNpYWxpc3RzL1JFQ1NZU19BR0VOVC5tZClcbi0gW0NPTlRST0xfQUdFTlRdKC4uLy4uL0FJX0FHRU5UUy9zcGVjaWFsaXN0cy9DT05UUk9MX0FHRU5ULm1kKVxuLSBbVUlfREVTSUdfQVNTSVNUQU5UXSguLi8uLi9BSV9BR0VOVFMvc3BlY2lhbGlzdHMvVUlfREVTSUdfQVNTSVNUQU5ULm1kKVxuLSBbTElORUFSSVpFX0FHRU5UXSguLi8uLi9BSV9BR0VOVFMvc3BlY2lhbGlzdHMvTElORUFSSVpFX0FHRU5ULm1kKVxuLSBbTUNfQUdFTlRdKC4uLy4uL0FJX0FHRU5UUy9zcGVjaWFsaXN0cy9NQ19BR0VOVC5tZCkiLCAiY2hpbGRyZW4iOiBbXX0sIHsidGl0bGUiOiAiS25vd2xlZGdlIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAiY29udGV4dCIsICJpZCI6ICJwcm9kdWN0LnNhYXMuYXJjaC5rbm93bGVkZ2UuZ2VuZXJhbCIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QyMDowMDowMCswMTowMCJ9LCAiY29udGVudCI6ICItIFtSRUFETUVdKC4uLy4uL1JFQURNRS5tZClcbi0gW01EX0NPTlZFTlRJT05TXSguLi8uLi9NRF9DT05WRU5USU9OUy5tZClcbi0gW0FHRU5UU10oLi4vLi4vQUdFTlRTLm1kKVxuLSBbQUdFTlRTX0xPR10oLi4vLi4vQUdFTlRTX0xPRy5tZClcbi0gW0RBR19FeGFtcGxlXSguLi8uLi9sYW5ndWFnZS9leGFtcGxlL0RBR19FeGFtcGxlLm1kKSIsICJjaGlsZHJlbiI6IFtdfV19XX0sIHsidGl0bGUiOiAiSW1wbGVtZW50YXRpb24gUm9hZG1hcCIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImFjdGl2ZSIsICJ0eXBlIjogInBsYW4iLCAiaWQiOiAicHJvZHVjdC5zYWFzLnJvYWRtYXAiLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjNUMjE6NDQ6MjMrMDE6MDAifSwgImNvbnRlbnQiOiAiVGhpcyByb2FkbWFwIHN0cmlwcyBhd2F5IGVudGVycHJpc2UgY29tcGxleGl0eSB0byBmb2N1cyBvbiB0aGUgY29yZSB2YWx1ZSBwcm9wb3NpdGlvbjogYSBsb2NhbCBhcHAgdGhhdCBhY3RzIGFzIGEgZGF0YSBodWIgYW5kIGEgY2hhdCBpbnRlcmZhY2UsIGNvbm5lY3RlZCB0byBwb3dlcmZ1bCBjbG91ZCBhZ2VudHMgZm9yIGV4ZWN1dGlvbi4iLCAiY2hpbGRyZW4iOiBbeyJ0aXRsZSI6ICJQaGFzZSAxOiBMb2NhbCBOZXh1cyIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImFjdGl2ZSIsICJ0eXBlIjogInBsYW4iLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxIiwgIm93bmVyIjogInVzZXIiLCAicHJpb3JpdHkiOiAiY3JpdGljYWwiLCAiZXN0aW1hdGUiOiAiNHciLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjRUMDg6MzU6MDArMDE6MDAifSwgImNvbnRlbnQiOiAiVGhpcyBkb2N1bWVudCBvdXRsaW5lcyB0aGUgdGFjdGljYWwgZXhlY3V0aW9uIHBsYW4gZm9yIGJ1aWxkaW5nIHRoZSAqKkxvY2FsIE5leHVzKiosIHRoZSBjbGllbnQtc2lkZSBhcHBsaWNhdGlvbiBvZiB0aGUgSW50ZWxsaWdlbnQgQ29udHJvbCBTYWFTLlxuXG4qKk9iamVjdGl2ZSoqOiBDcmVhdGUgYSBzZWxmLWNvbnRhaW5lZCBsb2NhbCBhcHBsaWNhdGlvbiB0aGF0IGZ1bmN0aW9ucyBhczpcbjEuICoqRGF0YSBXYXJlaG91c2UqKjogSW5nZXN0cyBhbmQgc3RydWN0dXJlcyByYXcgQ1NWL0V4Y2VsIGZpbGVzIGxvY2FsbHkgKER1Y2tEQikuXG4yLiAqKkludGVyZmFjZSoqOiBBIGNoYXQtYmFzZWQgVUkgZm9yIHF1ZXJ5aW5nIHRoYXQgZGF0YSAoU3RyZWFtbGl0KS5cblxuKipUZWNoIFN0YWNrIFNlbGVjdGlvbioqOlxuKiAqKkxhbmd1YWdlKio6IFB5dGhvbiAzLjEwK1xuKiAqKkZyb250ZW5kKio6IFN0cmVhbWxpdCAoQ2hvc2VuIGZvciByYXBpZCBpdGVyYXRpb24gYW5kIG5hdGl2ZSBkYXRhIHN1cHBvcnQpLlxuKiAqKkRhdGFiYXNlKio6IER1Y2tEQiAoRW1iZWRkZWQgT0xBUCwgemVyby1kZXBlbmRlbmN5LCBTUUwgY29tcGF0aWJsZSkuXG4qKlRlY2ggU3RhY2sgU2VsZWN0aW9uKio6XG4qICoqTGFuZ3VhZ2UqKjogUHl0aG9uIDMuMTArXG4qICoqRnJvbnRlbmQqKjogU3RyZWFtbGl0IChDaG9zZW4gZm9yIHJhcGlkIGl0ZXJhdGlvbiBhbmQgbmF0aXZlIGRhdGEgc3VwcG9ydCkuXG4qICoqRGF0YWJhc2UqKjogRHVja0RCIChFbWJlZGRlZCBPTEFQLCB6ZXJvLWRlcGVuZGVuY3ksIFNRTCBjb21wYXRpYmxlKS5cbiogKipEYXRhIFByb2Nlc3NpbmcqKjogUGFuZGFzIC8gUG9sYXJzLlxuKiAqKkFnZW50IEZyYW1ld29yayoqOiAqKkdvb2dsZSBBREsgKExvY2FsIE1vZGUpKiouIEV2ZW4gaW4gUGhhc2UgMSwgd2Ugd2lsbCBzdHJ1Y3R1cmUgXCJNb2NrIHRvb2xzXCIgdXNpbmcgdGhlIEFESyBwYXR0ZXJuIChQeXRob24gZnVuY3Rpb25zICsgdHlwZSBoaW50cykgdG8gbWFrZSB0aGUgdHJhbnNpdGlvbiB0byBQaGFzZSAzIHNlYW1sZXNzLiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIlByb2plY3QgSW5pdGlhbGl6YXRpb24gJiBTdHJ1Y3R1cmUiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTEuaW5pdCIsICJlc3RpbWF0ZSI6ICIxZCIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yNFQwODozNTowMCswMTowMCJ9LCAiY29udGVudCI6ICJFc3RhYmxpc2ggdGhlIHJlcG9zaXRvcnkgc3RydWN0dXJlIHRvIHN1cHBvcnQgbW9kdWxhciBncm93dGggaW50byBQaGFzZXMgMiBhbmQgMy5cblxuKipEaXJlY3RvcnkgU3RydWN0dXJlKio6XG5gYGBcbi9zcmNcbiAgL2FwcC5weSAgICAgICAgICAgICMgTWFpbiBTdHJlYW1saXQgZW50cnkgcG9pbnRcbiAgL2NvcmVcbiAgICAvZGF0YWJhc2UucHkgICAgICMgRHVja0RCIHNpbmdsZXRvbiB3cmFwcGVyXG4gICAgL2luZ2VzdGlvbi5weSAgICAjIEZpbGUgcHJvY2Vzc2luZyBsb2dpY1xuICAvY29tcG9uZW50c1xuICAgIC9jaGF0LnB5ICAgICAgICAgIyBVSSBjb21wb25lbnQgZm9yIGNoYXQgaGlzdG9yeVxuICAgIC9zaWRlYmFyLnB5ICAgICAgIyBVSSBjb21wb25lbnQgZm9yIGZpbGUgbWFuYWdlbWVudFxuICAvdXRpbHNcbiAgICAvbG9nZ2VyLnB5ICAgICAgICMgVGVsZW1ldHJ5IGxvZ2dpbmcgKGZvciBmdXR1cmUgUkwpXG4vdGVzdHMgICAgICAgICAgICAgICAjIFVuaXQgYW5kIGludGVncmF0aW9uIHRlc3RzXG4vZGF0YVxuICAvcmF3ICAgICAgICAgICAgICAgIyBTdGFnaW5nIGFyZWEgZm9yIHVzZXIgdXBsb2Fkc1xuICAvd2FyZWhvdXNlLmRiICAgICAgIyBQZXJzaXN0ZW50IER1Y2tEQiBmaWxlXG5gYGAiLCAiY2hpbGRyZW4iOiBbXX0sIHsidGl0bGUiOiAiTW9kdWxlIDE6IFRoZSBMb2NhbCBEYXRhIFdhcmVob3VzZSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMS53YXJlaG91c2UiLCAiYmxvY2tlZF9ieSI6IFsiaW1wbGVtZW50YXRpb24ucGhhc2UxLmluaXQiXSwgImVzdGltYXRlIjogIjF3IiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTI0VDA4OjM1OjAwKzAxOjAwIn0sICJjb250ZW50IjogIkltcGxlbWVudCB0aGUgcGVyc2lzdGVuY2UgbGF5ZXIgdXNpbmcgRHVja0RCLiBUaGlzIGlzIHRoZSBcIkxvbmctVGVybSBNZW1vcnlcIiBvZiB0aGUgc3lzdGVtLiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIkRhdGFiYXNlIE1hbmFnZXIgQ2xhc3MiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTEud2FyZWhvdXNlLm1hbmFnZXIiLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjRUMDg6MzU6MDArMDE6MDAifSwgImNvbnRlbnQiOiAiQ3JlYXRlIGEgRGF0YWJhc2VNYW5hZ2VyIGNsYXNzIGluIHNyYy9jb3JlL2RhdGFiYXNlLnB5LlxuXG4qICoqQ29ubmVjdGlvbioqOiBNYWludGFpbiBhIHBlcnNpc3RlbnQgY29ubmVjdGlvbiB0byBkYXRhL3dhcmVob3VzZS5kYi5cbiogKipTY2hlbWEgRGVmaW5pdGlvbioqOlxuICAgICogKipgbWV0YWRhdGFfcmVnaXN0cnlgKio6XG4gICAgICAgICogYGZpbGVfaWRgIChVVUlELCBQSylcbiAgICAgICAgKiBgZmlsZW5hbWVgIChWQVJDSEFSKVxuICAgICAgICAqIGB1cGxvYWRfdGltZXN0YW1wYCAoVElNRVNUQU1QKVxuICAgICAgICAqIGBmaWxlX2hhc2hgIChWQVJDSEFSKVxuICAgICAgICAqIGByb3dfY291bnRgIChJTlRFR0VSKVxuICAgICogKipgdGVsZW1ldHJ5X2xvZ2AqKjpcbiAgICAgICAgKiBgbG9nX2lkYCAoVVVJRCwgUEspXG4gICAgICAgICogYHVzZXJfaWRgIChWQVJDSEFSLCBudWxsYWJsZSkgLS0gUHJlcGFyZSBmb3IgUGhhc2UgMiBBdXRoXG4gICAgICAgICogYHRpbWVzdGFtcGAgKFRJTUVTVEFNUClcbiAgICAgICAgKiBgcXVlcnlfdGV4dGAgKFZBUkNIQVIpXG4gICAgICAgICogYHJlc3BvbnNlX3R5cGVgIChWQVJDSEFSKVxuICAgICAgICAqIGB1c2VyX2ZlZWRiYWNrYCAoSU5URUdFUiwgbnVsbGFibGUpXG4gICAgICAgICogYHN5bmNlZF9hdGAgKFRJTUVTVEFNUCwgbnVsbGFibGUpIC0tIEZvciBQaGFzZSAyIFN5bmMgTG9naWNcbiogKipNZXRob2RzKio6IGBnZXRfY29ubmVjdGlvbigpYCwgYGV4ZWN1dGVfcXVlcnkoKWAsIGBnZXRfdGFibGVfc2NoZW1hKClgLiIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJJbmdlc3Rpb24gU2VydmljZSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMS53YXJlaG91c2UuaW5nZXN0IiwgImJsb2NrZWRfYnkiOiBbImltcGxlbWVudGF0aW9uLnBoYXNlMS53YXJlaG91c2UubWFuYWdlciJdLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjRUMDg6MzU6MDArMDE6MDAifSwgImNvbnRlbnQiOiAiQ3JlYXRlIGxvZ2ljIHRvIGhhbmRsZSB1c2VyIGZpbGUgdXBsb2Fkcy5cblxuMS4gKipOb3JtYWxpemF0aW9uKio6IENvbnZlcnQgaW5jb21pbmcgRXhjZWwvQ1NWIHRvIGEgc3RyaWN0IFBhbmRhcyBEYXRhRnJhbWUuXG4yLiAqKlR5cGUgRW5mb3JjZW1lbnQqKjogQ2FzdCBnZW5lcmljIGBvYmplY3RgIGNvbHVtbnMgdG8gc3BlY2lmaWMgdHlwZXMgKFN0cmluZywgSW50LCBGbG9hdCwgQm9vbCwgVGltZXN0YW1wKSB0byBlbnN1cmUgZnV0dXJlIEJpZ1F1ZXJ5IGNvbXBhdGliaWxpdHkuXG4zLiAqKlNhbml0aXphdGlvbioqOiBDbGVhbiBjb2x1bW4gbmFtZXMgKGxvd2VyY2FzZSwgc25ha2VfY2FzZSkgdG8gbWFrZSB0aGVtIFNRTC1mcmllbmRseSBmb3IgdGhlIExMTSBsYXRlci5cbjQuICoqU3RvcmFnZSoqOiBVc2UgYGR1Y2tkYi5zcWwoXCJDUkVBVEUgVEFCTEUgLi4uIEFTIFNFTEVDVCAuLi5cIilgIHRvIHBlcnNpc3QgZGF0YS5cbjUuICoqVmVyc2lvbmluZyoqOiBDYWxjdWxhdGUgYSBjb250ZW50IGhhc2ggKFNIQS0yNTYpIG9mIHRoZSBmaWxlLiBJZiB0aGUgaGFzaCBleGlzdHMsIHNraXA7IGlmIHRoZSBmaWxlbmFtZSBleGlzdHMgYnV0IGhhc2ggZGlmZmVycywgY3JlYXRlIGEgbmV3IHZlcnNpb24gKGUuZy4sIGBzYWxlc19kYXRhX3YyYCkuIiwgImNoaWxkcmVuIjogW119XX0sIHsidGl0bGUiOiAiTW9kdWxlIDI6IFRoZSBDaGF0IEludGVyZmFjZSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMS51aSIsICJibG9ja2VkX2J5IjogWyJpbXBsZW1lbnRhdGlvbi5waGFzZTEud2FyZWhvdXNlIl0sICJlc3RpbWF0ZSI6ICIxdyIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yNFQwODozNTowMCswMTowMCJ9LCAiY29udGVudCI6ICJJbXBsZW1lbnQgdGhlIFN0cmVhbWxpdCBmcm9udGVuZC4iLCAiY2hpbGRyZW4iOiBbeyJ0aXRsZSI6ICJMYXlvdXQgJiBTZXNzaW9uIFN0YXRlIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLnVpLmxheW91dCIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yNFQwODozNTowMCswMTowMCJ9LCAiY29udGVudCI6ICIqICoqU2lkZWJhcioqOiBcIkRhdGEgTWFuYWdlbWVudFwiLiBBIGZpbGUgdXBsb2FkZXIgd2lkZ2V0IGFuZCBhIGxpc3Qgb2YgY3VycmVudGx5IGF2YWlsYWJsZSB0YWJsZXMgaW4gRHVja0RCLlxuKiAqKk1haW4gQXJlYSoqOiBDaGF0IGNvbnRhaW5lci5cbiogKipTdGF0ZSBNYW5hZ2VtZW50Kio6IEluaXRpYWxpemUgYHN0LnNlc3Npb25fc3RhdGVgIHRvIGhvbGQ6XG4gICogYG1lc3NhZ2VzYDogTGlzdCBvZiBgeydyb2xlJzogJ3VzZXInfCdhc3Npc3RhbnQnLCAnY29udGVudCc6IHN0ciwgJ2RhdGFfcmVmJzogLi4ufWAuXG4gICogYGFjdGl2ZV90YWJsZXNgOiBMaXN0IG9mIHRhYmxlcyBjdXJyZW50bHkgaW4gY29udGV4dC5cbiAgKiBgdXNlcl9pZGVudGl0eWA6IERpY3QgYHsnaWQnOiAnbG9jYWwtZGV2JywgJ3JvbGUnOiAnYWRtaW4nfWAgKE1vY2sgZm9yIFBoYXNlIDIgQXV0aCkuIiwgImNoaWxkcmVuIjogW119LCB7InRpdGxlIjogIkNoYXQgTG9naWMgJiBNb2NrIE9yY2hlc3RyYXRvciIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMS51aS5jaGF0IiwgImJsb2NrZWRfYnkiOiBbImltcGxlbWVudGF0aW9uLnBoYXNlMS51aS5sYXlvdXQiXSwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTI0VDA4OjM1OjAwKzAxOjAwIn0sICJjb250ZW50IjogIlNpbmNlIHRoZSBDbG91ZCBBZ2VudHMgKFBoYXNlIDMpIGFyZSBub3QgcmVhZHksIGJ1aWxkIGEgKipMb2NhbCBMb29wYmFjayoqIGZvciB0ZXN0aW5nLlxuXG4xLiAqKklucHV0Kio6IFVzZXIgdHlwZXMgXCJTaG93IG1lIHRoZSBsYXN0IDUgcm93cyBvZiBzYWxlc1wiLlxuMi4gKipNb2NrIFByb2Nlc3NvciAoQURLIFBhdHRlcm4pKio6XG4gICAqIEluc3RlYWQgb2YgcmFuZG9tIHJlZ2V4LCBkZWZpbmUgYSBjbGFzcyBgTG9jYWxBbmFseXN0YCB3aXRoIG1ldGhvZHMgbGlrZSBgZ2V0X3NhbGVzX2RhdGEobGltaXQ6IGludClgLlxuICAgKiBVc2UgKipQeWRhbnRpYyoqIHRvIGRlZmluZSB0aGUgaW5wdXQgc2NoZW1hIGZvciB0aGVzZSBtZXRob2RzLCBtaXJyb3JpbmcgaG93IEFESyBoYW5kbGVzIHRvb2wgYXJndW1lbnRzLlxuICAgKiBUaGlzIGFsbG93cyB1cyB0byBcInN3YXBcIiB0aGlzIE1vY2sgUHJvY2Vzc29yIGZvciBhIHJlYWwgYGFkay5BZ2VudGAgaW4gUGhhc2UgMyB3aXRob3V0IHJld3JpdGluZyB0aGUgZnJvbnRlbmQuXG4zLiAqKlJlbmRlcmluZyoqOlxuICAgKiBJZiByZXNwb25zZSBpcyBUZXh0OiBgc3QubWFya2Rvd24oKWAuXG4gICAqIElmIHJlc3BvbnNlIGlzIERhdGE6IGBzdC5kYXRhZnJhbWUoKWAgb3IgYHN0LmJhcl9jaGFydCgpYC4iLCAiY2hpbGRyZW4iOiBbXX1dfSwgeyJ0aXRsZSI6ICJNb2R1bGUgMzogVGVzdGluZyAmIFF1YWxpdHkgQXNzdXJhbmNlIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLnRlc3RpbmciLCAiYmxvY2tlZF9ieSI6IFsiaW1wbGVtZW50YXRpb24ucGhhc2UxLnVpIl0sICJlc3RpbWF0ZSI6ICIzZCIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yNFQwODozNTowMCswMTowMCJ9LCAiY29udGVudCI6ICJFc3RhYmxpc2ggY29tcHJlaGVuc2l2ZSB0ZXN0aW5nIHRvIGVuc3VyZSByZWxpYWJpbGl0eSBiZWZvcmUgcGFja2FnaW5nLiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIlVuaXQgVGVzdHMiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTEudGVzdGluZy51bml0In0sICJjb250ZW50IjogIi0gPCEtLSBjb250ZW50IC0tPlxuLSAqKkZyYW1ld29yayoqOiBgcHl0ZXN0YFxuLSAqKkNvdmVyYWdlKio6XG4gICAgLSBgaW5nZXN0aW9uLnB5YDogVmVyaWZ5IGZpbGUgaGFzaCBhc3NlcnRpb25zIGFuZCBzY2hlbWEgbm9ybWFsaXphdGlvbi5cbiAgICAtIGBkYXRhYmFzZS5weWA6IFRlc3QgY29ubmVjdGlvbiBwZXJzaXN0ZW5jZSBhbmQgcXVlcnkgZXhlY3V0aW9uIHdpdGggbW9jayBkYXRhLiIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJJbnRlZ3JhdGlvbiBUZXN0cyIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMS50ZXN0aW5nLmludGVncmF0aW9uIiwgImJsb2NrZWRfYnkiOiBbImltcGxlbWVudGF0aW9uLnBoYXNlMS50ZXN0aW5nLnVuaXQiXX0sICJjb250ZW50IjogIi0gPCEtLSBjb250ZW50IC0tPlxuLSAqKkZsb3cqKjogU2ltdWxhdGUgYSBmdWxsIHVzZXIgZmxvdzogVXNlciB1cGxvYWRzIENTViAtPiBJbmdlc3Rpb24gLT4gc3RvcmVkIGluIERCIC0+IFF1ZXJ5IHJldHJpZXZlcyBpdC4iLCAiY2hpbGRyZW4iOiBbXX1dfSwgeyJ0aXRsZSI6ICJNb2R1bGUgNDogUGFja2FnaW5nICYgRGlzdHJpYnV0aW9uIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLnBhY2thZ2luZyIsICJibG9ja2VkX2J5IjogWyJpbXBsZW1lbnRhdGlvbi5waGFzZTEudGVzdGluZyJdLCAiZXN0aW1hdGUiOiAiMmQiLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjRUMDg6MzU6MDArMDE6MDAifSwgImNvbnRlbnQiOiAiUHJlcGFyZSB0aGUgYXBwbGljYXRpb24gZm9yIGVhc3kgbG9jYWwgZGVwbG95bWVudC4iLCAiY2hpbGRyZW4iOiBbeyJ0aXRsZSI6ICJEZXBlbmRlbmN5IE1hbmFnZW1lbnQiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTEucGFja2FnaW5nLmRlcHMifSwgImNvbnRlbnQiOiAiLSA8IS0tIGNvbnRlbnQgLS0+XG4tIENyZWF0ZSBgcmVxdWlyZW1lbnRzLnR4dGAgd2l0aCBsb2NrZWQgdmVyc2lvbnMuXG4tIENyZWF0ZSBgZW52aXJvbm1lbnQueW1sYCBmb3IgQ29uZGEgdXNlcnMuIiwgImNoaWxkcmVuIjogW119LCB7InRpdGxlIjogIkV4ZWN1dGlvbiBTY3JpcHRzIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLnBhY2thZ2luZy5zY3JpcHRzIn0sICJjb250ZW50IjogIi0gPCEtLSBjb250ZW50IC0tPlxuLSBDcmVhdGUgYHJ1bl9hcHAuc2hgIChNYWMvTGludXgpIGFuZCBgcnVuX2FwcC5iYXRgIChXaW5kb3dzKSB0byBzZXQgdXAgdGhlIGVudmlyb25tZW50IGFuZCBsYXVuY2ggYHN0cmVhbWxpdCBydW4gc3JjL2FwcC5weWAuIiwgImNoaWxkcmVuIjogW119XX0sIHsidGl0bGUiOiAiUmVzZWFyY2ggSW5zdHJ1bWVudGF0aW9uIChQcmUtUkwpIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLnJlc2VhcmNoIiwgInByaW9yaXR5IjogImhpZ2giLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjRUMDg6MzU6MDArMDE6MDAifSwgImNvbnRlbnQiOiAiVG8gcHJlcGFyZSBmb3IgdGhlIFJMIEFnZW50cyBpbiBQaGFzZSAzLCB3ZSBtdXN0IHRyZWF0IHRoaXMgcGhhc2UgYXMgdGhlIFwiRGF0YSBDb2xsZWN0aW9uXCIgcGVyaW9kLlxuXG4qICoqSW50ZXJhY3Rpb24gTG9nZ2luZyoqOiBFdmVyeSB1c2VyIHF1ZXJ5IGFuZCBzdWJzZXF1ZW50IHN5c3RlbSBvdXRwdXQgbXVzdCBiZSBsb2dnZWQgdG8gYSBKU09OTCBmaWxlIG9yIHRoZSBgdGVsZW1ldHJ5X2xvZ2AgdGFibGUuXG4qICoqRm9ybWF0Kio6XG4gIGBgYGpzb25cbiAge1xuICAgIFwidGltZXN0YW1wXCI6IFwiSVNPODYwMVwiLFxuICAgIFwic3RhdGVfc25hcHNob3RcIjogW1wibGlzdF9vZl9hY3RpdmVfdGFibGVzXCIsIFwicm93X2NvdW50c1wiXSxcbiAgICBcImFjdGlvbl91c2VyX3F1ZXJ5XCI6IFwicmF3X3RleHRfaW5wdXRcIixcbiAgICBcInN5c3RlbV9yZXNwb25zZV90eXBlXCI6IFwidGFibGVfcmVuZGVyXCIsXG4gICAgXCJ1c2VyX2ZlZWRiYWNrXCI6IG51bGxcbiAgfVxuICBgYGBcbiogKipXaHkqKjogVGhpcyBkYXRhc2V0IHdpbGwgYmUgdXNlZCB0byBvZmZsaW5lLXRyYWluIHRoZSBPcmNoZXN0cmF0b3IgdG8gY2xhc3NpZnkgaW50ZW50IChBbmFseXNpcyB2cy4gQ29udHJvbCkgYmVmb3JlIHdlIGRlcGxveSB0aGUgbGl2ZSBtb2RlbC4iLCAiY2hpbGRyZW4iOiBbXX1dfSwgeyJ0aXRsZSI6ICJQaGFzZSAyOiBUaGUgQ2xvdWQgQnJpZGdlIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAicGxhbiIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIiLCAib3duZXIiOiAidXNlciIsICJwcmlvcml0eSI6ICJjcml0aWNhbCIsICJlc3RpbWF0ZSI6ICIydyIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yNFQwODo1MDowMCswMTowMCIsICJibG9ja2VkX2J5IjogWyJpbXBsZW1lbnRhdGlvbi5waGFzZTEiXX0sICJjb250ZW50IjogIlRoaXMgZG9jdW1lbnQgZGV0YWlscyB0aGUgXCJDbG91ZCBCcmlkZ2VcIiBpbXBsZW1lbnRhdGlvbi4gVGhlIGdvYWwgaXMgdG8gZXN0YWJsaXNoIGEgc2VjdXJlLCBzY2FsYWJsZSBjb21tdW5pY2F0aW9uIGNoYW5uZWwgYmV0d2VlbiB0aGUgTG9jYWwgTmV4dXMgKFBoYXNlIDEpIGFuZCB0aGUgQ2xvdWQgQWdlbnRzIChQaGFzZSAzKSB1c2luZyB0aGUgR29vZ2xlIENsb3VkIEVjb3N5c3RlbS5cblxuKipPYmplY3RpdmUqKjpcbjEuICAqKkluZnJhc3RydWN0dXJlKio6IFByb3Zpc2lvbiBzZXJ2ZXJsZXNzIGNvbXB1dGUgYW5kIHN0b3JhZ2Ugb24gR0NQLlxuMi4gICoqQ29ubmVjdGl2aXR5Kio6IEJ1aWxkIGEgc2VjdXJlIEFQSSBHYXRld2F5IGZvciB0aGUgbG9jYWwgYXBwIHRvIFwicGhvbmUgaG9tZVwiLlxuMy4gICoqU3luY2hyb25pemF0aW9uKio6IENyZWF0ZSBwaXBlbGluZXMgdG8gbWlycm9yIGxvY2FsIGRhdGEgdG8gdGhlIGNsb3VkIGZvciBoZWF2eSBwcm9jZXNzaW5nLlxuXG4qKlRlY2ggU3RhY2sqKjpcbiogICAqKkNvbXB1dGUqKjogR29vZ2xlIENsb3VkIFJ1biAoU2VydmVybGVzcyBDb250YWluZXIpLlxuKiAgICoqRGF0YWJhc2UqKjogR29vZ2xlIEJpZ1F1ZXJ5IChXYXJlaG91c2luZykgJiBGaXJlc3RvcmUgKE5vU1FMIE1ldGFkYXRhKS5cbiogICAqKkFQSSoqOiBQeXRob24gRmFzdEFQSS5cbiogICAqKkF1dGgqKjogRmlyZWJhc2UgQXV0aGVudGljYXRpb24uXG4qICAgKipEZXBsb3ltZW50Kio6IFRlcnJhZm9ybSAvIGdjbG91ZCBDTEkgKHZpYSBBbnRpZ3Jhdml0eSBNQ1ApLiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIk1vZHVsZSAxOiBJbmZyYXN0cnVjdHVyZSBJbml0aWFsaXphdGlvbiAoR0NQKSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMi5pbmZyYSIsICJlc3RpbWF0ZSI6ICIzZCIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yNFQwODo1MDowMCswMTowMCJ9LCAiY29udGVudCI6ICJQcm92aXNpb24gdGhlIG5lY2Vzc2FyeSBHb29nbGUgQ2xvdWQgcmVzb3VyY2VzLiBXZSB3aWxsIGZhdm9yIFwiSW5mcmFzdHJ1Y3R1cmUgYXMgQ29kZVwiIHByYWN0aWNlcy4iLCAiY2hpbGRyZW4iOiBbeyJ0aXRsZSI6ICJQcm9qZWN0IFNldHVwICYgQVBJIEVuYWJsZW1lbnQiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIuaW5mcmEuc2V0dXAiLCAicHJpb3JpdHkiOiAiaGlnaCJ9LCAiY29udGVudCI6ICIqICAgKipBY3Rpb24qKjogQ3JlYXRlIGEgbmV3IEdDUCBQcm9qZWN0IChlLmcuLCBgaW50ZWxsaWdlbnQtY29udHJvbC1wcm9kYCkuXG4qICAgKipFbmFibGUgQVBJcyoqOlxuICAgICogICBgcnVuLmdvb2dsZWFwaXMuY29tYCAoQ2xvdWQgUnVuKVxuICAgICogICBgYXJ0aWZhY3RyZWdpc3RyeS5nb29nbGVhcGlzLmNvbWAgKERvY2tlciBJbWFnZXMpXG4gICAgKiAgIGBiaWdxdWVyeS5nb29nbGVhcGlzLmNvbWAgKERhdGEgV2FyZWhvdXNlKVxuICAgICogICBgZmlyZXN0b3JlLmdvb2dsZWFwaXMuY29tYCAoQXBwIFN0YXRlKSIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJJYUMgJiBEZXBsb3ltZW50IFdvcmtmbG93IiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UyLmluZnJhLmlhYyIsICJibG9ja2VkX2J5IjogWyJpbXBsZW1lbnRhdGlvbi5waGFzZTIuaW5mcmEuc2V0dXAiXX0sICJjb250ZW50IjogIkRlZmluZSB0aGUgaW5mcmFzdHJ1Y3R1cmUgdXNpbmcgVGVycmFmb3JtIG9yIHNjcmlwdGFibGUgYGdjbG91ZGAgY29tbWFuZHMuXG4qICAgKipXb3JrZmxvdyoqOlxuICAgIDEuICBVc2VyIHByb21wdHMgQW50aWdyYXZpdHkgdG8gXCJEZXBsb3kgSW5mcmFzdHJ1Y3R1cmVcIi5cbiAgICAyLiAgQW50aWdyYXZpdHkgdXNlcyB0aGUgdGVybWluYWwgdG9vbCAob3IgYGdjbG91ZGAgTUNQKSB0byBleGVjdXRlIHRoZSBwcm92aXNpb25pbmcgc2NyaXB0cy5cbiAgICAzLiAgT3V0cHV0cyAoU2VydmljZSBVUkxzLCBCdWNrZXQgTmFtZXMpIGFyZSBzYXZlZCB0byBgZGVwbG95bWVudF9jb25maWcuanNvbmAuIiwgImNoaWxkcmVuIjogW119XX0sIHsidGl0bGUiOiAiTW9kdWxlIDI6IEF1dGhlbnRpY2F0aW9uICYgU2VjdXJpdHkiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIuYXV0aCIsICJibG9ja2VkX2J5IjogWyJpbXBsZW1lbnRhdGlvbi5waGFzZTIuaW5mcmEiXSwgImVzdGltYXRlIjogIjF3IiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTI0VDA4OjUwOjAwKzAxOjAwIn0sICJjb250ZW50IjogIlNlY3VyZSB0aGUgYnJpZGdlLiBUaGUgTG9jYWwgQXBwIG11c3QgYXV0aGVudGljYXRlIGJlZm9yZSBzZW5kaW5nIGRhdGEuIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiSWRlbnRpdHkgTWFuYWdlbWVudCAoRmlyZWJhc2UpIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UyLmF1dGguZmlyZWJhc2UifSwgImNvbnRlbnQiOiAiKiAgICoqU2V0dXAqKjogSW5pdGlhbGl6ZSBhIEZpcmViYXNlIHByb2plY3QgbGlua2VkIHRvIHRoZSBHQ1AgcHJvamVjdC5cbiogICAqKkNsaWVudCoqOiBJbnRlZ3JhdGUgYGZpcmViYXNlLWFkbWluYCBpbiB0aGUgQ2xvdWQgQVBJIGFuZCB0aGUgSlMvUHl0aG9uIFNESyBpbiB0aGUgTG9jYWwgQXBwLlxuKiAgICoqRmxvdyoqOlxuICAgIDEuICBMb2NhbCBVc2VyIGxvZ3MgaW4uXG4gICAgMi4gIExvY2FsIEFwcCBnZXRzIEpXVCBUb2tlbi5cbiAgICAzLiAgQVBJIEdhdGV3YXkgdmVyaWZpZXMgSldUIFRva2VuIG9uIGV2ZXJ5IHJlcXVlc3QuIiwgImNoaWxkcmVuIjogW119LCB7InRpdGxlIjogIlNlcnZpY2UgU2VjdXJpdHkiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIuYXV0aC5pYW0ifSwgImNvbnRlbnQiOiAiKiAgICoqU2VydmljZSBBY2NvdW50cyoqOiBDcmVhdGUgYSBzcGVjaWZpYyBTZXJ2aWNlIEFjY291bnQgZm9yIHRoZSBDbG91ZCBSdW4gaW5zdGFuY2UuXG4qICAgKipQZXJtaXNzaW9ucyoqOiBHcmFudCBzdHJpY3RseSBuZWNlc3Nhcnkgcm9sZXMgKGUuZy4sIGByb2xlcy9iaWdxdWVyeS5kYXRhRWRpdG9yYCwgYHJvbGVzL3N0b3JhZ2Uub2JqZWN0Q3JlYXRvcmApLiAqKkRvIG5vdCB1c2UgT3duZXIgcm9sZS4qKiIsICJjaGlsZHJlbiI6IFtdfV19LCB7InRpdGxlIjogIk1vZHVsZSAzOiBUaGUgQVBJIEdhdGV3YXkgKENvbm5lY3RvcikiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIuYXBpIiwgImJsb2NrZWRfYnkiOiBbImltcGxlbWVudGF0aW9uLnBoYXNlMi5hdXRoIl0sICJlc3RpbWF0ZSI6ICIxdyIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yNFQwODo1MDowMCswMTowMCJ9LCAiY29udGVudCI6ICJEZXZlbG9wIGFuZCBkZXBsb3kgdGhlIGNlbnRyYWwgUkVTVCBBUEkuIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiU2VydmljZSBTa2VsZXRvbiAoRmFzdEFQSSkiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIuYXBpLmRldiJ9LCAiY29udGVudCI6ICJDcmVhdGUgYHNyYy9jbG91ZC9tYWluLnB5YC5cbiogICAqKkVuZHBvaW50cyoqOlxuICAgICogICBgUE9TVCAvdjEvdGVsZW1ldHJ5YDogQWNjZXB0cyBKU09OIHBheWxvYWRzIG9mIHVzZXIgaW50ZXJhY3Rpb25zLlxuICAgICogICBgUE9TVCAvdjEvYWdlbnQvdGFza2A6IFN1Ym1pdHMgYSBjb21wbGV4IHRhc2sgZm9yIHRoZSBDbG91ZCBBZ2VudHMuXG4gICAgKiAgIGBHRVQgL3YxL2FnZW50L3N0YXR1cy97dGFza19pZH1gOiBQb2xsaW5nIGVuZHBvaW50IGZvciBsb25nLXJ1bm5pbmcgam9icy4iLCAiY2hpbGRyZW4iOiBbXX0sIHsidGl0bGUiOiAiQ29udGFpbmVyaXphdGlvbiAmIERlcGxveSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMi5hcGkuZGVwbG95IiwgImJsb2NrZWRfYnkiOiBbImltcGxlbWVudGF0aW9uLnBoYXNlMi5hcGkuZGV2Il19LCAiY29udGVudCI6ICIqICAgKipEb2NrZXIqKjogQ3JlYXRlIGBEb2NrZXJmaWxlYCBvcHRpbWl6ZWQgZm9yIFB5dGhvbiAobXVsdGktc3RhZ2UgYnVpbGQpLlxuKiAgICoqQ0kvQ0QqKjogRGVmaW5lIGEgc2ltcGxlIGRlcGxveW1lbnQgc2NyaXB0OiBgZ2Nsb3VkIHJ1biBkZXBsb3kgLS1zb3VyY2UgLmAuIiwgImNoaWxkcmVuIjogW119XX0sIHsidGl0bGUiOiAiTW9kdWxlIDQ6IERhdGEgU3luY2hyb25pemF0aW9uIFBpcGVsaW5lIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UyLnBpcGVsaW5lIiwgImJsb2NrZWRfYnkiOiBbImltcGxlbWVudGF0aW9uLnBoYXNlMi5hcGkiXSwgImVzdGltYXRlIjogIjF3IiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTI0VDA4OjUwOjAwKzAxOjAwIn0sICJjb250ZW50IjogIk1lY2hhbmlzbXMgdG8gbW92ZSBsYXJnZSBkYXRhc2V0cyBmcm9tIExvY2FsIER1Y2tEQiB0byBDbG91ZCBCaWdRdWVyeS4iLCAiY2hpbGRyZW4iOiBbeyJ0aXRsZSI6ICJCbG9iIFN0b3JhZ2UgSW5ncmVzcyIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMi5waXBlbGluZS5nY3MifSwgImNvbnRlbnQiOiAiRm9yIHJhdyBmaWxlcyAoQ1NWL0V4Y2VsKSB0aGF0IGFyZSB0b28gbGFyZ2UgZm9yIEpTT04gcGF5bG9hZHMuXG4qICAgKipNZWNoYW5pc20qKjogTG9jYWwgQXBwIHJlcXVlc3RzIGEgU2lnbmVkIFVwbG9hZCBVUkwgZnJvbSB0aGUgQVBJLlxuKiAgICoqQWN0aW9uKio6IExvY2FsIEFwcCBQVVRzIHRoZSBmaWxlIGRpcmVjdGx5IHRvIGEgR0NTIEJ1Y2tldCAoYHJhdy1kYXRhLWluZ3Jlc3NgKS4iLCAiY2hpbGRyZW4iOiBbXX0sIHsidGl0bGUiOiAiV2FyZWhvdXNlIFN5bmMgKEJpZ1F1ZXJ5KSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMi5waXBlbGluZS5iaWdxdWVyeSIsICJibG9ja2VkX2J5IjogWyJpbXBsZW1lbnRhdGlvbi5waGFzZTIucGlwZWxpbmUuZ2NzIl19LCAiY29udGVudCI6ICIqICAgKipTY2hlbWEgTWFwcGluZyoqOiBNYXAgRHVja0RCIHR5cGVzIHRvIEJpZ1F1ZXJ5IHR5cGVzLlxuKiAgICoqVmFsaWRhdGlvbioqOiBDaGVjayBpbmNvbWluZyBzY2hlbWEgYWdhaW5zdCBleGlzdGluZyBCaWdRdWVyeSBzY2hlbWEgdG8gcmVqZWN0IGJyZWFraW5nIGNoYW5nZXMgKFNjaGVtYSBEcmlmdCBkZWZlbnNlKS5cbiogICAqKlZhbGlkYXRpb24qKjogQ2hlY2sgaW5jb21pbmcgc2NoZW1hIGFnYWluc3QgZXhpc3RpbmcgQmlnUXVlcnkgc2NoZW1hIHRvIHJlamVjdCBicmVha2luZyBjaGFuZ2VzIChTY2hlbWEgRHJpZnQgZGVmZW5zZSkuXG4qICAgKipUcmlnZ2VyKio6IFdoZW4gYSBmaWxlIGxhbmRzIGluIEdDUywgYSBDbG91ZCBFdmVudCB0cmlnZ2VycyBhIFwiTG9hZGVyXCIgZnVuY3Rpb24gKG9yIHRoZSBBUEkgaXRzZWxmKSB0byBsb2FkIHRoZSBDU1YgaW50byBCaWdRdWVyeS5cbiogICAqKkFESyBDb21wYXRpYmlsaXR5Kio6IEVuc3VyZSB0aGUgQmlnUXVlcnkgZGF0YXNldCBsYWJlbHMgYW5kIGRlc2NyaXB0aW9ucyBhcmUgdmVyYm9zZS4gQURLJ3MgYEJpZ1F1ZXJ5VG9vbGAgdXNlcyB0aGVzZSBzY2hlbWEgZGVzY3JpcHRpb25zIHRvIHVuZGVyc3RhbmQgaG93IHRvIHF1ZXJ5IHRoZSBkYXRhLiIsICJjaGlsZHJlbiI6IFtdfV19XX0sIHsidGl0bGUiOiAiUGhhc2UgMzogVGhlIENsb3VkIEFnZW50cyIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJwbGFuIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMyIsICJvd25lciI6ICJ1c2VyIiwgInByaW9yaXR5IjogImNyaXRpY2FsIiwgImVzdGltYXRlIjogIjZ3IiwgImJsb2NrZWRfYnkiOiBbImltcGxlbWVudGF0aW9uLnBoYXNlMiJdfSwgImNvbnRlbnQiOiAiVGhpcyBkb2N1bWVudCBkZXRhaWxzIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgXCJCcmFpblwiIG9mIHRoZSBJbnRlbGxpZ2VudCBDb250cm9sIFNhYVM6IGEgbXVsdGktYWdlbnQgc3lzdGVtIGJ1aWx0IHVzaW5nIHRoZSAqKkdvb2dsZSBBZ2VudCBEZXZlbG9wbWVudCBLaXQgKEFESykqKi5cblxuKipPYmplY3RpdmUqKjogRGVwbG95IGEgcm9idXN0LCBvYnNlcnZhYmxlLCBhbmQgc2NhbGFibGUgYWdlbnQgZWNvc3lzdGVtIGhhbmRsaW5nOlxuMS4gICoqQW5hbHlzaXMqKjogUHl0aG9uLWJhc2VkIGRhdGEgc2NpZW5jZSBhbmQgdmlzdWFsaXphdGlvbi5cbjIuICAqKkNvbnRyb2wqKjogUkwvQ29udHJvbC10aGVvcnkgb3B0aW1pemF0aW9uIHVzaW5nIGEgY3VzdG9tIGFsZ29yaXRobSByZXBvc2l0b3J5LlxuMy4gICoqT3JjaGVzdHJhdGlvbioqOiBJbnRlbGxpZ2VudCByb3V0aW5nIGFuZCBzdGF0ZSBtYW5hZ2VtZW50LlxuXG4qKlRlY2ggU3RhY2sqKjpcbiogICAqKkZyYW1ld29yayoqOiBHb29nbGUgQURLIChQeXRob24gU0RLKS5cbiogICAqKk1vZGVsKio6IEdlbWluaSAxLjUgUHJvICh2aWEgVmVydGV4IEFJKS5cbiogICAqKlJ1bnRpbWUqKjogQ2xvdWQgUnVuIChDb250YWluZXJpemVkIEFnZW50cykuXG4qICAgKipFdmFsdWF0aW9uKio6IFZlcnRleCBBSSBHZW4gQUkgRXZhbHVhdGlvbiBTZXJ2aWNlLiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIkFyY2hpdGVjdHVyZTogVGhlIEFESyBFY29zeXN0ZW0iLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAicGxhbiIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTMuYXJjaCIsICJlc3RpbWF0ZSI6ICIxdyJ9LCAiY29udGVudCI6ICJXZSB3aWxsIGxldmVyYWdlIEFESydzIHBhdHRlcm4gZm9yIGNvbXBvc2FibGUgYWdlbnRzLiBUaGUgc3lzdGVtIHdpbGwgY29uc2lzdCBvZiBhIHRvcC1sZXZlbCAqKkNvb3JkaW5hdG9yIEFnZW50KiogYW5kIHR3byBzcGVjaWFsaXplZCB3b3JrZXIgYWdlbnRzLiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIlRoZSBDb29yZGluYXRvciBQYXR0ZXJuIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInByb3RvY29sIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMy5hcmNoLmNvb3JkaW5hdG9yIn0sICJjb250ZW50IjogIkluc3RlYWQgb2YgYSBtb25vbGl0aGljIGNoYWluLCB3ZSB1c2UgYSBjZW50cmFsIGBMbG1BZ2VudGAgYWN0aW5nIGFzIGEgcm91dGVyLlxuKiAgICoqSW5wdXQqKjogTmF0dXJhbCBsYW5ndWFnZSB1c2VyIHF1ZXJpZXMgKyBTdGF0ZSBDb250ZXh0IChmcm9tIFBoYXNlIDIpLlxuKiAgICoqRGVjaXNpb24qKjogVXNlcyBhIGBjbGFzc2lmeV9pbnRlbnRgIHRvb2wgb3IgZmV3LXNob3QgcHJvbXB0aW5nIHRvIGRlY2lkZTpcbiAgICAqICAgYEFOQUxZU0lTX1JFUVVJUkVEYCAtPiBEZWxlZ2F0ZSB0byBBbmFseXN0IEFnZW50LlxuICAgICogICBgQ09OVFJPTF9SRVFVSVJFRGAgLT4gRGVsZWdhdGUgdG8gQ29udHJvbGxlciBBZ2VudC5cbiAgICAqICAgYEFNQklHVU9VU2AgLT4gQXNrIGNsYXJpZnlpbmcgcXVlc3Rpb25zLlxuKiAgICoqT3V0cHV0Kio6IEFnZ3JlZ2F0ZXMgcmVzcG9uc2VzIGZyb20gd29ya2VycyBhbmQgZm9ybWF0cyB0aGUgZmluYWwgYW5zd2VyIGZvciB0aGUgdXNlci4iLCAiY2hpbGRyZW4iOiBbXX1dfSwgeyJ0aXRsZSI6ICJNb2R1bGUgMTogVGhlIEFuYWx5c3QgQWdlbnQgKERhdGEgU2NpZW50aXN0KSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMy5hbmFseXN0IiwgImJsb2NrZWRfYnkiOiBbImltcGxlbWVudGF0aW9uLnBoYXNlMy5hcmNoIl0sICJlc3RpbWF0ZSI6ICIydyJ9LCAiY29udGVudCI6ICIqKlJvbGUqKjogXCJXaHkgaXMgdGhpcyBoYXBwZW5pbmc/XCJcbioqVG9vbHMqKjogQ29kZSBFeGVjdXRpb24sIERhdGEgVmlzdWFsaXphdGlvbi4iLCAiY2hpbGRyZW4iOiBbeyJ0aXRsZSI6ICJEYXRhIFNjaWVuY2UgVG9vbCBSZXBvc2l0b3J5IiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UzLmFuYWx5c3QucmVwbyJ9LCAiY29udGVudCI6ICJXZSB3aWxsIGJ1aWxkIGEgZGVkaWNhdGVkIFB5dGhvbiBsaWJyYXJ5IChgc3JjL2xpYl9hbmFseXNpc2ApIHRoYXQgdGhlIGFnZW50IGxlYXJucyB0byB1c2UuXG4qICAgKipTdHJ1Y3R1cmUqKjpcbiAgICBgYGBweXRob25cbiAgICAvc3JjL2xpYl9hbmFseXNpc1xuICAgICAgIC92aXN1YWxpemUucHkgICAjIEhpZ2gtbGV2ZWwgcGxvdCB3cmFwcGVycyAocGxvdF90aW1lX3NlcmllcywgcGxvdF9kaXN0cmlidXRpb24pXG4gICAgICAgL3N0YXRzLnB5ICAgICAgICMgSHlwb3RoZXNpcyB0ZXN0aW5nIChhbm92YSwgdF90ZXN0KVxuICAgICAgIC9jbGVhbi5weSAgICAgICAjIEF1dG8tY2xlYW5pbmcgdXRpbGl0aWVzXG4gICAgYGBgXG4qICAgKipJbnRlZ3JhdGlvbioqOlxuICAgICogICBFeHBvc2UgdGhlc2UgZnVuY3Rpb25zIGFzICoqQURLIFRvb2xzKiouXG4gICAgKiAgIFVzZSB0eXBlIGhpbnRzIGFuZCBkb2NzdHJpbmdzIGhlYXZpbHksIGFzIEFESyB1c2VzIHRoZXNlIGZvciB0b29sIGRlZmluaXRpb24gdmVyaWZpY2F0aW9uLiIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJDb2RlIEV4ZWN1dGlvbiBTYW5kYm94IiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UzLmFuYWx5c3Quc2FuZGJveCJ9LCAiY29udGVudCI6ICIqICAgKipNZWNoYW5pc20qKjogVGhlIGFnZW50IHdyaXRlcyBjb2RlIHRoYXQgaW1wb3J0cyBgbGliX2FuYWx5c2lzYC5cbiogICAqKlNlY3VyaXR5Kio6IFVzZSBBREsncyBgQ29kZUV4ZWN1dGlvblRvb2xgIGNvbmZpZ3VyZWQgd2l0aCBhIHJlc3RyaWN0ZWQgZW52aXJvbm1lbnQgKG9yIEUyQiBpbnRlZ3JhdGlvbiBpZiBBREsgbmF0aXZlIHN1cHBvcnQgaXMgaW5zdWZmaWNpZW50KS5cbiogICAqKk91dHB1dCBIYW5kbGluZyoqOiBDYXB0dXJlIGBzdGRvdXRgICh0ZXh0KSBhbmQgZ2VuZXJhdGVkIGFydGlmYWN0cyAoUE5HL0pTT04pIHRvIHBhc3MgYmFjayB0byB0aGUgQ29vcmRpbmF0b3IuIiwgImNoaWxkcmVuIjogW119XX0sIHsidGl0bGUiOiAiTW9kdWxlIDI6IFRoZSBDb250cm9sbGVyIEFnZW50IChPcHRpbWl6ZXIpIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UzLmNvbnRyb2xsZXIiLCAiYmxvY2tlZF9ieSI6IFsiaW1wbGVtZW50YXRpb24ucGhhc2UzLmFuYWx5c3QiXSwgImVzdGltYXRlIjogIjJ3In0sICJjb250ZW50IjogIioqUm9sZSoqOiBcIk9wdGltaXplIGZvciBYLlwiXG4qKlRvb2xzKio6IE9wdGltaXphdGlvbiBBbGdvcml0aG1zLCBTaW11bGF0aW9uLiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIkNvbnRyb2wgQWxnb3JpdGhtcyBJbnRlZ3JhdGlvbiIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMy5jb250cm9sbGVyLmludGVncmF0aW9uIn0sICJjb250ZW50IjogIkludGVncmF0ZSB0aGUgZXh0ZXJuYWwgcmVwb3NpdG9yeSBbY29udHJvbF9hbGdvcml0aG1zXShodHRwczovL2dpdGh1Yi5jb20vSWduYWNpb09RL2NvbnRyb2xfYWxnb3JpdGhtcykuXG4qICAgKipTdGVwIDEqKjogU3VibW9kdWxlIG9yIFBhY2thZ2UgaW50ZWdyYXRpb24gb2YgdGhlIHVzZXIncyByZXBvc2l0b3J5LlxuKiAgICoqU3RlcCAyKio6IENyZWF0ZSBhbiAqKkFESyBUb29sIFdyYXBwZXIqKiAoYHNyYy90b29scy9jb250cm9sX3Rvb2xzLnB5YCkgdGhhdCBleHBvc2VzIGtleSBhbGdvcml0aG1zIGFzIGNhbGxhYmxlIGZ1bmN0aW9uczpcbiAgICAqICAgYHJ1bl9tcGNfb3B0aW1pemF0aW9uKHN0YXRlX3ZlY3RvciwgY29uc3RyYWludHMpYFxuICAgICogICBgc29sdmVfbmV3c3ZlbmRvcihkZW1hbmRfZGlzdCwgY29zdHMpYFxuICAgICogICBgc2ltdWxhdGVfc2NlbmFyaW8oaW5pdGlhbF9zdGF0ZSwgaG9yaXpvbilgXG4qICAgKipTdGVwIDMqKjogRGVmaW5lIHRoZSBcIlN0YXRlIFNjaGVtYVwiLiBUaGUgQWdlbnQgbXVzdCBrbm93IGhvdyB0byBtYXAgdGhlIHJhdyB0ZWxlbWV0cnkgKGZyb20gQmlnUXVlcnkvUGhhc2UgMikgaW50byB0aGUgaW5wdXRzIHJlcXVpcmVkIGJ5IHRoZXNlIGFsZ29yaXRobXMuIiwgImNoaWxkcmVuIjogW119XX0sIHsidGl0bGUiOiAiTW9kdWxlIDM6IEFnZW50IERldmVsb3BtZW50ICYgT3BzIChBREspIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UzLm9wcyIsICJibG9ja2VkX2J5IjogWyJpbXBsZW1lbnRhdGlvbi5waGFzZTMuY29udHJvbGxlciJdLCAiZXN0aW1hdGUiOiAiMXcifSwgImNvbnRlbnQiOiAiRXN0YWJsaXNoIHRoZSBsaWZlY3ljbGUgZm9yIGRldmVsb3BpbmcgYW5kIGltcHJvdmluZyB0aGVzZSBhZ2VudHMuIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiRXZhbHVhdGlvbiBQaXBlbGluZSAoR2VuQUkgRXZhbCkiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTMub3BzLmV2YWwifSwgImNvbnRlbnQiOiAiVXNlIEdvb2dsZSdzIEdlbiBBSSBFdmFsdWF0aW9uIFNlcnZpY2UgdG8gbW92ZSBiZXlvbmQgXCJ2aWJlcy1iYXNlZFwiIHRlc3RpbmcuXG4qICAgKipUcmFqZWN0b3J5IEV2YWx1YXRpb24qKjogY2hlY2sgaWYgdGhlIEFuYWx5c3QgQWdlbnQgKmFjdHVhbGx5KiB1c2VkIHRoZSBgdmlzdWFsaXplLnB5YCB0b29sIG9yIGlmIGl0IHRyaWVkIHRvIGhhbGx1Y2luYXRlIGEgcGxvdC5cbiogICAqKkdvbGRlbiBEYXRhc2V0cyoqOiBDcmVhdGUgYSBzZXQgb2YgKFF1ZXJ5LCBFeHBlY3RlZF9Ub29sX0NhbGwsIEV4cGVjdGVkX091dGNvbWUpIHR1cGxlcy5cbiogICAqKkNJL0NEKio6IFJ1biBgYWRrIGV2YWxgIGFzIHBhcnQgb2YgdGhlIGRlcGxveW1lbnQgcGlwZWxpbmUuIiwgImNoaWxkcmVuIjogW119LCB7InRpdGxlIjogIkRlcGxveW1lbnQgKFZlcnRleCBBSSkiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTMub3BzLmRlcGxveSJ9LCAiY29udGVudCI6ICIqICAgKipDb250YWluZXJpemUqKjogV3JhcCB0aGUgQURLIGFnZW50IHNlcnZlciBpbiBhIERvY2tlciBjb250YWluZXIuXG4qICAgKipEZXBsb3kqKjogUHVzaCB0byBDbG91ZCBSdW4uXG4qICAgKipFeHBvc2UqKjogQ29ubmVjdCB0aGUgQ2xvdWQgUnVuIGVuZHBvaW50IHRvIHRoZSBBUEkgR2F0ZXdheSBjcmVhdGVkIGluIFBoYXNlIDIuIiwgImNoaWxkcmVuIjogW119XX1dfV19LCB7InRpdGxlIjogIkNvbW1lcmNpYWwgU3RyYXRlZ3kiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJhY3RpdmUiLCAidHlwZSI6ICJwbGFuIiwgImlkIjogInByb2R1Y3Quc2Fhcy5jb21tZXJjaWFsIiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTI0VDA5OjQwOjU1KzAxOjAwIn0sICJjb250ZW50IjogIlRoaXMgc2VjdGlvbiBvdXRsaW5lcyB0aGUgc3RyYXRlZ3kgZm9yIG1vbmV0aXphdGlvbiwgdXNlciBhY3F1aXNpdGlvbiwgYW5kIG1hcmtldCB2YWxpZGF0aW9uLiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIkZyb250bGluZSBUcmlhbHMiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAicGxhbiIsICJpZCI6ICJwcm9kdWN0LnNhYXMuY29tbWVyY2lhbC5mcm9udGxpbmUiLCAiZXN0aW1hdGUiOiAiNHcifSwgImNvbnRlbnQiOiAiKipPYmplY3RpdmUqKjogVmFsaWRhdGUgdGhlIHByb2R1Y3QgdmFsdWUgcHJvcG9zaXRpb24gd2l0aCByZWFsIHVzZXJzIGluIGEgbG93LXN0YWtlcyBlbnZpcm9ubWVudC5cbiogICAqKkFwcHJvYWNoKio6IFwiRG8gdGhpbmdzIHRoYXQgZG9uJ3Qgc2NhbGUuXCIgRGlyZWN0IG91dHJlYWNoIHRvIGZyaWVuZGx5IFNNQnMgKFJldGFpbC9Mb2dpc3RpY3MpLlxuKiAgICoqR29hbCoqOiA1LTEwIGFjdGl2ZSB1c2VycyBwcm92aWRpbmcgd2Vla2x5IGZlZWRiYWNrLlxuKiAgICoqTW9uZXRpemF0aW9uKio6IEZyZWUgb3IgaGVhdmlseSBkaXNjb3VudGVkIGluIGV4Y2hhbmdlIGZvciBmZWVkYmFjay90ZXN0aW1vbmlhbHMuXG4qICAgKipNZXRyaWNzKio6IEVuZ2FnZW1lbnQgKERhaWx5IEFjdGl2ZSBVc2VycyksIFwiTWFnaWMgTW9tZW50c1wiIChlLmcuLCBcIlRoaXMgc2F2ZWQgbWUgMiBob3Vyc1wiKS4iLCAiY2hpbGRyZW4iOiBbXX0sIHsidGl0bGUiOiAiUGF5bWVudCBTY2hlbWEiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAicGxhbiIsICJpZCI6ICJwcm9kdWN0LnNhYXMuY29tbWVyY2lhbC5wYXltZW50IiwgImJsb2NrZWRfYnkiOiBbInByb2R1Y3Quc2Fhcy5jb21tZXJjaWFsLmZyb250bGluZSJdLCAiZXN0aW1hdGUiOiAiMncifSwgImNvbnRlbnQiOiAiKipPYmplY3RpdmUqKjogQnVpbGQgdGhlIGluZnJhc3RydWN0dXJlIHRvIGNhcHR1cmUgdmFsdWUuXG4qICAgKipUZWNoKio6IFN0cmlwZSAvIExlbW9uIFNxdWVlenkgaW50ZWdyYXRpb24uXG4qICAgKipNb2RlbHMqKjpcbiAgICAqICAgKipGcmVlbWl1bSoqOiBMb2NhbC1vbmx5IGZlYXR1cmVzIGFyZSBmcmVlLlxuICAgICogICAqKlBybyAoJDI5L21vKSoqOiBDbG91ZCBzeW5jICsgYmFzaWMgQW5hbHlzdCBBZ2VudCB1c2FnZSAodG9rZW4gY2FwcGVkKS5cbiAgICAqICAgKipFbnRlcnByaXNlIChDdXN0b20pKio6IEZ1bGwgQ29udHJvbGxlciBBZ2VudCBhY2Nlc3MgKyBkZWRpY2F0ZWQgc3VwcG9ydC5cbiogICAqKkRlbGl2ZXJhYmxlKio6IEEgc2VhbWxlc3MgXCJVcGdyYWRlXCIgZmxvdyB3aXRoaW4gdGhlIFN0cmVhbWxpdCBhcHAuIiwgImNoaWxkcmVuIjogW119LCB7InRpdGxlIjogIk1hcmtldGluZyAmIEdyb3d0aCIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJwbGFuIiwgImlkIjogInByb2R1Y3Quc2Fhcy5jb21tZXJjaWFsLm1hcmtldGluZyIsICJibG9ja2VkX2J5IjogWyJwcm9kdWN0LnNhYXMuY29tbWVyY2lhbC5wYXltZW50Il19LCAiY29udGVudCI6ICIqKk9iamVjdGl2ZSoqOiBTY2FsZSBhd2FyZW5lc3MgYW5kIGFjcXVpc2l0aW9uLlxuKiAgICoqQ29udGVudCBNYXJrZXRpbmcqKjogQmxvZyBwb3N0cy9WaWRlb3MgZGVtb25zdHJhdGluZyBcIkRhdGEgU2NpZW5jZSBmb3IgTm9uLURhdGEgU2NpZW50aXN0c1wiIHVzaW5nIG91ciBhcHAuXG4qICAgKipPdXRyZWFjaCoqOiBUYXJnZXRlZCBMaW5rZWRJbiBvdXRyZWFjaCB0byBPcGVyYXRpb25zIE1hbmFnZXJzIGluIExvZ2lzdGljcy9SZXRhaWwuXG4qICAgKipDaGFubmVscyoqOlxuICAgICogICAqKk9yZ2FuaWMqKjogU0VPLCBHaXRIdWIgKE9wZW4gU291cmNlIGNvcmU/KS5cbiAgICAqICAgKipQYWlkKio6IFRhcmdldGVkIGFkcyBvbiBuaWNoZSBpbmR1c3RyeSBmb3J1bXMgKGxhdGVyIHN0YWdlKS4iLCAiY2hpbGRyZW4iOiBbXX1dfSwgeyJ0aXRsZSI6ICJMZWdhbHMgJiBBZG1pbiIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJwbGFuIiwgImlkIjogImxlZ2FsIiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTI0VDA5OjU3OjI1KzAxOjAwIn0sICJjb250ZW50IjogIlRoaXMgc2VjdGlvbiBkZXRhaWxzIHRoZSBhZG1pbmlzdHJhdGl2ZSBhbmQgbGVnYWwgaW5mcmFzdHJ1Y3R1cmUsIGRpdmlkZWQgYnkganVyaXNkaWN0aW9uLiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIlVTIEJyYW5jaCAoSGVhZHF1YXJ0ZXJzKSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImFjdGl2ZSIsICJ0eXBlIjogInBsYW4iLCAiaWQiOiAibGVnYWwudXMiLCAib3duZXIiOiAidXNlciJ9LCAiY29udGVudCI6ICIqKlJvbGUqKjogR2xvYmFsIFJldmVudWUgQ29sbGVjdGlvbiwgQ2xvdWQgU2VydmljZXMgQ29udHJhY3RpbmcsIEludGVsbGVjdHVhbCBQcm9wZXJ0eSBIb2xkZXIuIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiQmFua2luZyAmIENsb3VkIEFjY291bnRpbmciLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJsZWdhbC51cy5iYW5raW5nIiwgImVzdGltYXRlIjogIjF3In0sICJjb250ZW50IjogIioqT2JqZWN0aXZlKio6IEVzdGFibGlzaCB0aGUgZmluYW5jaWFsIGh1Yi5cbiogICAqKkJhbmtpbmcqKjpcbiAgICAqICAgKipNZXJjdXJ5Kio6IFJlY29tbWVuZGVkIChaZXJvIGZlZXMsIGhpZ2ggeWllbGQpLlxuICAgICogICAqKkJhY2t1cCoqOiBOb3ZvIC8gR3Jhc3Nob3BwZXIuXG4gICAgKiAgICoqQWN0aW9uKio6IEFwcGx5IHdpdGggRUlOIGFuZCBBcnRpY2xlcyBvZiBPcmdhbml6YXRpb24uXG4qICAgKipBY2NvdW50aW5nKio6XG4gICAgKiAgICoqUXVpY2tCb29rcyBPbmxpbmUqKjogQ29ubmVjdCB0byBNZXJjdXJ5LlxuICAgICogICAqKlJldmVudWUqKjogU3RyaXBlIC8gQXBwIFN0b3JlIHBheW91dHMgbGFuZCBoZXJlLlxuICAgICogICAqKkV4cGVuc2VzKio6IFBheSBHb29nbGUgQ2xvdWQgKEdDUC9Xb3Jrc3BhY2UpLCBHaXRIdWIsIGFuZCBFT1IvQ29udHJhY3RvciBmZWVzIGZyb20gdGhpcyBhY2NvdW50LiIsICJjaGlsZHJlbiI6IFtdfV19LCB7InRpdGxlIjogIkFyZ2VudGluYSBCcmFuY2ggKFRhbGVudCBIdWIpIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInBsYW4iLCAiaWQiOiAibGVnYWwuYXIiLCAib3duZXIiOiAidXNlciJ9LCAiY29udGVudCI6ICIqKlJvbGUqKjogVGFsZW50IEFjcXVpc2l0aW9uLCBTb2Z0d2FyZSBEZXZlbG9wbWVudCBDZW50ZXIuIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiRW50aXR5IFNldHVwOiBTLlIuTC4gKFNvY2llZGFkIGRlIFJlc3BvbnNhYmlsaWRhZCBMaW1pdGFkYSkiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJsZWdhbC5hci5zZXR1cCIsICJlc3RpbWF0ZSI6ICI0dyJ9LCAiY29udGVudCI6ICIqKk9iamVjdGl2ZSoqOiBFc3RhYmxpc2ggYSBsb2NhbCBlbnRpdHkgdG8gaGlyZSBmdWxsLXRpbWUgZW1wbG95ZWVzIHdpdGhvdXQgRU9SIG1hcmt1cC5cbiogICAqKlN0cnVjdHVyZSoqOlxuICAgICogICAqKlBhcnRuZXJzKio6IFJlcXVpcmVzIDIgcGFydG5lcnMuIE9wdGlvbnM6XG4gICAgICAgICogICAqKk9wdGlvbiBBIChDb3Jwb3JhdGUgTGluaykqKjogWW91IDk1JSArIFVTIExMQyA1JSAoKlJlcXVpcmVzIFVTIExMQyBJR0ogcmVnaXN0cmF0aW9uKikuXG4gICAgICAgICogICAqKk9wdGlvbiBCIChGYXN0IFJvdXRlKSoqOiBZb3UgOTUlICsgVHJ1c3RlZCBJbmRpdmlkdWFsIDUlICgqQXZvaWRzIFVTIExMQyBwYXBlcndvcmsqKS5cbiAgICAqICAgKipDYXBpdGFsKio6IH5BUlMgMTAwLDAwMCAoU3ltYm9saWMpLiAyNSUgcGFpZCBhdCBzaWduaW5nLlxuICAgICogICAqKk1hbmFnZXIqKjogTXVzdCBoYXZlIGRvbWljaWxlIGluIEFyZ2VudGluYS4gKFlvdSBjYW4gc2VydmUgYXMgTWFuYWdlciB1c2luZyB5b3VyIEFyZ2VudGluZSBETkkvUGFzc3BvcnQgaWYgeW91IG1haW50YWluIGEgbG9jYWwgYWRkcmVzcykuXG4qICAgKipQcm9jZXNzKio6XG4gICAgMS4gICoqTmFtZSBSZXNlcnZhdGlvbioqOiBDaGVjayBhdmFpbGFiaWxpdHkgd2l0aCBJR0ouXG4gICAgMi4gICoqQnlsYXdzIChDb250cmF0byBTb2NpYWwpKio6IERyYWZ0ZWQgYnkgYSBsb2NhbCBOb3RhcnkgUHVibGljICgqRXNjcmliYW5vKikuXG4gICAgMy4gICoqUmVnaXN0cmF0aW9uKio6IEZpbGUgd2l0aCBJR0ogKEluc3BlY2NpXHUwMGYzbiBHZW5lcmFsIGRlIEp1c3RpY2lhKS5cbiAgICA0LiAgKipUYXggSUQqKjogT2J0YWluIENVSVQgZnJvbSBBRklQLlxuKiAgICoqVVMgTExDIFJlcXVpcmVtZW50Kio6IFRvIGJlIGEgcGFydG5lciwgdGhlIFVTIExMQyBtdXN0IHJlZ2lzdGVyIHdpdGggSUdKIHVuZGVyIFwiQXJ0aWNsZSAxMjNcIiAoU2ltcGxpZmllZCBpbiAyMDI0LCBubyBsb25nZXIgbmVlZCB0byBwcm92ZSBhc3NldHMgYWJyb2FkKS4iLCAiY2hpbGRyZW4iOiBbXX0sIHsidGl0bGUiOiAiSGlyaW5nICYgUGF5cm9sbCIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImxlZ2FsLmFyLmhpcmluZyIsICJibG9ja2VkX2J5IjogWyJsZWdhbC5hci5zZXR1cCJdfSwgImNvbnRlbnQiOiAiKipPYmplY3RpdmUqKjogSGlyZSBsb2NhbCBkZXZlbG9wZXJzIGxlZ2FsbHkuXG4qICAgKipQYXlyb2xsKio6XG4gICAgKiAgICoqUmVnaXN0cmF0aW9uKio6IFJlZ2lzdGVyIGFzIEVtcGxveWVyICgqQWx0YSBkZSBFbXBsZWFkb3IqKSB3aXRoIEFGSVAuXG4gICAgKiAgICoqU2VydmljZSoqOiBVc2UgYSBsb2NhbCBhY2NvdW50aW5nIGZpcm0gKEVzdHVkaW8gQ29udGFibGUpIHRvIHByb2Nlc3MgbW9udGhseSBwYXlzbGlwcyAoKlJlY2lib3MgZGUgU3VlbGRvKikgYW5kIEY5MzEgKFNvY2lhbCBTZWN1cml0eSkuXG4qICAgKipCZW5lZml0cyoqOlxuICAgICogICAqKk1hbmRhdG9yeSoqOiAxM3RoIFNhbGFyeSAoKkFndWluYWxkbyopLCBWYWNhdGlvbiAoMTQgZGF5cyksIEhlYWx0aCBJbnN1cmFuY2UgKCpPYnJhIFNvY2lhbCopLlxuICAgICogICAqKlBlcmtzKio6IFVTRCBTcGxpdC1wYXltZW50IChwYXJ0IG9mIHNhbGFyeSBwYWlkIGFicm9hZCkgaXMgY29tbW9uIGZvciByZXRlbnRpb24sIGJ1dCByZXF1aXJlcyBjYXJlZnVsIHRheCBzdHJ1Y3R1cmluZyAoKmNvbnN1bHQgbG9jYWwgQ1BBKikuIiwgImNoaWxkcmVuIjogW119XX1dfSwgeyJ0aXRsZSI6ICJTZWN1cml0eSAmIFNhZmV0eSBDaGVja3MiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJhY3RpdmUiLCAidHlwZSI6ICJndWlkZWxpbmUiLCAiaWQiOiAicHJvZHVjdC5zYWFzLnNlY3VyaXR5IiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTIzVDEzOjQ3OjA3KzAxOjAwIn0sICJjb250ZW50IjogIi0gICAqKkluZGlyZWN0IEV4ZWN1dGlvbioqOiBDbGllbnRzIG9ubHkgc3VibWl0IG5hdHVyYWwgbGFuZ3VhZ2UsIG5ldmVyIGNvZGUuXG4tICAgKipSZXBvc2l0b3J5IFNjb3BpbmcqKjogR2VuZXJhdGVkIGNvZGUgY2FuIG9ubHkgaW1wb3J0IHdoaXRlbGlzdGVkIGxpYnJhcmllcyAoYHBhbmRhc2AsIGBudW1weWAsIGBsaWJfYW5hbHlzaXNgKS4gTm8gYG9zYCBvciBgc3lzYC5cbi0gICAqKlNpbXVsYXRpb24gSXNvbGF0aW9uKio6IFVzZXItcHJvdmlkZWQgbG9naWMgcnVucyBpbiBgZ1Zpc29yYCBzYW5kYm94ZXMuXG4tICAgKipBY3Rpb24gQm91bmRpbmcqKjogRGV0ZXJtaW5pc3RpYyBsb2dpYyBsYXllciB2YWxpZGF0ZXMgYWN0aW9ucyBhZ2FpbnN0IHNhZmV0eSBjb25zdHJhaW50cyAoZS5nLiwgYE1BWF9PUkRFUl9MSU1JVGApIGJlZm9yZSBleGVjdXRpb24uIiwgImNoaWxkcmVuIjogW119LCB7InRpdGxlIjogIlJlc2VhcmNoIERpcmVjdGlvbnMiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJhY3RpdmUiLCAidHlwZSI6ICJwbGFuIiwgImlkIjogInByb2R1Y3Quc2Fhcy5yZXNlYXJjaCIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QxMzo0NzowNyswMTowMCJ9LCAiY29udGVudCI6ICItICAgKipNQlJMIChEcmVhbWVyVjMpKio6IExlYXJuaW5nIFdvcmxkIE1vZGVscyBmcm9tIHRlbGVtZXRyeSB0byBzaW11bGF0ZSBlbnZpcm9ubWVudHMuXG4tICAgKipTYWZlIFJMKio6IENvbnN0cmFpbmVkIE1EUHMgKExhZ3JhbmdpYW4gUmVsYXhhdGlvbikgdG8gZW5zdXJlIHNhZmV0eSBkdXJpbmcgZXhwbG9yYXRpb24uXG4tICAgKipSZWZsZXhpb24qKjogQWdlbnRzIHRoYXQgYW5hbHl6ZSB0aGVpciBvd24gdHJhY2ViYWNrcyB0byBpdGVyYXRpdmVseSBmaXggY29kZS4iLCAiY2hpbGRyZW4iOiBbXX1dfSwgImRlcGVuZGVuY2llcyI6IFt7InNvdXJjZSI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTEuaW5pdCIsICJ0YXJnZXQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLndhcmVob3VzZSJ9LCB7InNvdXJjZSI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTEud2FyZWhvdXNlLm1hbmFnZXIiLCAidGFyZ2V0IjogImltcGxlbWVudGF0aW9uLnBoYXNlMS53YXJlaG91c2UuaW5nZXN0In0sIHsic291cmNlIjogImltcGxlbWVudGF0aW9uLnBoYXNlMS53YXJlaG91c2UiLCAidGFyZ2V0IjogImltcGxlbWVudGF0aW9uLnBoYXNlMS51aSJ9LCB7InNvdXJjZSI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTEudWkubGF5b3V0IiwgInRhcmdldCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTEudWkuY2hhdCJ9LCB7InNvdXJjZSI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTEudWkiLCAidGFyZ2V0IjogImltcGxlbWVudGF0aW9uLnBoYXNlMS50ZXN0aW5nIn0sIHsic291cmNlIjogImltcGxlbWVudGF0aW9uLnBoYXNlMS50ZXN0aW5nLnVuaXQiLCAidGFyZ2V0IjogImltcGxlbWVudGF0aW9uLnBoYXNlMS50ZXN0aW5nLmludGVncmF0aW9uIn0sIHsic291cmNlIjogImltcGxlbWVudGF0aW9uLnBoYXNlMS50ZXN0aW5nIiwgInRhcmdldCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTEucGFja2FnaW5nIn0sIHsic291cmNlIjogImltcGxlbWVudGF0aW9uLnBoYXNlMSIsICJ0YXJnZXQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UyIn0sIHsic291cmNlIjogImltcGxlbWVudGF0aW9uLnBoYXNlMi5pbmZyYS5zZXR1cCIsICJ0YXJnZXQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UyLmluZnJhLmlhYyJ9LCB7InNvdXJjZSI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIuaW5mcmEiLCAidGFyZ2V0IjogImltcGxlbWVudGF0aW9uLnBoYXNlMi5hdXRoIn0sIHsic291cmNlIjogImltcGxlbWVudGF0aW9uLnBoYXNlMi5hdXRoIiwgInRhcmdldCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIuYXBpIn0sIHsic291cmNlIjogImltcGxlbWVudGF0aW9uLnBoYXNlMi5hcGkuZGV2IiwgInRhcmdldCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIuYXBpLmRlcGxveSJ9LCB7InNvdXJjZSI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIuYXBpIiwgInRhcmdldCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIucGlwZWxpbmUifSwgeyJzb3VyY2UiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UyLnBpcGVsaW5lLmdjcyIsICJ0YXJnZXQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UyLnBpcGVsaW5lLmJpZ3F1ZXJ5In0sIHsic291cmNlIjogImltcGxlbWVudGF0aW9uLnBoYXNlMiIsICJ0YXJnZXQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UzIn0sIHsic291cmNlIjogImltcGxlbWVudGF0aW9uLnBoYXNlMy5hcmNoIiwgInRhcmdldCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTMuYW5hbHlzdCJ9LCB7InNvdXJjZSI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTMuYW5hbHlzdCIsICJ0YXJnZXQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UzLmNvbnRyb2xsZXIifSwgeyJzb3VyY2UiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UzLmNvbnRyb2xsZXIiLCAidGFyZ2V0IjogImltcGxlbWVudGF0aW9uLnBoYXNlMy5vcHMifSwgeyJzb3VyY2UiOiAicHJvZHVjdC5zYWFzLmNvbW1lcmNpYWwuZnJvbnRsaW5lIiwgInRhcmdldCI6ICJwcm9kdWN0LnNhYXMuY29tbWVyY2lhbC5wYXltZW50In0sIHsic291cmNlIjogInByb2R1Y3Quc2Fhcy5jb21tZXJjaWFsLnBheW1lbnQiLCAidGFyZ2V0IjogInByb2R1Y3Quc2Fhcy5jb21tZXJjaWFsLm1hcmtldGluZyJ9LCB7InNvdXJjZSI6ICJsZWdhbC5hci5zZXR1cCIsICJ0YXJnZXQiOiAibGVnYWwuYXIuaGlyaW5nIn1dfQ==";
    if (rawData.startsWith("__DATA")) {
        log("Error: Placeholder not replaced.");
    } else {
        const data = decodeData(rawData);
        if (data && typeof d3 !== 'undefined') {
            log("D3 loaded. Version: " + d3.version);
            document.getElementById('loading').style.display = 'none';
            parsedData = data.tree ? data : { tree: data, dependencies: [] }; // Handle legacy format if needed
            initViz(parsedData);
        } else {
            if (typeof d3 === 'undefined') {
                handleScriptError();
            } else {
                log("Error: Data is null.");
            }
        }
    }
} catch (globalErr) {
    log("Global Error: " + globalErr.message);
}

function initViz(fullData) {
    log("Initializing Visualization...");
    try {
        const width = window.innerWidth;
        const height = window.innerHeight;

        svg = d3.select("svg");
        
        // Clear previous if any
        svg.selectAll("*").remove();
        
        // Defs for arrows
        const defs = svg.append("defs");
        defs.append("marker")
            .attr("id", "arrowhead")
            .attr("refX", 10) /* adjust based on node radius */
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-2.5 L6,0 L0,2.5")
            .style("fill", "#e74c3c");

        g = svg.append("g");

        zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on("zoom", (event) => g.attr("transform", event.transform));

        svg.call(zoom);

        // Define tree layout params
        // nodeSize depends on orientation. 
        // For standard top-down: [width, height]
        // For left-right (projecting y as x): [height, width]
        tree = d3.tree().nodeSize([40, 300]); 

        root = d3.hierarchy(fullData.tree, d => d.children);
        root.x0 = 0;
        root.y0 = 0;

        // Check if root has children
        if (!root.children) {
            log("Warning: Root has no children.");
        } else {
            log("Root children count: " + root.children.length);
        }

        // Collapse
        if(root.children) {
            root.children.forEach(collapseRecursive);
        }

        update(root);
        
        // Initial center
        const initialTransform = d3.zoomIdentity.translate(100, height / 2).scale(1);
        svg.call(zoom.transform, initialTransform);
        
        log("Viz Initialized.");

    } catch (vizErr) {
        log("Viz Error: " + vizErr.message);
        log(vizErr.stack);
    }
}

function collapseRecursive(d) {
  if(d.children) {
    d._children = d.children;
    d.children.forEach(collapseRecursive);
    d.children = null;
  }
}

function expandAll() {
    function recurse(d) {
        if (d._children) {
            d.children = d._children;
            d._children = null;
        }
        if (d.children) d.children.forEach(recurse);
    }
    recurse(root);
    update(root);
}

function collapseAll() {
    if (root.children) root.children.forEach(collapseRecursive);
    update(root);
}

function resetZoom() {
    const height = window.innerHeight;
    svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity.translate(100, height/2).scale(1));
}

function toggleDeps() {
    showDependencies = !showDependencies;
    update(root);
}

function update(source) {
  const treeData = tree(root);

  // Compute the new tree layout.
  const nodes = treeData.descendants();
  const links = treeData.links();

  // Normalize for left-right tree
  // Swap x and y for horizontal layout
  nodes.forEach(d => { d.y = d.depth * 300; });

  // Node Map for calculating dependencies
  const nodeMap = new Map();
  nodes.forEach(d => {
      // Key can be ID or Node Title (fallback)
      if (d.data.metadata && d.data.metadata.id) {
          nodeMap.set(d.data.metadata.id, d);
      }
      // Also map by title for redundancy if needed, but ID is preferred
  });


  // ****************** Links (Hierarchy) ***************************
  const link = g.selectAll('path.link')
      .data(links, d => d.target.id);

  const linkEnter = link.enter().insert('path', "g")
      .attr("class", "link")
      .attr('d', d => {
        const o = {x: source.x0, y: source.y0};
        return diagonal(o, o);
      });

  const linkUpdate = linkEnter.merge(link);

  linkUpdate.transition()
      .duration(duration)
      .attr('d', d => diagonal(d.source, d.target));

  link.exit().transition()
      .duration(duration)
      .attr('d', d => {
        const o = {x: source.x, y: source.y};
        return diagonal(o, o);
      })
      .remove();

  // ****************** Dependency Links (Explicit) ***************************
  // Calculate active dependencies based on current visible nodes
  let depLinksData = [];
  if (showDependencies && parsedData.dependencies) {
      parsedData.dependencies.forEach(dep => {
          const sourceNode = nodeMap.get(dep.source);
          const targetNode = nodeMap.get(dep.target);
          
          if (sourceNode && targetNode) {
              depLinksData.push({source: sourceNode, target: targetNode});
          }
      });
  }

  const depLink = g.selectAll('path.dep-link')
      .data(depLinksData, d => d.source.id + "-" + d.target.id);

  const depLinkEnter = depLink.enter().append('path')
      .attr("class", "dep-link")
      .attr('d', d => {
           // Start from wherever the source is currently (animation) -> usually nice to just fade in or pop in
           // For simplicity, we calculate the curve immediately or use the source position
           return dependencyPath(d.source, d.target);
      })
      .style("opacity", 0);

  depLinkEnter.transition().duration(duration).style("opacity", 0.6);

  depLink.transition().duration(duration)
      .attr('d', d => dependencyPath(d.source, d.target))
      .style("opacity", 0.6);

  depLink.exit().transition().duration(duration).style("opacity", 0).remove();


  // ****************** Nodes ***************************
  const node = g.selectAll('g.node')
      .data(nodes, d => d.id || (d.id = ++i));

  const nodeEnter = node.enter().append('g')
      .attr('class', 'node')
      .attr("transform", d => "translate(" + source.y0 + "," + source.x0 + ")")
      .on('click', click);

  nodeEnter.append('circle')
      .attr('r', 1e-6)
      .attr('class', d => {
          const status = (d.data.metadata && d.data.metadata.status) || 'default';
          return `status-${status.replace(' ', '-')}`;
      });

  nodeEnter.append('text')
      .attr("dy", ".35em")
      .attr("x", d => d.children || d._children ? -13 : 13)
      .attr("text-anchor", d => d.children || d._children ? "end" : "start")
      .text(d => {
          let title = d.data.title;
          return title.length > 30 ? title.substring(0, 30) + '...' : title;
      })
      .style('fill-opacity', 1e-6);

  const nodeUpdate = nodeEnter.merge(node);

  nodeUpdate.transition()
      .duration(duration)
      .attr("transform", d => "translate(" + d.y + "," + d.x + ")");

  nodeUpdate.select('circle')
      .attr('r', 8)
      .style("fill", d => d._children ? "#fff" : "") 
      .attr('class', d => `status-${((d.data.metadata && d.data.metadata.status) || 'default').replace(' ', '-')}`);

  nodeUpdate.select('text').style("fill-opacity", 1);

  const nodeExit = node.exit().transition()
      .duration(duration)
      .attr("transform", d => "translate(" + source.y + "," + source.x + ")")
      .remove();

  nodeExit.select('circle').attr('r', 1e-6);
  nodeExit.select('text').style('fill-opacity', 1e-6);


  nodes.forEach(d => {
    d.x0 = d.x;
    d.y0 = d.y;
  });

  function diagonal(s, d) {
    return `M ${s.y} ${s.x}
            C ${(s.y + d.y) / 2} ${s.x},
              ${(s.y + d.y) / 2} ${d.x},
              ${d.y} ${d.x}`;
  }

  function dependencyPath(s, t) {
      // Custom path for dependencies - larger arc to avoid hierarchy lines?
      // Or just a straightish Bezier
      const dx = t.y - s.y;
      const dy = t.x - s.x;
      const dr = Math.sqrt(dx * dx + dy * dy) * 1.5; // Controls curvature
      
      // Arc path
      return `M${s.y},${s.x}A${dr},${dr} 0 0,1 ${t.y},${t.x}`;
  }

  function click(event, d) {
    showDetails(d.data);
    if (d.children) {
        d._children = d.children;
        d.children = null;
    } else {
        d.children = d._children;
        d._children = null;
    }
    update(d);
  }
}

function showDetails(data) {
    const sidebar = document.getElementById('sidebar');
    const container = document.getElementById('details');
    sidebar.style.display = 'block';

    const status = (data.metadata.status || 'todo').replace(' ', '-');
    
    let metaHtml = '';
    for (const [key, value] of Object.entries(data.metadata)) {
        if (key === 'status') continue;
        metaHtml += `<div><strong>${key}:</strong> ${JSON.stringify(value).replace(/"/g, '')}</div>`;
    }

    container.innerHTML = `
        <span class="meta-tag tag-${status}">${status.toUpperCase().replace('-', ' ')}</span>
        <h2>${data.title}</h2>
        <div style="margin-bottom: 20px; font-size: 0.9em; color: #7f8c8d;">
            ${metaHtml}
        </div>
        <hr style="border: 0; border-top: 1px solid #eee;"/>
        <div class="content-block">
            <pre style="background:none; padding:0; white-space: pre-wrap; font-family: inherit;">${data.content || "No content."}</pre>
        </div>
    `;
}
</script>
</body>
</html>
