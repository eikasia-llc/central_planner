
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Master Plan Visualization</title>
  <script src="d3.min.js" onerror="handleScriptError()"></script>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 0; overflow: hidden; background: #f8f9fa; }
    #container { width: 100vw; height: 100vh; display: flex; }
    #viz { flex-grow: 1; height: 100%; position: relative; }
    #sidebar { width: 400px; height: 100vh; background: white; border-left: 1px solid #ddd; padding: 20px; box-sizing: border-box; overflow-y: auto; display: none; box-shadow: -2px 0 5px rgba(0,0,0,0.05); z-index: 10; transform: translateX(0); transition: transform 0.3s ease; }
    
    .node circle { fill: #fff; stroke: steelblue; stroke-width: 2px; cursor: pointer; transition: all 0.3s; }
    .node circle:hover { stroke-width: 4px; }
    .node text { font: 12px sans-serif; cursor: pointer; text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff; }
    
    .link { fill: none; stroke: #ccc; stroke-width: 1.5px; transition: all 0.5s; stroke-opacity: 0.6; }

    .dep-link { fill: none; stroke: #e74c3c; stroke-width: 1.5px; stroke-dasharray: 4; marker-end: url(#arrowhead); opacity: 0.6; }
    .dep-link:hover { opacity: 1.0; stroke-width: 2.5px; }

    /* Metadata Colors */
    .status-done { stroke: #2ecc71 !important; fill: #e8f8f5; }
    .status-active, .status-in-progress { stroke: #3498db !important; fill: #ebf5fb; }
    .status-todo { stroke: #bdc3c7 !important; fill: #fbfcfc; }
    .status-blocked { stroke: #e74c3c !important; fill: #fdedec; }
    
    h2 { margin-top: 0; font-size: 1.5em; color: #2c3e50; }
    .meta-tag { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 0.85em; margin-right: 5px; margin-bottom: 5px; color: white; font-weight: 500;}
    
    .tag-todo { background: #95a5a6; }
    .tag-active, .tag-in-progress { background: #3498db; }
    .tag-done { background: #2ecc71; }
    .tag-blocked { background: #e74c3c; }
    .tag-default { background: #7f8c8d; }

    pre { background: #f4f6f7; padding: 10px; border-radius: 4px; overflow-x: auto; font-size: 0.9em; white-space: pre-wrap; }
    .content-block { line-height: 1.6; color: #34495e; font-size: 0.95em; }

    .control-panel { position: absolute; top: 20px; left: 20px; background: rgba(255, 255, 255, 0.9); padding: 10px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    button { background: #3498db; color: white; border: none; padding: 5px 12px; border-radius: 4px; cursor: pointer; font-size: 13px; margin-right: 5px; }
    button:hover { background: #2980b9; }

    #debug-log { position: absolute; bottom: 10px; left: 10px; font-family: monospace; font-size: 10px; color: #aaa; pointer-events: none; z-index: 100; max-height: 200px; overflow: hidden; }
    #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1.5em; color: #666; background: rgba(255,255,255,0.8); padding: 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
  </style>
</head>
<body>

<div id="container">
  <div id="viz">
    <div id="loading">Initializing...</div>
    <div id="debug-log"></div>
    <svg width="100%" height="100%"></svg>
    <div class="control-panel">
        <button onclick="expandAll()">Expand All</button>
        <button onclick="collapseAll()">Collapse All</button>
        <button onclick="resetZoom()">Reset Zoom</button>
        <button onclick="toggleDeps()">Toggle Dependencies</button>
    </div>
  </div>
  <div id="sidebar">
    <div id="details">
        <h2 style="color: #bbb;">Select a node...</h2>
    </div>
  </div>
</div>

<script>
// Global Variables - Must be declared before use
let root, svg, g, zoom, tree;
let i = 0;
let duration = 500;
let parsedData = null;
let showDependencies = true;

function log(msg) {
    console.log(msg);
    const logDiv = document.getElementById('debug-log');
    if (logDiv) logDiv.innerHTML += msg + "<br>";
}

function handleScriptError() {
    log("ERROR: Failed to load D3.js. Check if d3.min.js exists in the same folder.");
    document.getElementById('loading').innerHTML = "Error: D3.js missing.<br><small>Ensure d3.min.js is in the folder.</small>";
}

// Base64 Decode
function decodeData(enc) {
    try {
        log("Decoding data...");
        const jsonStr = new TextDecoder().decode(Uint8Array.from(atob(enc), c => c.charCodeAt(0)));
        log("Data decoded. Length: " + jsonStr.length);
        return JSON.parse(jsonStr);
    } catch(e) {
        log("Decoding error: " + e.message);
        document.getElementById('loading').innerText = "Error decoding data";
        return null;
    }
}

// Data Injection
try {
    const rawData = "eyJ0cmVlIjogeyJ0aXRsZSI6ICJDZW50cmFsIENvbXBhbnkgTWFzdGVyIFBsYW4iLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJhY3RpdmUiLCAidHlwZSI6ICJwbGFuIiwgImlkIjogIm1hc3Rlcl9wbGFuIiwgIm93bmVyIjogImNlbnRyYWwtcGxhbm5lciIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QxMzo0NzowNyswMTowMCJ9LCAiY29udGVudCI6ICJUaGlzIGRvY3VtZW50IHNlcnZlcyBhcyB0aGUgY2VudHJhbCBhZ2dyZWdhdGlvbiBwb2ludCBmb3IgdGhlIGNvbXBhbnkncyBzdHJhdGVnaWMgaW5pdGlhdGl2ZXMuIEl0IGN1cnJlbnRseSBmb2N1c2VzIG9uIHRoZSBmbGFnc2hpcCAqKkludGVsbGlnZW50IENvbnRyb2wgJiBBbmFseXNpcyBQbGF0Zm9ybSoqLiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIkludGVsbGlnZW50IENvbnRyb2wgJiBBbmFseXNpcyBQbGF0Zm9ybSAoU2FhUykiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJhY3RpdmUiLCAidHlwZSI6ICJwbGFuIiwgImlkIjogInByb2R1Y3Quc2FhcyIsICJvd25lciI6ICJwcm9kdWN0LW1hbmFnZXIiLCAicHJpb3JpdHkiOiAiY3JpdGljYWwiLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjNUMTM6NDc6MDcrMDE6MDAifSwgImNvbnRlbnQiOiAiQSBkdWFsLWVuZ2luZSBBSSBzeXN0ZW0gZnVuY3Rpb25pbmcgYXMgYm90aCBhICoqQnVzaW5lc3MgQW5hbHlzdCoqIGFuZCBhbiAqKkF1dG9ub21vdXMgT3BlcmF0b3IqKiBmb3IgU01CcyBhbmQgaW5kdXN0cmlhbCBjbGllbnRzLiBJdCBjb21iaW5lcyBMTE0gcmVhc29uaW5nIChBbmFseXNpcykgd2l0aCBSTCBjb250cm9sIChPcHRpbWl6YXRpb24pLiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIkV4ZWN1dGl2ZSBTdW1tYXJ5IiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiZG9uZSIsICJ0eXBlIjogImNvbnRleHQiLCAiaWQiOiAicHJvZHVjdC5zYWFzLnN1bW1hcnkiLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjNUMTM6NDc6MDcrMDE6MDAifSwgImNvbnRlbnQiOiAiKipUaGUgVmlzaW9uKio6IFRyYW5zZm9ybSBkYXRhIGludG8gZGVjaXNpb24uIFRoZSBwbGF0Zm9ybSBhbGxvd3MgY2xpZW50cyB0byBcImNoYXQgd2l0aCBkYXRhXCIgYW5kIG9wdGltaXplIG9wZXJhdGlvbnMgdXNpbmcgYSBjb252ZXJzYXRpb25hbCBpbnRlcmZhY2UgYmFja2VkIGJ5IHJpZ29yb3VzIGV4ZWN1dGlvbiBlbmdpbmVzLlxuLSAgICoqQW5hbHlzdCoqOiBcIldoeSBpcyB0aGlzIGhhcHBlbmluZz9cIiAtPiBDb2RlIEludGVycHJldGVyIGFuYWx5c2lzLlxuLSAgICoqQ29udHJvbGxlcioqOiBcIk9wdGltaXplIGZvciBlZmZpY2llbmN5LlwiIC0+IFJMIEFnZW50IGV4ZWN1dGlvbi4iLCAiY2hpbGRyZW4iOiBbXX0sIHsidGl0bGUiOiAiVmFsdWUgUHJvcG9zaXRpb25zIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAiY29udGV4dCIsICJpZCI6ICJwcm9kdWN0LnNhYXMudmFsdWVfcHJvcCIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QxMzo0NzowNyswMTowMCJ9LCAiY29udGVudCI6ICIxLiAgKipSZXRhaWwvU01CcyAoVGhlIEFnZW50aWMgQW5hbHlzdCkqKjogRGVtb2NyYXRpemVkIERhdGEgU2NpZW5jZS4gSW5zdGFudCBhbnN3ZXJzIHRvIGNvbGxvcXVpYWwgcXVlc3Rpb25zIHdpdGhvdXQgYSBkYXRhIHRlYW0uXG4yLiAgKipMb2dpc3RpY3MgKEludmVudG9yeSBBdXRvLVBpbG90KSoqOiBDYXNoIGZsb3cgb3B0aW1pemF0aW9uLiBBdXRvbWF0ZWQgcmVvcmRlcmluZyB1c2luZyBSTCBhZ2VudHMgdG8gc29sdmUgdGhlIE5ld3N2ZW5kb3IgcHJvYmxlbSAobWluaW1pemUgaG9sZGluZyBjb3N0cyB2cy4gcHJldmVudCBzdG9ja291dHMpLiIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJUZWNobmljYWwgQXJjaGl0ZWN0dXJlIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAicGxhbiIsICJpZCI6ICJwcm9kdWN0LnNhYXMuYXJjaCIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QxMzo0NzowNyswMTowMCJ9LCAiY29udGVudCI6ICJUaGUgc3lzdGVtIHNlcGFyYXRlcyBBbmFseXRpY2FsIFF1ZXJpZXMgKENvZGUgRXhlY3V0aW9uKSBmcm9tIENvbnRyb2wgVGFza3MgKE1vZGVsIEluZmVyZW5jZSkuIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiQ29yZSBDb21wb25lbnRzIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAiY29udGV4dCIsICJpZCI6ICJwcm9kdWN0LnNhYXMuYXJjaC5jb21wb25lbnRzIiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTIzVDEzOjQ3OjA3KzAxOjAwIn0sICJjb250ZW50IjogIi0gICAqKk9yY2hlc3RyYXRvciAoVGhlIEJyYWluKSoqOiBWZXJ0ZXggQUkgKEdlbWluaSBQcm8pLiBSb3V0ZXMgcmVxdWVzdHMgdG8gQW5hbHlzaXMgb3IgQ29udHJvbC5cbi0gICAqKkFuYWx5c2lzIFNhbmRib3gqKjogRXBoZW1lcmFsIERvY2tlciBDb250YWluZXJzIChFMkIgLyBWZXJ0ZXggRXh0ZW5zaW9ucykgZm9yIHNhZmUgY29kZSBleGVjdXRpb24uIEludGVybmFsIGFjY2VzcyBvbmx5LlxuLSAgICoqQ29udHJvbCBGYWN0b3J5Kio6IFZlcnRleCBBSSBDdXN0b20gVHJhaW5pbmcgKyBSYXkvU3RhYmxlIEJhc2VsaW5lczMgZm9yIHRyYWluaW5nIFJMIHBvbGljaWVzLiIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJJbmZvcm1hdGlvbiBGbG93IChDb250cm9sIExvb3ApIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAiY29udGV4dCIsICJpZCI6ICJwcm9kdWN0LnNhYXMuYXJjaC5mbG93IiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTIzVDEzOjQ3OjA3KzAxOjAwIn0sICJjb250ZW50IjogIjEuICAqKklucHV0Kio6IENsaWVudCBzdHJlYW1zIHRlbGVtZXRyeSAoJHNfdCQpIHRvIGAvdjEvdGVsZW1ldHJ5YC5cbjIuICAqKkluZmVyZW5jZSoqOiBQb2xpY3kgbmV0d29yayAkXFxwaShzX3QpJCBvciBXb3JsZCBNb2RlbCAkXFxoYXR7Zn0ocywgYSkkIHNlbGVjdHMgYWN0aW9uLlxuMy4gICoqQWN0aW9uKio6IEFQSSByZXR1cm5zIGFjdGlvbiAkYV90JC5cbjQuICAqKkZlZWRiYWNrKio6IENsaWVudCBzZW5kcyByZXdhcmQvbmV3IHN0YXRlIGR1cmluZyBvZmZsaW5lIHJldHJhaW5pbmcuIiwgImNoaWxkcmVuIjogW119XX0sIHsidGl0bGUiOiAiSW1wbGVtZW50YXRpb24gUm9hZG1hcCIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImFjdGl2ZSIsICJ0eXBlIjogInBsYW4iLCAiaWQiOiAicHJvZHVjdC5zYWFzLnJvYWRtYXAiLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjNUMTM6NDc6MDcrMDE6MDAifSwgImNvbnRlbnQiOiAiIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiUGhhc2UgMTogVW5pZmllZCBEYXRhIEFQSSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogInByb2R1Y3Quc2Fhcy5yb2FkbWFwLnBoYXNlMSIsICJlc3RpbWF0ZSI6ICIydyIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QxMzo0NzowNyswMTowMCJ9LCAiY29udGVudCI6ICIqKkdvYWwqKjogU2luZ2xlIEFQSSBzdXJmYWNlIGZvciB1cGxvYWRpbmcgYm90aCBFdmVudCBkYXRhIChSZWNzKSBhbmQgVGVsZW1ldHJ5IChDb250cm9sKS5cbioqRGVsaXZlcmFibGVzKio6XG4tICAgUm9idXN0IEluZ2VzdGlvbiBMYXllci5cbi0gICBTY2hlbWEgdmFsaWRhdGlvbiB2aWEgUHlkYW50aWMuXG4tICAgRW5kcG9pbnRzOiBgL3YxL2V2ZW50c2AgKHRvIEJpZ1F1ZXJ5KSBhbmQgYC92MS90ZWxlbWV0cnlgICh0byBCaWdRdWVyeS9CaWdUYWJsZSkuIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiQmFzaWMgQ2hhdGJvdCBJbnRlcmZhY2UiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJwcm9kdWN0LnNhYXMucm9hZG1hcC5waGFzZTEuY2hhdGJvdCIsICJlc3RpbWF0ZSI6ICIxdyIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QxNToxMTo1NSswMTowMCJ9LCAiY29udGVudCI6ICJDcmVhdGUgYSBiYXNpYyBjaGF0IGludGVyZmFjZSB0byBpbnRlcmFjdCB3aXRoIHRoZSBMTE1zLiBUaGlzIGludm9sdmVzIHNldHRpbmcgdXAgYSBzaW1wbGUgUmVhY3QgVUksIGVzdGFibGlzaGluZyB0aGUgQVBJIGNvbm5lY3Rpb24gdG8gVmVydGV4IEFJIC8gT3BlbkFJLCBhbmQgaW1wbGVtZW50aW5nIGJhc2ljIGNvc3QgdHJhY2tpbmcgcGVyIHNlc3Npb24uIiwgImNoaWxkcmVuIjogW119LCB7InRpdGxlIjogIkNsaWVudCBEYXRhIFdhcmVob3VzZSBBcHAiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJwcm9kdWN0LnNhYXMucm9hZG1hcC5waGFzZTEud2FyZWhvdXNlX2FwcCIsICJibG9ja2VkX2J5IjogWyJwcm9kdWN0LnNhYXMucm9hZG1hcC5waGFzZTEuY2hhdGJvdCJdLCAiZXN0aW1hdGUiOiAiMXciLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjNUMTQ6NDg6NTgrMDE6MDAifSwgImNvbnRlbnQiOiAiRGV2ZWxvcCBhIGRvd25sb2FkYWJsZSBhcHBsaWNhdGlvbiBmb3IgY2xpZW50cyB0byBpbnN0YWxsLCBlbmFibGluZyBzdHJlYW1saW5lZCBkYXRhIHN0cmVhbWluZyB0byBvdXIgY2VudHJhbCB3YXJlaG91c2UuIiwgImNoaWxkcmVuIjogW119LCB7InRpdGxlIjogIkRhdGEgU3RyZWFtIENvbnRyb2xsZXJzICYgUGxhbm5lcnMiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJwcm9kdWN0LnNhYXMucm9hZG1hcC5waGFzZTEuY29udHJvbGxlcnMiLCAiYmxvY2tlZF9ieSI6IFsicHJvZHVjdC5zYWFzLnJvYWRtYXAucGhhc2UxLndhcmVob3VzZV9hcHAiXSwgImVzdGltYXRlIjogIjF3IiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTIzVDE0OjQ4OjU4KzAxOjAwIn0sICJjb250ZW50IjogIlNldCB1cCBpbml0aWFsIGNvbnRyb2xsZXJzIGFuZCBwbGFubmVycyB0byBwcm9jZXNzIHRoZSBpbmNvbWluZyBkYXRhIHN0cmVhbSBmcm9tIHRoZSBjbGllbnQgYXBwLiIsICJjaGlsZHJlbiI6IFtdfV19LCB7InRpdGxlIjogIlBoYXNlIDI6IFRoZSBBZ2VudGljIEFuYWx5c3QgKEdlbmVyYXRpdmUgVUkpIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAicHJvZHVjdC5zYWFzLnJvYWRtYXAucGhhc2UyIiwgImJsb2NrZWRfYnkiOiBbInByb2R1Y3Quc2Fhcy5yb2FkbWFwLnBoYXNlMSJdLCAiZXN0aW1hdGUiOiAiNHciLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjNUMTM6NDc6MDcrMDE6MDAifSwgImNvbnRlbnQiOiAiKipHb2FsKio6IEVuYWJsZSBcIkNoYXQgd2l0aCBEYXRhXCIgd2l0aCBpbnRlcmFjdGl2ZSBjb21wb25lbnRzIChSZWFjdCkuXG4qKkFjdGlvbnMqKjpcbi0gICAqKkZyb250ZW5kKio6IEJ1aWxkIENvbXBvbmVudCBSZWdpc3RyeSAoQ2hhcnRzLCBUYWJsZXMsIFNsaWRlcnMpLlxuLSAgICoqQmFja2VuZCoqOiBJbXBsZW1lbnQgdG9vbF9jYWxsIGxvZ2ljIGluIFZlcnRleCBBSSB0byBtYXAgcmVxdWVzdHMgdG8gVUkgSlNPTiBwYXlsb2Fkcy5cbi0gICAqKlByb21wdGluZyoqOiBUcmFpbiBtb2RlbCB0byBwcmVmZXIgcmV0dXJuaW5nIFVJIGNvbXBvbmVudHMgb3ZlciBkZW5zZSB0ZXh0LiIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJQaGFzZSAzOiBUaGUgQ29udHJvbCBMb29wIChNVlApIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAicHJvZHVjdC5zYWFzLnJvYWRtYXAucGhhc2UzIiwgImJsb2NrZWRfYnkiOiBbInByb2R1Y3Quc2Fhcy5yb2FkbWFwLnBoYXNlMiJdLCAiZXN0aW1hdGUiOiAiNnciLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjNUMTM6NDc6MDcrMDE6MDAifSwgImNvbnRlbnQiOiAiKipHb2FsKio6IEVuZC10by1lbmQgUkwgcGlwZWxpbmUuXG4qKkFjdGlvbnMqKjpcbi0gICBJbXBsZW1lbnQgc3RhbmRhcmQgYWxnb3JpdGhtIChlLmcuLCBQUE8pIG9uIFZlcnRleCBDdXN0b20gSm9icy5cbi0gICBUcmFpbiBvbiBhIHNpbXBsZSBpbnZlbnRvcnkgbWFuYWdlbWVudCBwcm9ibGVtIChFbnZpcm9ubWVudCkuIiwgImNoaWxkcmVuIjogW119XX0sIHsidGl0bGUiOiAiU2VjdXJpdHkgJiBTYWZldHkgQ2hlY2tzIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAiZ3VpZGVsaW5lIiwgImlkIjogInByb2R1Y3Quc2Fhcy5zZWN1cml0eSIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QxMzo0NzowNyswMTowMCJ9LCAiY29udGVudCI6ICItICAgKipJbmRpcmVjdCBFeGVjdXRpb24qKjogQ2xpZW50cyBvbmx5IHN1Ym1pdCBuYXR1cmFsIGxhbmd1YWdlLCBuZXZlciBjb2RlLlxuLSAgICoqUmVwb3NpdG9yeSBTY29waW5nKio6IEdlbmVyYXRlZCBjb2RlIGNhbiBvbmx5IGltcG9ydCB3aGl0ZWxpc3RlZCBsaWJyYXJpZXMgKGBwYW5kYXNgLCBgbnVtcHlgLCBgbGliX2FuYWx5c2lzYCkuIE5vIGBvc2Agb3IgYHN5c2AuXG4tICAgKipTaW11bGF0aW9uIElzb2xhdGlvbioqOiBVc2VyLXByb3ZpZGVkIGxvZ2ljIHJ1bnMgaW4gYGdWaXNvcmAgc2FuZGJveGVzLlxuLSAgICoqQWN0aW9uIEJvdW5kaW5nKio6IERldGVybWluaXN0aWMgbG9naWMgbGF5ZXIgdmFsaWRhdGVzIGFjdGlvbnMgYWdhaW5zdCBzYWZldHkgY29uc3RyYWludHMgKGUuZy4sIGBNQVhfT1JERVJfTElNSVRgKSBiZWZvcmUgZXhlY3V0aW9uLiIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJSZXNlYXJjaCBEaXJlY3Rpb25zIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAicGxhbiIsICJpZCI6ICJwcm9kdWN0LnNhYXMucmVzZWFyY2giLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjNUMTM6NDc6MDcrMDE6MDAifSwgImNvbnRlbnQiOiAiLSAgICoqTUJSTCAoRHJlYW1lclYzKSoqOiBMZWFybmluZyBXb3JsZCBNb2RlbHMgZnJvbSB0ZWxlbWV0cnkgdG8gc2ltdWxhdGUgZW52aXJvbm1lbnRzLlxuLSAgICoqU2FmZSBSTCoqOiBDb25zdHJhaW5lZCBNRFBzIChMYWdyYW5naWFuIFJlbGF4YXRpb24pIHRvIGVuc3VyZSBzYWZldHkgZHVyaW5nIGV4cGxvcmF0aW9uLlxuLSAgICoqUmVmbGV4aW9uKio6IEFnZW50cyB0aGF0IGFuYWx5emUgdGhlaXIgb3duIHRyYWNlYmFja3MgdG8gaXRlcmF0aXZlbHkgZml4IGNvZGUuIiwgImNoaWxkcmVuIjogW119XX0sIHsidGl0bGUiOiAiUmVwb3NpdG9yeSBNYWludGVuYW5jZSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImFjdGl2ZSIsICJ0eXBlIjogInJlY3VycmluZyIsICJpZCI6ICJtZXRhLm1haW50ZW5hbmNlIiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTIzVDEzOjQ3OjA3KzAxOjAwIn0sICJjb250ZW50IjogIlRvIHN5bmMgdGhpcyBwbGFuIHdpdGggb3RoZXIgcmVwb3NpdG9yaWVzLCBydW46XG5gcHl0aG9uMyBtYW5hZ2VyL3VwZGF0ZV9tYXN0ZXJfcGxhbi5weSAtLWFsbGAiLCAiY2hpbGRyZW4iOiBbXX1dfSwgImRlcGVuZGVuY2llcyI6IFt7InNvdXJjZSI6ICJwcm9kdWN0LnNhYXMucm9hZG1hcC5waGFzZTEuY2hhdGJvdCIsICJ0YXJnZXQiOiAicHJvZHVjdC5zYWFzLnJvYWRtYXAucGhhc2UxLndhcmVob3VzZV9hcHAifSwgeyJzb3VyY2UiOiAicHJvZHVjdC5zYWFzLnJvYWRtYXAucGhhc2UxLndhcmVob3VzZV9hcHAiLCAidGFyZ2V0IjogInByb2R1Y3Quc2Fhcy5yb2FkbWFwLnBoYXNlMS5jb250cm9sbGVycyJ9LCB7InNvdXJjZSI6ICJwcm9kdWN0LnNhYXMucm9hZG1hcC5waGFzZTEiLCAidGFyZ2V0IjogInByb2R1Y3Quc2Fhcy5yb2FkbWFwLnBoYXNlMiJ9LCB7InNvdXJjZSI6ICJwcm9kdWN0LnNhYXMucm9hZG1hcC5waGFzZTIiLCAidGFyZ2V0IjogInByb2R1Y3Quc2Fhcy5yb2FkbWFwLnBoYXNlMyJ9XX0=";
    if (rawData.startsWith("__DATA")) {
        log("Error: Placeholder not replaced.");
    } else {
        const data = decodeData(rawData);
        if (data && typeof d3 !== 'undefined') {
            log("D3 loaded. Version: " + d3.version);
            document.getElementById('loading').style.display = 'none';
            parsedData = data.tree ? data : { tree: data, dependencies: [] }; // Handle legacy format if needed
            initViz(parsedData);
        } else {
            if (typeof d3 === 'undefined') {
                handleScriptError();
            } else {
                log("Error: Data is null.");
            }
        }
    }
} catch (globalErr) {
    log("Global Error: " + globalErr.message);
}

function initViz(fullData) {
    log("Initializing Visualization...");
    try {
        const width = window.innerWidth;
        const height = window.innerHeight;

        svg = d3.select("svg");
        
        // Clear previous if any
        svg.selectAll("*").remove();
        
        // Defs for arrows
        const defs = svg.append("defs");
        defs.append("marker")
            .attr("id", "arrowhead")
            .attr("refX", 10) /* adjust based on node radius */
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-2.5 L6,0 L0,2.5")
            .style("fill", "#e74c3c");

        g = svg.append("g");

        zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on("zoom", (event) => g.attr("transform", event.transform));

        svg.call(zoom);

        // Define tree layout params
        // nodeSize depends on orientation. 
        // For standard top-down: [width, height]
        // For left-right (projecting y as x): [height, width]
        tree = d3.tree().nodeSize([40, 300]); 

        root = d3.hierarchy(fullData.tree, d => d.children);
        root.x0 = 0;
        root.y0 = 0;

        // Check if root has children
        if (!root.children) {
            log("Warning: Root has no children.");
        } else {
            log("Root children count: " + root.children.length);
        }

        // Collapse
        if(root.children) {
            root.children.forEach(collapseRecursive);
        }

        update(root);
        
        // Initial center
        const initialTransform = d3.zoomIdentity.translate(100, height / 2).scale(1);
        svg.call(zoom.transform, initialTransform);
        
        log("Viz Initialized.");

    } catch (vizErr) {
        log("Viz Error: " + vizErr.message);
        log(vizErr.stack);
    }
}

function collapseRecursive(d) {
  if(d.children) {
    d._children = d.children;
    d.children.forEach(collapseRecursive);
    d.children = null;
  }
}

function expandAll() {
    function recurse(d) {
        if (d._children) {
            d.children = d._children;
            d._children = null;
        }
        if (d.children) d.children.forEach(recurse);
    }
    recurse(root);
    update(root);
}

function collapseAll() {
    if (root.children) root.children.forEach(collapseRecursive);
    update(root);
}

function resetZoom() {
    const height = window.innerHeight;
    svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity.translate(100, height/2).scale(1));
}

function toggleDeps() {
    showDependencies = !showDependencies;
    update(root);
}

function update(source) {
  const treeData = tree(root);

  // Compute the new tree layout.
  const nodes = treeData.descendants();
  const links = treeData.links();

  // Normalize for left-right tree
  // Swap x and y for horizontal layout
  nodes.forEach(d => { d.y = d.depth * 300; });

  // Node Map for calculating dependencies
  const nodeMap = new Map();
  nodes.forEach(d => {
      // Key can be ID or Node Title (fallback)
      if (d.data.metadata && d.data.metadata.id) {
          nodeMap.set(d.data.metadata.id, d);
      }
      // Also map by title for redundancy if needed, but ID is preferred
  });


  // ****************** Links (Hierarchy) ***************************
  const link = g.selectAll('path.link')
      .data(links, d => d.target.id);

  const linkEnter = link.enter().insert('path', "g")
      .attr("class", "link")
      .attr('d', d => {
        const o = {x: source.x0, y: source.y0};
        return diagonal(o, o);
      });

  const linkUpdate = linkEnter.merge(link);

  linkUpdate.transition()
      .duration(duration)
      .attr('d', d => diagonal(d.source, d.target));

  link.exit().transition()
      .duration(duration)
      .attr('d', d => {
        const o = {x: source.x, y: source.y};
        return diagonal(o, o);
      })
      .remove();

  // ****************** Dependency Links (Explicit) ***************************
  // Calculate active dependencies based on current visible nodes
  let depLinksData = [];
  if (showDependencies && parsedData.dependencies) {
      parsedData.dependencies.forEach(dep => {
          const sourceNode = nodeMap.get(dep.source);
          const targetNode = nodeMap.get(dep.target);
          
          if (sourceNode && targetNode) {
              depLinksData.push({source: sourceNode, target: targetNode});
          }
      });
  }

  const depLink = g.selectAll('path.dep-link')
      .data(depLinksData, d => d.source.id + "-" + d.target.id);

  const depLinkEnter = depLink.enter().append('path')
      .attr("class", "dep-link")
      .attr('d', d => {
           // Start from wherever the source is currently (animation) -> usually nice to just fade in or pop in
           // For simplicity, we calculate the curve immediately or use the source position
           return dependencyPath(d.source, d.target);
      })
      .style("opacity", 0);

  depLinkEnter.transition().duration(duration).style("opacity", 0.6);

  depLink.transition().duration(duration)
      .attr('d', d => dependencyPath(d.source, d.target))
      .style("opacity", 0.6);

  depLink.exit().transition().duration(duration).style("opacity", 0).remove();


  // ****************** Nodes ***************************
  const node = g.selectAll('g.node')
      .data(nodes, d => d.id || (d.id = ++i));

  const nodeEnter = node.enter().append('g')
      .attr('class', 'node')
      .attr("transform", d => "translate(" + source.y0 + "," + source.x0 + ")")
      .on('click', click);

  nodeEnter.append('circle')
      .attr('r', 1e-6)
      .attr('class', d => {
          const status = (d.data.metadata && d.data.metadata.status) || 'default';
          return `status-${status.replace(' ', '-')}`;
      });

  nodeEnter.append('text')
      .attr("dy", ".35em")
      .attr("x", d => d.children || d._children ? -13 : 13)
      .attr("text-anchor", d => d.children || d._children ? "end" : "start")
      .text(d => {
          let title = d.data.title;
          return title.length > 30 ? title.substring(0, 30) + '...' : title;
      })
      .style('fill-opacity', 1e-6);

  const nodeUpdate = nodeEnter.merge(node);

  nodeUpdate.transition()
      .duration(duration)
      .attr("transform", d => "translate(" + d.y + "," + d.x + ")");

  nodeUpdate.select('circle')
      .attr('r', 8)
      .style("fill", d => d._children ? "#fff" : "") 
      .attr('class', d => `status-${((d.data.metadata && d.data.metadata.status) || 'default').replace(' ', '-')}`);

  nodeUpdate.select('text').style("fill-opacity", 1);

  const nodeExit = node.exit().transition()
      .duration(duration)
      .attr("transform", d => "translate(" + source.y + "," + source.x + ")")
      .remove();

  nodeExit.select('circle').attr('r', 1e-6);
  nodeExit.select('text').style('fill-opacity', 1e-6);


  nodes.forEach(d => {
    d.x0 = d.x;
    d.y0 = d.y;
  });

  function diagonal(s, d) {
    return `M ${s.y} ${s.x}
            C ${(s.y + d.y) / 2} ${s.x},
              ${(s.y + d.y) / 2} ${d.x},
              ${d.y} ${d.x}`;
  }

  function dependencyPath(s, t) {
      // Custom path for dependencies - larger arc to avoid hierarchy lines?
      // Or just a straightish Bezier
      const dx = t.y - s.y;
      const dy = t.x - s.x;
      const dr = Math.sqrt(dx * dx + dy * dy) * 1.5; // Controls curvature
      
      // Arc path
      return `M${s.y},${s.x}A${dr},${dr} 0 0,1 ${t.y},${t.x}`;
  }

  function click(event, d) {
    showDetails(d.data);
    if (d.children) {
        d._children = d.children;
        d.children = null;
    } else {
        d.children = d._children;
        d._children = null;
    }
    update(d);
  }
}

function showDetails(data) {
    const sidebar = document.getElementById('sidebar');
    const container = document.getElementById('details');
    sidebar.style.display = 'block';

    const status = (data.metadata.status || 'todo').replace(' ', '-');
    
    let metaHtml = '';
    for (const [key, value] of Object.entries(data.metadata)) {
        if (key === 'status') continue;
        metaHtml += `<div><strong>${key}:</strong> ${JSON.stringify(value).replace(/"/g, '')}</div>`;
    }

    container.innerHTML = `
        <span class="meta-tag tag-${status}">${status.toUpperCase().replace('-', ' ')}</span>
        <h2>${data.title}</h2>
        <div style="margin-bottom: 20px; font-size: 0.9em; color: #7f8c8d;">
            ${metaHtml}
        </div>
        <hr style="border: 0; border-top: 1px solid #eee;"/>
        <div class="content-block">
            <pre style="background:none; padding:0; white-space: pre-wrap; font-family: inherit;">${data.content || "No content."}</pre>
        </div>
    `;
}
</script>
</body>
</html>
