
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Master Plan Visualization</title>
  <script src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js"></script>
  <script>
    if (typeof d3 === 'undefined') {
        document.write('<script src="d3.min.js" onerror="handleScriptError()"><\/script>');
    }
  </script>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 0; overflow: hidden; background: #f8f9fa; }
    #container { width: 100vw; height: 100vh; display: flex; }
    #viz { flex-grow: 1; height: 100%; position: relative; }
    #sidebar { width: 400px; height: 100vh; background: white; border-left: 1px solid #ddd; padding: 20px; box-sizing: border-box; overflow-y: auto; display: none; box-shadow: -2px 0 5px rgba(0,0,0,0.05); z-index: 10; transform: translateX(0); transition: transform 0.3s ease; }
    
    .node circle { fill: #fff; stroke: steelblue; stroke-width: 2px; cursor: pointer; transition: all 0.3s; }
    .node circle:hover { stroke-width: 4px; }
    .node text { font: 12px sans-serif; cursor: pointer; text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff; }
    
    .link { fill: none; stroke: #ccc; stroke-width: 1.5px; transition: all 0.5s; stroke-opacity: 0.6; }

    .dep-link { fill: none; stroke: #e74c3c; stroke-width: 1.5px; stroke-dasharray: 4; marker-end: url(#arrowhead); opacity: 0.6; }
    .dep-link:hover { opacity: 1.0; stroke-width: 2.5px; }

    /* Metadata Colors */
    .status-done { stroke: #2ecc71 !important; fill: #e8f8f5; }
    .status-active, .status-in-progress { stroke: #3498db !important; fill: #ebf5fb; }
    .status-todo { stroke: #bdc3c7 !important; fill: #fbfcfc; }
    .status-blocked { stroke: #e74c3c !important; fill: #fdedec; }
    
    h2 { margin-top: 0; font-size: 1.5em; color: #2c3e50; }
    .meta-tag { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 0.85em; margin-right: 5px; margin-bottom: 5px; color: white; font-weight: 500;}
    
    .tag-todo { background: #95a5a6; }
    .tag-active, .tag-in-progress { background: #3498db; }
    .tag-done { background: #2ecc71; }
    .tag-blocked { background: #e74c3c; }
    .tag-default { background: #7f8c8d; }

    pre { background: #f4f6f7; padding: 10px; border-radius: 4px; overflow-x: auto; font-size: 0.9em; white-space: pre-wrap; }
    .content-block { line-height: 1.6; color: #34495e; font-size: 0.95em; }

    .control-panel { position: absolute; top: 20px; left: 20px; background: rgba(255, 255, 255, 0.9); padding: 10px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    button { background: #3498db; color: white; border: none; padding: 5px 12px; border-radius: 4px; cursor: pointer; font-size: 13px; margin-right: 5px; }
    button:hover { background: #2980b9; }

    #debug-log { position: absolute; bottom: 10px; left: 10px; font-family: monospace; font-size: 10px; color: #aaa; pointer-events: none; z-index: 100; max-height: 200px; overflow: hidden; }
    #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1.5em; color: #666; background: rgba(255,255,255,0.8); padding: 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
  </style>
</head>
<body>

<div id="container">
  <div id="viz">
    <div id="loading">Initializing...</div>
    <div id="debug-log"></div>
    <svg width="100%" height="100%"></svg>
    <div class="control-panel">
        <button onclick="expandAll()">Expand All</button>
        <button onclick="collapseAll()">Collapse All</button>
        <button onclick="resetZoom()">Reset Zoom</button>
        <button onclick="toggleDeps()">Toggle Dependencies</button>
    </div>
  </div>
  <div id="sidebar">
    <div id="details">
        <h2 style="color: #bbb;">Select a node...</h2>
    </div>
  </div>
</div>

<script>
// Global Variables - Must be declared before use
let root, svg, g, zoom, tree;
let i = 0;
let duration = 500;
let parsedData = null;
let showDependencies = true;

function log(msg) {
    console.log(msg);
    const logDiv = document.getElementById('debug-log');
    if (logDiv) logDiv.innerHTML += msg + "<br>";
}

function handleScriptError() {
    log("ERROR: Failed to load D3.js. Check if d3.min.js exists in the same folder.");
    document.getElementById('loading').innerHTML = "Error: D3.js missing.<br><small>Ensure d3.min.js is in the folder.</small>";
}

// Base64 Decode
function decodeData(enc) {
    try {
        log("Decoding data...");
        const jsonStr = new TextDecoder().decode(Uint8Array.from(atob(enc), c => c.charCodeAt(0)));
        log("Data decoded. Length: " + jsonStr.length);
        return JSON.parse(jsonStr);
    } catch(e) {
        log("Decoding error: " + e.message);
        document.getElementById('loading').innerText = "Error decoding data";
        return null;
    }
}

// Data Injection
try {
    const rawData = "eyJ0cmVlIjogeyJ0aXRsZSI6ICJNYXN0ZXIgUGxhbjogSW50ZWxsaWdlbnQgQ29udHJvbCBTYWFTIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAicGxhbiIsICJpZCI6ICJtYXN0ZXJfcGxhbi5zYWFzIiwgIm93bmVyIjogInByb2R1Y3QtbWFuYWdlciIsICJwcmlvcml0eSI6ICJjcml0aWNhbCIsICJjb250ZXh0X2RlcGVuZGVuY2llcyI6IHsibWFuYWdlciI6ICJNQU5BR0VSX0FHRU5ULm1kIiwgImNvbnZlbnRpb25zIjogIi4uLy4uL01EX0NPTlZFTlRJT05TLm1kIn0sICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QxNToxNDoyNSswMTowMCJ9LCAiY29udGVudCI6ICJUaGlzIGRvY3VtZW50IHNlcnZlcyBhcyB0aGUgY2VudHJhbCBzdHJhdGVnaWMgcGxhbiBmb3IgdGhlICoqSW50ZWxsaWdlbnQgQ29udHJvbCAmIEFuYWx5c2lzIFBsYXRmb3JtKiouIEl0IGlzIGEgZHVhbC1lbmdpbmUgQUkgc3lzdGVtIGZ1bmN0aW9uaW5nIGFzIGJvdGggYSAqKkJ1c2luZXNzIEFuYWx5c3QqKiBhbmQgYW4gKipBdXRvbm9tb3VzIE9wZXJhdG9yKiogZm9yIFNNQnMgYW5kIGluZHVzdHJpYWwgY2xpZW50cy4gSXQgY29tYmluZXMgTExNIHJlYXNvbmluZyAoQW5hbHlzaXMpIHdpdGggUkwgY29udHJvbCAoT3B0aW1pemF0aW9uKS4iLCAiY2hpbGRyZW4iOiBbeyJ0aXRsZSI6ICJFeGVjdXRpdmUgU3VtbWFyeSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImRvbmUiLCAidHlwZSI6ICJjb250ZXh0IiwgImlkIjogInByb2R1Y3Quc2Fhcy5zdW1tYXJ5IiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTIzVDEzOjQ3OjA3KzAxOjAwIn0sICJjb250ZW50IjogIioqVGhlIFZpc2lvbioqOiBUcmFuc2Zvcm0gZGF0YSBpbnRvIGRlY2lzaW9uLiBUaGUgcGxhdGZvcm0gYWxsb3dzIGNsaWVudHMgdG8gXCJjaGF0IHdpdGggZGF0YVwiIGFuZCBvcHRpbWl6ZSBvcGVyYXRpb25zIHVzaW5nIGEgY29udmVyc2F0aW9uYWwgaW50ZXJmYWNlIGJhY2tlZCBieSByaWdvcm91cyBleGVjdXRpb24gZW5naW5lcy5cbi0gICAqKkFuYWx5c3QqKjogXCJXaHkgaXMgdGhpcyBoYXBwZW5pbmc/XCIgLT4gQ29kZSBJbnRlcnByZXRlciBhbmFseXNpcy5cbi0gICAqKkNvbnRyb2xsZXIqKjogXCJPcHRpbWl6ZSBmb3IgZWZmaWNpZW5jeS5cIiAtPiBSTCBBZ2VudCBleGVjdXRpb24uXG5cbioqVmFsdWUgUHJvcG9zaXRpb25zKipcbjEuICAqKlJldGFpbC9TTUJzIChUaGUgQWdlbnRpYyBBbmFseXN0KSoqOiBEZW1vY3JhdGl6ZWQgRGF0YSBTY2llbmNlLiBJbnN0YW50IGFuc3dlcnMgdG8gY29sbG9xdWlhbCBxdWVzdGlvbnMgd2l0aG91dCBhIGRhdGEgdGVhbS5cbjIuICAqKkxvZ2lzdGljcyAoSW52ZW50b3J5IEF1dG8tUGlsb3QpKio6IENhc2ggZmxvdyBvcHRpbWl6YXRpb24uIEF1dG9tYXRlZCByZW9yZGVyaW5nIHVzaW5nIFJMIGFnZW50cyB0byBzb2x2ZSB0aGUgTmV3c3ZlbmRvciBwcm9ibGVtIChtaW5pbWl6ZSBob2xkaW5nIGNvc3RzIHZzLiBwcmV2ZW50IHN0b2Nrb3V0cykuIiwgImNoaWxkcmVuIjogW119LCB7InRpdGxlIjogIlRlY2huaWNhbCBBcmNoaXRlY3R1cmUiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJhY3RpdmUiLCAidHlwZSI6ICJwbGFuIiwgImlkIjogInByb2R1Y3Quc2Fhcy5hcmNoIiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTIzVDEzOjQ3OjA3KzAxOjAwIn0sICJjb250ZW50IjogIlRoZSBzeXN0ZW0gc2VwYXJhdGVzIEFuYWx5dGljYWwgUXVlcmllcyAoQ29kZSBFeGVjdXRpb24pIGZyb20gQ29udHJvbCBUYXNrcyAoTW9kZWwgSW5mZXJlbmNlKS4iLCAiY2hpbGRyZW4iOiBbeyJ0aXRsZSI6ICJDb3JlIENvbXBvbmVudHMiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJhY3RpdmUiLCAidHlwZSI6ICJjb250ZXh0IiwgImlkIjogInByb2R1Y3Quc2Fhcy5hcmNoLmNvbXBvbmVudHMiLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjNUMTM6NDc6MDcrMDE6MDAifSwgImNvbnRlbnQiOiAiIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiQ2hhdGJvdCBBc3Npc3RhbnQgQXBwIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAiY29udGV4dCIsICJpZCI6ICJwcm9kdWN0LnNhYXMuYXJjaC5jb21wb25lbnRzLmNoYXRib3QiLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjNUMTk6NDc6MzErMDE6MDAifSwgImNvbnRlbnQiOiAiU2VydmVzIGFzIHRoZSBwcmltYXJ5IGludGVyZmFjZSBmb3IgdXNlcnMsIGZ1bmN0aW9uaW5nIHNpbXVsdGFuZW91c2x5IGFzIGEgbWVjaGFuaXNtIGZvciBpbnRlcmFjdGlvbiBhbmQgYSBsb2NhbCBkYXRhIHdhcmVob3VzZS4gSXQgZmFjaWxpdGF0ZXMgZGF0YSBjb2xsZWN0aW9uIGFuZCB1c2VyIGludGVudCBjYXB0dXJlLiIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJJbnRlcm5hbCBFY29zeXN0ZW0gb2YgQUktQXNzaXN0YW50cyIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImFjdGl2ZSIsICJ0eXBlIjogImNvbnRleHQiLCAiaWQiOiAicHJvZHVjdC5zYWFzLmFyY2guY29tcG9uZW50cy5lY29zeXN0ZW0iLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjNUMTk6NDc6MzErMDE6MDAifSwgImNvbnRlbnQiOiAiQSBiYWNrZ3JvdW5kIG9yY2hlc3RyYXRpb24gbGF5ZXIgd2hlcmUgbXVsdGlwbGUgc3BlY2lhbGl6ZWQgQUkgYWdlbnRzIGNvbGxhYm9yYXRlLiBUaGVzZSBhZ2VudHMgYXJlIGludGVybmFsLW9ubHkgYW5kIGhhbmRsZSBzcGVjaWZpYyBzdWItdGFza3MgdG8gZW5zdXJlIHNlYW1sZXNzIHN5c3RlbSBvcGVyYXRpb24uIiwgImNoaWxkcmVuIjogW119LCB7InRpdGxlIjogIkNsb3VkIEluZnJhc3RydWN0dXJlIChCaWdRdWVyeSAmIENvbXB1dGUpIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAiY29udGV4dCIsICJpZCI6ICJwcm9kdWN0LnNhYXMuYXJjaC5jb21wb25lbnRzLmNsb3VkIiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTIzVDE5OjQ3OjMxKzAxOjAwIn0sICJjb250ZW50IjogIlRoZSBzY2FsYWJsZSBiYWNrYm9uZSBvZiB0aGUgcGxhdGZvcm0uIEl0IGluY2x1ZGVzICoqR29vZ2xlIEJpZ1F1ZXJ5KiogZm9yIG1hc3NpdmUgZGF0YSB3YXJlaG91c2luZyBhbmQgKipHb29nbGUgQ2xvdWQgQ29tcHV0ZSoqIGZvciBwZXJmb3JtYW50IHByb2Nlc3NpbmcsIGVuc3VyaW5nIHJlbGlhYmlsaXR5IGFuZCBzcGVlZC4iLCAiY2hpbGRyZW4iOiBbXX0sIHsidGl0bGUiOiAiSW50ZXJuYWwgQWxnb3JpdGhtcyBSZXBvc2l0b3J5IiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAiY29udGV4dCIsICJpZCI6ICJwcm9kdWN0LnNhYXMuYXJjaC5jb21wb25lbnRzLmFsZ29yaXRobXMiLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjNUMTk6NDc6MzErMDE6MDAifSwgImNvbnRlbnQiOiAiVGhlIGNlbnRyYWwgbGlicmFyeSBvZiBkYXRhIHByb2Nlc3NpbmcgYW5kIGNvbnRyb2wgYWxnb3JpdGhtcy4gVGhpcyBsZXZlcmFnZXMgKipWZXJ0ZXggQUkqKiBmb3IgYWR2YW5jZWQgZGF0YSBzY2llbmNlIG1vZGVsaW5nIGFuZCBvcHRpbWl6YXRpb24gdGFza3MsIHJlcHJlc2VudGluZyB0aGUgY29yZSBpbnRlbGxlY3R1YWwgcHJvcGVydHkgb2YgdGhlIGFuYWx5c2lzIGVuZ2luZS4iLCAiY2hpbGRyZW4iOiBbXX1dfSwgeyJ0aXRsZSI6ICJJbmZvcm1hdGlvbiBGbG93IiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAiY29udGV4dCIsICJpZCI6ICJwcm9kdWN0LnNhYXMuYXJjaC5mbG93IiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTIzVDEzOjQ3OjA3KzAxOjAwIn0sICJjb250ZW50IjogIiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIkFJIEFzc2lzdGFudCBPcmNoZXN0cmF0aW9uIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAiY29udGV4dCIsICJpZCI6ICJwcm9kdWN0LnNhYXMuYXJjaC5mbG93Lm9yY2hlc3RyYXRpb24iLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjNUMTU6Mjg6NTkrMDE6MDAifSwgImNvbnRlbnQiOiAiVXNlciBpbnRlcmFjdGlvbiBiZWdpbnMgd2l0aCB0aGUgQ2hhdGJvdCBBcHAsIHdoaWNoIGZvcndhcmRzIHJlcXVlc3RzIHRvIHRoZSBPcmNoZXN0cmF0b3IgKFZlcnRleCBBSSkuXG4xLiAgKipJbnRlbnQgUmVjb2duaXRpb24qKjogVGhlIE9yY2hlc3RyYXRvciBkZXRlcm1pbmVzIGlmIHRoZSByZXF1ZXN0IGlzICoqQW5hbHlzaXMqKiAoaW5mb3JtYXRpb25hbCkgb3IgKipDb250cm9sKiogKGFjdGlvbmFibGUpLlxuMi4gICoqUm91dGluZyoqOlxuICAgICogICAqKkFuYWx5c2lzKio6IFJvdXRlZCB0byBDb2RlIEludGVycHJldGVyIC8gQW5hbHlzdCBBZ2VudCBmb3IgZGF0YSBxdWVyeWluZyBhbmQgdmlzdWFsaXphdGlvbi5cbiAgICAqICAgKipDb250cm9sKio6IFJvdXRlZCB0byBQbGFubmVyIC8gUkwgQWdlbnQgZm9yIG9wdGltaXphdGlvbiBhbmQgZGVjaXNpb24gbWFraW5nLlxuMy4gICoqUmVzcG9uc2UqKjogUmVzdWx0cyBhcmUgYWdncmVnYXRlZCBhbmQgcmV0dXJuZWQgdG8gdGhlIENoYXRib3QgYXMgbmF0dXJhbCBsYW5ndWFnZSBvciBVSSBjb21wb25lbnRzLiIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJDb250cm9sIExvb3AiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJhY3RpdmUiLCAidHlwZSI6ICJjb250ZXh0IiwgImlkIjogInByb2R1Y3Quc2Fhcy5hcmNoLmZsb3cuY29udHJvbCIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QxNToyODo1OSswMTowMCJ9LCAiY29udGVudCI6ICJUaGlzIGhpZ2gtZnJlcXVlbmN5IGxvb3AgaGFuZGxlcyB0aGUgYXV0b25vbW91cyBvcHRpbWl6YXRpb24gc3lzdGVtOlxuMS4gICoqVGVsZW1ldHJ5IEluZ2VzdCoqOiBSYXcgZGF0YSBzdHJlYW1zIGZyb20gdGhlIENsaWVudCBBcHAvV2FyZWhvdXNlIGFyZSBpbmdlc3RlZCBpbnRvIEJpZ1F1ZXJ5LlxuMi4gICoqU3RhdGUgRXN0aW1hdGlvbioqOiBQcm9jZXNzaW5nIGFsZ29yaXRobXMgY29udmVydCByYXcgdGVsZW1ldHJ5IGludG8gc3RhdGUgdmVjdG9ycyAoJHNfdCQpIHN1aXRhYmxlIGZvciBtb2RlbCBpbnB1dC5cbjMuICAqKkRlY2lzaW9uKio6IFRoZSBQb2xpY3kgbmV0d29yayAoJFxccGkkKSBvciBQbGFuZXIgc2VsZWN0cyB0aGUgb3B0aW1hbCBhY3Rpb24gKCRhX3QkKSBiYXNlZCBvbiB0aGUgY3VycmVudCBzdGF0ZS5cbjQuICAqKkV4ZWN1dGlvbiAmIEZlZWRiYWNrKio6IFRoZSBhY3Rpb24gaXMgc2VudCB0byB0aGUgQ29udHJvbGxlciBmb3IgZXhlY3V0aW9uLCBhbmQgdGhlIG91dGNvbWUgaXMgcmVjb3JkZWQgZm9yIG9mZmxpbmUgcmUtdHJhaW5pbmcgYW5kIHJlZmluZW1lbnQuIiwgImNoaWxkcmVuIjogW119LCB7InRpdGxlIjogIkh1bWFuLUFJIEludGVyYWN0aW9uIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAiY29udGV4dCIsICJpZCI6ICJwcm9kdWN0LnNhYXMuYXJjaC5mbG93Lmh1bWFuX2FpIiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTIzVDE5OjUxOjA3KzAxOjAwIn0sICJjb250ZW50IjogIkRlZmluZXMgdGhlIHByb3RvY29scyBmb3IgaG93IGh1bWFucyBpbnRlcmFjdCB3aXRoIHRoZSBBSSBhZ2VudHMuIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiRGV2ZWxvcGVyLUFJIEludGVyYWN0aW9uIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAicHJvdG9jb2wiLCAiaWQiOiAicHJvZHVjdC5zYWFzLmFyY2guZmxvdy5odW1hbl9haS5kZXZlbG9wZXIiLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjNUMTk6NTE6MDcrMDE6MDAifSwgImNvbnRlbnQiOiAiUHJvdG9jb2wgZm9yIGRldmVsb3BlcnMgdG8gY29uZmlndXJlLCB0cmFpbiwgYW5kIGRlYnVnIGFnZW50cy4gSW52b2x2ZXMgZGlyZWN0IGFjY2VzcyB0byBpbnRlcm5hbCBsb2dzLCBtb2RlbCB3ZWlnaHRzLCBhbmQgdGhlICdBbmFseXNpcyBTYW5kYm94JyBmb3Igc2FmZSBjb2RlIHRlc3RpbmcuIiwgImNoaWxkcmVuIjogW119LCB7InRpdGxlIjogIkNsaWVudC1BSSBJbnRlcmFjdGlvbiIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImFjdGl2ZSIsICJ0eXBlIjogInByb3RvY29sIiwgImlkIjogInByb2R1Y3Quc2Fhcy5hcmNoLmZsb3cuaHVtYW5fYWkuY2xpZW50IiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTIzVDE5OjUxOjA3KzAxOjAwIn0sICJjb250ZW50IjogIlByb3RvY29sIGZvciBlbmQtdXNlcnMuIFJlc3RyaWN0ZWQgdG8gbmF0dXJhbCBsYW5ndWFnZSB2aWEgdGhlIENoYXRib3QgQXBwLiBObyBkaXJlY3QgY29kZSBleGVjdXRpb24gYWxsb3dlZC4gSW50ZW50IGlzIHBhcnNlZCBieSB0aGUgT3JjaGVzdHJhdG9yLiIsICJjaGlsZHJlbiI6IFtdfV19LCB7InRpdGxlIjogIkFJLVRvb2xzIFByb3RvY29scyIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImFjdGl2ZSIsICJ0eXBlIjogInByb3RvY29sIiwgImlkIjogInByb2R1Y3Quc2Fhcy5hcmNoLmZsb3cudG9vbHMiLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjNUMTk6NTE6MDcrMDE6MDAifSwgImNvbnRlbnQiOiAiUHJvdG9jb2xzIGZvciBob3cgQUkgYWdlbnRzIHV0aWxpemUgZXh0ZXJuYWwgc29mdHdhcmUgYW5kIEFQSXMuIEFkaGVyZXMgdG8gdGhlICoqTW9kZWwgQ29udGV4dCBQcm90b2NvbCAoTUNQKSoqIHRvIHN0YW5kYXJkaXplIHRvb2wgZGVmaW5pdGlvbiwgZGlzY292ZXJ5LCBhbmQgZXhlY3V0aW9uLiIsICJjaGlsZHJlbiI6IFtdfV19LCB7InRpdGxlIjogIktub3dsZWRnZSBCYXNlcyIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImFjdGl2ZSIsICJ0eXBlIjogImNvbnRleHQiLCAiaWQiOiAicHJvZHVjdC5zYWFzLmFyY2gua25vd2xlZGdlIiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTIzVDIwOjAwOjAwKzAxOjAwIn0sICJjb250ZW50IjogIlJlcG9zaXRvcnkgcmVzb3VyY2VzIGNhdGVnb3JpemVkIGJ5IHRoZWlyIGZ1bmN0aW9uLiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIkFnZW50aWMiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJhY3RpdmUiLCAidHlwZSI6ICJjb250ZXh0IiwgImlkIjogInByb2R1Y3Quc2Fhcy5hcmNoLmtub3dsZWRnZS5hZ2VudGljIiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTIzVDIwOjAwOjAwKzAxOjAwIn0sICJjb250ZW50IjogIi0gW01BTkFHRVJfQUdFTlRdKE1BTkFHRVJfQUdFTlQubWQpXG4tIFtDTEVBTkVSX0FHRU5UXSguLi9jbGVhbmVyL0NMRUFORVJfQUdFTlQubWQpXG4tIFtSRUFDVF9BU1NJU1RBTlRdKC4uLy4uL0FJX0FHRU5UUy9zcGVjaWFsaXN0cy9SRUFDVF9BU1NJU1RBTlQubWQpXG4tIFtSRUNTWVNfQUdFTlRdKC4uLy4uL0FJX0FHRU5UUy9zcGVjaWFsaXN0cy9SRUNTWVNfQUdFTlQubWQpXG4tIFtDT05UUk9MX0FHRU5UXSguLi8uLi9BSV9BR0VOVFMvc3BlY2lhbGlzdHMvQ09OVFJPTF9BR0VOVC5tZClcbi0gW1VJX0RFU0lHX0FTU0lTVEFOVF0oLi4vLi4vQUlfQUdFTlRTL3NwZWNpYWxpc3RzL1VJX0RFU0lHX0FTU0lTVEFOVC5tZClcbi0gW0xJTkVBUklaRV9BR0VOVF0oLi4vLi4vQUlfQUdFTlRTL3NwZWNpYWxpc3RzL0xJTkVBUklaRV9BR0VOVC5tZClcbi0gW01DX0FHRU5UXSguLi8uLi9BSV9BR0VOVFMvc3BlY2lhbGlzdHMvTUNfQUdFTlQubWQpIiwgImNoaWxkcmVuIjogW119LCB7InRpdGxlIjogIktub3dsZWRnZSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImFjdGl2ZSIsICJ0eXBlIjogImNvbnRleHQiLCAiaWQiOiAicHJvZHVjdC5zYWFzLmFyY2gua25vd2xlZGdlLmdlbmVyYWwiLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjNUMjA6MDA6MDArMDE6MDAifSwgImNvbnRlbnQiOiAiLSBbUkVBRE1FXSguLi8uLi9SRUFETUUubWQpXG4tIFtNRF9DT05WRU5USU9OU10oLi4vLi4vTURfQ09OVkVOVElPTlMubWQpXG4tIFtBR0VOVFNdKC4uLy4uL0FHRU5UUy5tZClcbi0gW0FHRU5UU19MT0ddKC4uLy4uL0FHRU5UU19MT0cubWQpXG4tIFtEQUdfRXhhbXBsZV0oLi4vLi4vbGFuZ3VhZ2UvZXhhbXBsZS9EQUdfRXhhbXBsZS5tZCkiLCAiY2hpbGRyZW4iOiBbXX1dfV19LCB7InRpdGxlIjogIkltcGxlbWVudGF0aW9uIFJvYWRtYXAiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJhY3RpdmUiLCAidHlwZSI6ICJwbGFuIiwgImlkIjogInByb2R1Y3Quc2Fhcy5yb2FkbWFwIiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTIzVDIxOjQ0OjIzKzAxOjAwIn0sICJjb250ZW50IjogIlRoaXMgcm9hZG1hcCBzdHJpcHMgYXdheSBlbnRlcnByaXNlIGNvbXBsZXhpdHkgdG8gZm9jdXMgb24gdGhlIGNvcmUgdmFsdWUgcHJvcG9zaXRpb246IGEgbG9jYWwgYXBwIHRoYXQgYWN0cyBhcyBhIGRhdGEgaHViIGFuZCBhIGNoYXQgaW50ZXJmYWNlLCBjb25uZWN0ZWQgdG8gcG93ZXJmdWwgY2xvdWQgYWdlbnRzIGZvciBleGVjdXRpb24uIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiUGhhc2UgMTogTG9jYWwgTmV4dXMiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJhY3RpdmUiLCAidHlwZSI6ICJwbGFuIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMSIsICJvd25lciI6ICJ1c2VyIiwgInByaW9yaXR5IjogImNyaXRpY2FsIiwgImVzdGltYXRlIjogIjR3IiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTI0VDA4OjM1OjAwKzAxOjAwIn0sICJjb250ZW50IjogIlRoaXMgZG9jdW1lbnQgb3V0bGluZXMgdGhlIHRhY3RpY2FsIGV4ZWN1dGlvbiBwbGFuIGZvciBidWlsZGluZyB0aGUgKipMb2NhbCBOZXh1cyoqLCB0aGUgY2xpZW50LXNpZGUgYXBwbGljYXRpb24gb2YgdGhlIEludGVsbGlnZW50IENvbnRyb2wgU2FhUy5cblxuKipPYmplY3RpdmUqKjogQ3JlYXRlIGEgc2VsZi1jb250YWluZWQgbG9jYWwgYXBwbGljYXRpb24gdGhhdCBmdW5jdGlvbnMgYXM6XG4xLiAqKkRhdGEgV2FyZWhvdXNlKio6IEluZ2VzdHMgYW5kIHN0cnVjdHVyZXMgcmF3IENTVi9FeGNlbCBmaWxlcyBsb2NhbGx5IChEdWNrREIpLlxuMi4gKipJbnRlcmZhY2UqKjogQSBjaGF0LWJhc2VkIFVJIGZvciBxdWVyeWluZyB0aGF0IGRhdGEgKFN0cmVhbWxpdCkuXG5cbioqVGVjaCBTdGFjayBTZWxlY3Rpb24qKjpcbiogKipMYW5ndWFnZSoqOiBQeXRob24gMy4xMCtcbiogKipGcm9udGVuZCoqOiBTdHJlYW1saXQgKENob3NlbiBmb3IgcmFwaWQgaXRlcmF0aW9uIGFuZCBuYXRpdmUgZGF0YSBzdXBwb3J0KS5cbiogKipEYXRhYmFzZSoqOiBEdWNrREIgKEVtYmVkZGVkIE9MQVAsIHplcm8tZGVwZW5kZW5jeSwgU1FMIGNvbXBhdGlibGUpLlxuKiAqKkRhdGEgUHJvY2Vzc2luZyoqOiBQYW5kYXMgLyBQb2xhcnMuIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiUHJvamVjdCBJbml0aWFsaXphdGlvbiAmIFN0cnVjdHVyZSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMS5pbml0IiwgImVzdGltYXRlIjogIjFkIiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTI0VDA4OjM1OjAwKzAxOjAwIn0sICJjb250ZW50IjogIkVzdGFibGlzaCB0aGUgcmVwb3NpdG9yeSBzdHJ1Y3R1cmUgdG8gc3VwcG9ydCBtb2R1bGFyIGdyb3d0aCBpbnRvIFBoYXNlcyAyIGFuZCAzLlxuXG4qKkRpcmVjdG9yeSBTdHJ1Y3R1cmUqKjpcbmBgYFxuL3NyY1xuICAvYXBwLnB5ICAgICAgICAgICAgIyBNYWluIFN0cmVhbWxpdCBlbnRyeSBwb2ludFxuICAvY29yZVxuICAgIC9kYXRhYmFzZS5weSAgICAgIyBEdWNrREIgc2luZ2xldG9uIHdyYXBwZXJcbiAgICAvaW5nZXN0aW9uLnB5ICAgICMgRmlsZSBwcm9jZXNzaW5nIGxvZ2ljXG4gIC9jb21wb25lbnRzXG4gICAgL2NoYXQucHkgICAgICAgICAjIFVJIGNvbXBvbmVudCBmb3IgY2hhdCBoaXN0b3J5XG4gICAgL3NpZGViYXIucHkgICAgICAjIFVJIGNvbXBvbmVudCBmb3IgZmlsZSBtYW5hZ2VtZW50XG4gIC91dGlsc1xuICAgIC9sb2dnZXIucHkgICAgICAgIyBUZWxlbWV0cnkgbG9nZ2luZyAoZm9yIGZ1dHVyZSBSTClcbi90ZXN0cyAgICAgICAgICAgICAgICMgVW5pdCBhbmQgaW50ZWdyYXRpb24gdGVzdHNcbi9kYXRhXG4gIC9yYXcgICAgICAgICAgICAgICAjIFN0YWdpbmcgYXJlYSBmb3IgdXNlciB1cGxvYWRzXG4gIC93YXJlaG91c2UuZGIgICAgICAjIFBlcnNpc3RlbnQgRHVja0RCIGZpbGVcbmBgYCIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJNb2R1bGUgMTogVGhlIExvY2FsIERhdGEgV2FyZWhvdXNlIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLndhcmVob3VzZSIsICJibG9ja2VkX2J5IjogWyJpbXBsZW1lbnRhdGlvbi5waGFzZTEuaW5pdCJdLCAiZXN0aW1hdGUiOiAiMXciLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjRUMDg6MzU6MDArMDE6MDAifSwgImNvbnRlbnQiOiAiSW1wbGVtZW50IHRoZSBwZXJzaXN0ZW5jZSBsYXllciB1c2luZyBEdWNrREIuIFRoaXMgaXMgdGhlIFwiTG9uZy1UZXJtIE1lbW9yeVwiIG9mIHRoZSBzeXN0ZW0uIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiRGF0YWJhc2UgTWFuYWdlciBDbGFzcyIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMS53YXJlaG91c2UubWFuYWdlciIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yNFQwODozNTowMCswMTowMCJ9LCAiY29udGVudCI6ICJDcmVhdGUgYSBEYXRhYmFzZU1hbmFnZXIgY2xhc3MgaW4gc3JjL2NvcmUvZGF0YWJhc2UucHkuXG5cbiogKipDb25uZWN0aW9uKio6IE1haW50YWluIGEgcGVyc2lzdGVudCBjb25uZWN0aW9uIHRvIGRhdGEvd2FyZWhvdXNlLmRiLlxuKiAqKlNjaGVtYSBEZWZpbml0aW9uKio6XG4gICAgKiAqKmBtZXRhZGF0YV9yZWdpc3RyeWAqKjpcbiAgICAgICAgKiBgZmlsZV9pZGAgKFVVSUQsIFBLKVxuICAgICAgICAqIGBmaWxlbmFtZWAgKFZBUkNIQVIpXG4gICAgICAgICogYHVwbG9hZF90aW1lc3RhbXBgIChUSU1FU1RBTVApXG4gICAgICAgICogYGZpbGVfaGFzaGAgKFZBUkNIQVIpXG4gICAgICAgICogYHJvd19jb3VudGAgKElOVEVHRVIpXG4gICAgKiAqKmB0ZWxlbWV0cnlfbG9nYCoqOlxuICAgICAgICAqIGBsb2dfaWRgIChVVUlELCBQSylcbiAgICAgICAgKiBgdXNlcl9pZGAgKFZBUkNIQVIsIG51bGxhYmxlKSAtLSBQcmVwYXJlIGZvciBQaGFzZSAyIEF1dGhcbiAgICAgICAgKiBgdGltZXN0YW1wYCAoVElNRVNUQU1QKVxuICAgICAgICAqIGBxdWVyeV90ZXh0YCAoVkFSQ0hBUilcbiAgICAgICAgKiBgcmVzcG9uc2VfdHlwZWAgKFZBUkNIQVIpXG4gICAgICAgICogYHVzZXJfZmVlZGJhY2tgIChJTlRFR0VSLCBudWxsYWJsZSlcbiAgICAgICAgKiBgc3luY2VkX2F0YCAoVElNRVNUQU1QLCBudWxsYWJsZSkgLS0gRm9yIFBoYXNlIDIgU3luYyBMb2dpY1xuKiAqKk1ldGhvZHMqKjogYGdldF9jb25uZWN0aW9uKClgLCBgZXhlY3V0ZV9xdWVyeSgpYCwgYGdldF90YWJsZV9zY2hlbWEoKWAuIiwgImNoaWxkcmVuIjogW119LCB7InRpdGxlIjogIkluZ2VzdGlvbiBTZXJ2aWNlIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLndhcmVob3VzZS5pbmdlc3QiLCAiYmxvY2tlZF9ieSI6IFsiaW1wbGVtZW50YXRpb24ucGhhc2UxLndhcmVob3VzZS5tYW5hZ2VyIl0sICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yNFQwODozNTowMCswMTowMCJ9LCAiY29udGVudCI6ICJDcmVhdGUgbG9naWMgdG8gaGFuZGxlIHVzZXIgZmlsZSB1cGxvYWRzLlxuXG4xLiAqKk5vcm1hbGl6YXRpb24qKjogQ29udmVydCBpbmNvbWluZyBFeGNlbC9DU1YgdG8gYSBzdHJpY3QgUGFuZGFzIERhdGFGcmFtZS5cbjIuICoqVHlwZSBFbmZvcmNlbWVudCoqOiBDYXN0IGdlbmVyaWMgYG9iamVjdGAgY29sdW1ucyB0byBzcGVjaWZpYyB0eXBlcyAoU3RyaW5nLCBJbnQsIEZsb2F0LCBCb29sLCBUaW1lc3RhbXApIHRvIGVuc3VyZSBmdXR1cmUgQmlnUXVlcnkgY29tcGF0aWJpbGl0eS5cbjMuICoqU2FuaXRpemF0aW9uKio6IENsZWFuIGNvbHVtbiBuYW1lcyAobG93ZXJjYXNlLCBzbmFrZV9jYXNlKSB0byBtYWtlIHRoZW0gU1FMLWZyaWVuZGx5IGZvciB0aGUgTExNIGxhdGVyLlxuNC4gKipTdG9yYWdlKio6IFVzZSBgZHVja2RiLnNxbChcIkNSRUFURSBUQUJMRSAuLi4gQVMgU0VMRUNUIC4uLlwiKWAgdG8gcGVyc2lzdCBkYXRhLlxuNS4gKipWZXJzaW9uaW5nKio6IENhbGN1bGF0ZSBhIGNvbnRlbnQgaGFzaCAoU0hBLTI1Nikgb2YgdGhlIGZpbGUuIElmIHRoZSBoYXNoIGV4aXN0cywgc2tpcDsgaWYgdGhlIGZpbGVuYW1lIGV4aXN0cyBidXQgaGFzaCBkaWZmZXJzLCBjcmVhdGUgYSBuZXcgdmVyc2lvbiAoZS5nLiwgYHNhbGVzX2RhdGFfdjJgKS4iLCAiY2hpbGRyZW4iOiBbXX1dfSwgeyJ0aXRsZSI6ICJNb2R1bGUgMjogVGhlIENoYXQgSW50ZXJmYWNlIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLnVpIiwgImJsb2NrZWRfYnkiOiBbImltcGxlbWVudGF0aW9uLnBoYXNlMS53YXJlaG91c2UiXSwgImVzdGltYXRlIjogIjF3IiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTI0VDA4OjM1OjAwKzAxOjAwIn0sICJjb250ZW50IjogIkltcGxlbWVudCB0aGUgU3RyZWFtbGl0IGZyb250ZW5kLiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIkxheW91dCAmIFNlc3Npb24gU3RhdGUiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTEudWkubGF5b3V0IiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTI0VDA4OjM1OjAwKzAxOjAwIn0sICJjb250ZW50IjogIiogKipTaWRlYmFyKio6IFwiRGF0YSBNYW5hZ2VtZW50XCIuIEEgZmlsZSB1cGxvYWRlciB3aWRnZXQgYW5kIGEgbGlzdCBvZiBjdXJyZW50bHkgYXZhaWxhYmxlIHRhYmxlcyBpbiBEdWNrREIuXG4qICoqTWFpbiBBcmVhKio6IENoYXQgY29udGFpbmVyLlxuKiAqKlN0YXRlIE1hbmFnZW1lbnQqKjogSW5pdGlhbGl6ZSBgc3Quc2Vzc2lvbl9zdGF0ZWAgdG8gaG9sZDpcbiAgKiBgbWVzc2FnZXNgOiBMaXN0IG9mIGB7J3JvbGUnOiAndXNlcid8J2Fzc2lzdGFudCcsICdjb250ZW50Jzogc3RyLCAnZGF0YV9yZWYnOiAuLi59YC5cbiAgKiBgYWN0aXZlX3RhYmxlc2A6IExpc3Qgb2YgdGFibGVzIGN1cnJlbnRseSBpbiBjb250ZXh0LlxuICAqIGB1c2VyX2lkZW50aXR5YDogRGljdCBgeydpZCc6ICdsb2NhbC1kZXYnLCAncm9sZSc6ICdhZG1pbid9YCAoTW9jayBmb3IgUGhhc2UgMiBBdXRoKS4iLCAiY2hpbGRyZW4iOiBbXX0sIHsidGl0bGUiOiAiQ2hhdCBMb2dpYyAmIE1vY2sgT3JjaGVzdHJhdG9yIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLnVpLmNoYXQiLCAiYmxvY2tlZF9ieSI6IFsiaW1wbGVtZW50YXRpb24ucGhhc2UxLnVpLmxheW91dCJdLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjRUMDg6MzU6MDArMDE6MDAifSwgImNvbnRlbnQiOiAiU2luY2UgdGhlIENsb3VkIEFnZW50cyAoUGhhc2UgMykgYXJlIG5vdCByZWFkeSwgYnVpbGQgYSAqKkxvY2FsIExvb3BiYWNrKiogZm9yIHRlc3RpbmcuXG5cbjEuICoqSW5wdXQqKjogVXNlciB0eXBlcyBcIlNob3cgbWUgdGhlIGxhc3QgNSByb3dzIG9mIHNhbGVzXCIuXG4yLiAqKk1vY2sgUHJvY2Vzc29yKio6XG4gICAqIFJlZ2V4IG9yIEtleXdvcmQgbWF0Y2hpbmcgKGUuZy4sIGlmIFwic2hvd1wiIGFuZCBcInNhbGVzXCIgaW4gdGV4dCAtPiBgU0VMRUNUICogRlJPTSBzYWxlcyBMSU1JVCA1YCkuXG4gICAqICpHb2FsKjogUHJvdmUgdGhlIFVJIGNhbiByZW5kZXIgYSBEYXRhRnJhbWUgcmV0dXJuZWQgYnkgRHVja0RCLlxuMy4gKipSZW5kZXJpbmcqKjpcbiAgICogSWYgcmVzcG9uc2UgaXMgVGV4dDogYHN0Lm1hcmtkb3duKClgLlxuICAgKiBJZiByZXNwb25zZSBpcyBEYXRhOiBgc3QuZGF0YWZyYW1lKClgIG9yIGBzdC5iYXJfY2hhcnQoKWAuIiwgImNoaWxkcmVuIjogW119XX0sIHsidGl0bGUiOiAiTW9kdWxlIDM6IFRlc3RpbmcgJiBRdWFsaXR5IEFzc3VyYW5jZSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMS50ZXN0aW5nIiwgImJsb2NrZWRfYnkiOiBbImltcGxlbWVudGF0aW9uLnBoYXNlMS51aSJdLCAiZXN0aW1hdGUiOiAiM2QiLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjRUMDg6MzU6MDArMDE6MDAifSwgImNvbnRlbnQiOiAiRXN0YWJsaXNoIGNvbXByZWhlbnNpdmUgdGVzdGluZyB0byBlbnN1cmUgcmVsaWFiaWxpdHkgYmVmb3JlIHBhY2thZ2luZy4iLCAiY2hpbGRyZW4iOiBbeyJ0aXRsZSI6ICJVbml0IFRlc3RzIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLnRlc3RpbmcudW5pdCJ9LCAiY29udGVudCI6ICItIDwhLS0gY29udGVudCAtLT5cbi0gKipGcmFtZXdvcmsqKjogYHB5dGVzdGBcbi0gKipDb3ZlcmFnZSoqOlxuICAgIC0gYGluZ2VzdGlvbi5weWA6IFZlcmlmeSBmaWxlIGhhc2ggYXNzZXJ0aW9ucyBhbmQgc2NoZW1hIG5vcm1hbGl6YXRpb24uXG4gICAgLSBgZGF0YWJhc2UucHlgOiBUZXN0IGNvbm5lY3Rpb24gcGVyc2lzdGVuY2UgYW5kIHF1ZXJ5IGV4ZWN1dGlvbiB3aXRoIG1vY2sgZGF0YS4iLCAiY2hpbGRyZW4iOiBbXX0sIHsidGl0bGUiOiAiSW50ZWdyYXRpb24gVGVzdHMiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTEudGVzdGluZy5pbnRlZ3JhdGlvbiIsICJibG9ja2VkX2J5IjogWyJpbXBsZW1lbnRhdGlvbi5waGFzZTEudGVzdGluZy51bml0Il19LCAiY29udGVudCI6ICItIDwhLS0gY29udGVudCAtLT5cbi0gKipGbG93Kio6IFNpbXVsYXRlIGEgZnVsbCB1c2VyIGZsb3c6IFVzZXIgdXBsb2FkcyBDU1YgLT4gSW5nZXN0aW9uIC0+IHN0b3JlZCBpbiBEQiAtPiBRdWVyeSByZXRyaWV2ZXMgaXQuIiwgImNoaWxkcmVuIjogW119XX0sIHsidGl0bGUiOiAiTW9kdWxlIDQ6IFBhY2thZ2luZyAmIERpc3RyaWJ1dGlvbiIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMS5wYWNrYWdpbmciLCAiYmxvY2tlZF9ieSI6IFsiaW1wbGVtZW50YXRpb24ucGhhc2UxLnRlc3RpbmciXSwgImVzdGltYXRlIjogIjJkIiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTI0VDA4OjM1OjAwKzAxOjAwIn0sICJjb250ZW50IjogIlByZXBhcmUgdGhlIGFwcGxpY2F0aW9uIGZvciBlYXN5IGxvY2FsIGRlcGxveW1lbnQuIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiRGVwZW5kZW5jeSBNYW5hZ2VtZW50IiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLnBhY2thZ2luZy5kZXBzIn0sICJjb250ZW50IjogIi0gPCEtLSBjb250ZW50IC0tPlxuLSBDcmVhdGUgYHJlcXVpcmVtZW50cy50eHRgIHdpdGggbG9ja2VkIHZlcnNpb25zLlxuLSBDcmVhdGUgYGVudmlyb25tZW50LnltbGAgZm9yIENvbmRhIHVzZXJzLiIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJFeGVjdXRpb24gU2NyaXB0cyIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMS5wYWNrYWdpbmcuc2NyaXB0cyJ9LCAiY29udGVudCI6ICItIDwhLS0gY29udGVudCAtLT5cbi0gQ3JlYXRlIGBydW5fYXBwLnNoYCAoTWFjL0xpbnV4KSBhbmQgYHJ1bl9hcHAuYmF0YCAoV2luZG93cykgdG8gc2V0IHVwIHRoZSBlbnZpcm9ubWVudCBhbmQgbGF1bmNoIGBzdHJlYW1saXQgcnVuIHNyYy9hcHAucHlgLiIsICJjaGlsZHJlbiI6IFtdfV19LCB7InRpdGxlIjogIlJlc2VhcmNoIEluc3RydW1lbnRhdGlvbiAoUHJlLVJMKSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMS5yZXNlYXJjaCIsICJwcmlvcml0eSI6ICJoaWdoIiwgImxhc3RfY2hlY2tlZCI6ICIyMDI2LTAxLTI0VDA4OjM1OjAwKzAxOjAwIn0sICJjb250ZW50IjogIlRvIHByZXBhcmUgZm9yIHRoZSBSTCBBZ2VudHMgaW4gUGhhc2UgMywgd2UgbXVzdCB0cmVhdCB0aGlzIHBoYXNlIGFzIHRoZSBcIkRhdGEgQ29sbGVjdGlvblwiIHBlcmlvZC5cblxuKiAqKkludGVyYWN0aW9uIExvZ2dpbmcqKjogRXZlcnkgdXNlciBxdWVyeSBhbmQgc3Vic2VxdWVudCBzeXN0ZW0gb3V0cHV0IG11c3QgYmUgbG9nZ2VkIHRvIGEgSlNPTkwgZmlsZSBvciB0aGUgYHRlbGVtZXRyeV9sb2dgIHRhYmxlLlxuKiAqKkZvcm1hdCoqOlxuICBgYGBqc29uXG4gIHtcbiAgICBcInRpbWVzdGFtcFwiOiBcIklTTzg2MDFcIixcbiAgICBcInN0YXRlX3NuYXBzaG90XCI6IFtcImxpc3Rfb2ZfYWN0aXZlX3RhYmxlc1wiLCBcInJvd19jb3VudHNcIl0sXG4gICAgXCJhY3Rpb25fdXNlcl9xdWVyeVwiOiBcInJhd190ZXh0X2lucHV0XCIsXG4gICAgXCJzeXN0ZW1fcmVzcG9uc2VfdHlwZVwiOiBcInRhYmxlX3JlbmRlclwiLFxuICAgIFwidXNlcl9mZWVkYmFja1wiOiBudWxsXG4gIH1cbiAgYGBgXG4qICoqV2h5Kio6IFRoaXMgZGF0YXNldCB3aWxsIGJlIHVzZWQgdG8gb2ZmbGluZS10cmFpbiB0aGUgT3JjaGVzdHJhdG9yIHRvIGNsYXNzaWZ5IGludGVudCAoQW5hbHlzaXMgdnMuIENvbnRyb2wpIGJlZm9yZSB3ZSBkZXBsb3kgdGhlIGxpdmUgbW9kZWwuIiwgImNoaWxkcmVuIjogW119XX0sIHsidGl0bGUiOiAiUGhhc2UgMjogVGhlIENsb3VkIEJyaWRnZSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogImFjdGl2ZSIsICJ0eXBlIjogInBsYW4iLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UyIiwgIm93bmVyIjogInVzZXIiLCAicHJpb3JpdHkiOiAiY3JpdGljYWwiLCAiZXN0aW1hdGUiOiAiMnciLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjRUMDg6NTA6MDArMDE6MDAiLCAiYmxvY2tlZF9ieSI6IFsiaW1wbGVtZW50YXRpb24ucGhhc2UxIl19LCAiY29udGVudCI6ICJUaGlzIGRvY3VtZW50IGRldGFpbHMgdGhlIFwiQ2xvdWQgQnJpZGdlXCIgaW1wbGVtZW50YXRpb24uIFRoZSBnb2FsIGlzIHRvIGVzdGFibGlzaCBhIHNlY3VyZSwgc2NhbGFibGUgY29tbXVuaWNhdGlvbiBjaGFubmVsIGJldHdlZW4gdGhlIExvY2FsIE5leHVzIChQaGFzZSAxKSBhbmQgdGhlIENsb3VkIEFnZW50cyAoUGhhc2UgMykgdXNpbmcgdGhlIEdvb2dsZSBDbG91ZCBFY29zeXN0ZW0uXG5cbioqT2JqZWN0aXZlKio6XG4xLiAgKipJbmZyYXN0cnVjdHVyZSoqOiBQcm92aXNpb24gc2VydmVybGVzcyBjb21wdXRlIGFuZCBzdG9yYWdlIG9uIEdDUC5cbjIuICAqKkNvbm5lY3Rpdml0eSoqOiBCdWlsZCBhIHNlY3VyZSBBUEkgR2F0ZXdheSBmb3IgdGhlIGxvY2FsIGFwcCB0byBcInBob25lIGhvbWVcIi5cbjMuICAqKlN5bmNocm9uaXphdGlvbioqOiBDcmVhdGUgcGlwZWxpbmVzIHRvIG1pcnJvciBsb2NhbCBkYXRhIHRvIHRoZSBjbG91ZCBmb3IgaGVhdnkgcHJvY2Vzc2luZy5cblxuKipUZWNoIFN0YWNrKio6XG4qICAgKipDb21wdXRlKio6IEdvb2dsZSBDbG91ZCBSdW4gKFNlcnZlcmxlc3MgQ29udGFpbmVyKS5cbiogICAqKkRhdGFiYXNlKio6IEdvb2dsZSBCaWdRdWVyeSAoV2FyZWhvdXNpbmcpICYgRmlyZXN0b3JlIChOb1NRTCBNZXRhZGF0YSkuXG4qICAgKipBUEkqKjogUHl0aG9uIEZhc3RBUEkuXG4qICAgKipBdXRoKio6IEZpcmViYXNlIEF1dGhlbnRpY2F0aW9uLlxuKiAgICoqRGVwbG95bWVudCoqOiBUZXJyYWZvcm0gLyBnY2xvdWQgQ0xJICh2aWEgQW50aWdyYXZpdHkgTUNQKS4iLCAiY2hpbGRyZW4iOiBbeyJ0aXRsZSI6ICJNb2R1bGUgMTogSW5mcmFzdHJ1Y3R1cmUgSW5pdGlhbGl6YXRpb24gKEdDUCkiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIuaW5mcmEiLCAiZXN0aW1hdGUiOiAiM2QiLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjRUMDg6NTA6MDArMDE6MDAifSwgImNvbnRlbnQiOiAiUHJvdmlzaW9uIHRoZSBuZWNlc3NhcnkgR29vZ2xlIENsb3VkIHJlc291cmNlcy4gV2Ugd2lsbCBmYXZvciBcIkluZnJhc3RydWN0dXJlIGFzIENvZGVcIiBwcmFjdGljZXMuIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiUHJvamVjdCBTZXR1cCAmIEFQSSBFbmFibGVtZW50IiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UyLmluZnJhLnNldHVwIiwgInByaW9yaXR5IjogImhpZ2gifSwgImNvbnRlbnQiOiAiKiAgICoqQWN0aW9uKio6IENyZWF0ZSBhIG5ldyBHQ1AgUHJvamVjdCAoZS5nLiwgYGludGVsbGlnZW50LWNvbnRyb2wtcHJvZGApLlxuKiAgICoqRW5hYmxlIEFQSXMqKjpcbiAgICAqICAgYHJ1bi5nb29nbGVhcGlzLmNvbWAgKENsb3VkIFJ1bilcbiAgICAqICAgYGFydGlmYWN0cmVnaXN0cnkuZ29vZ2xlYXBpcy5jb21gIChEb2NrZXIgSW1hZ2VzKVxuICAgICogICBgYmlncXVlcnkuZ29vZ2xlYXBpcy5jb21gIChEYXRhIFdhcmVob3VzZSlcbiAgICAqICAgYGZpcmVzdG9yZS5nb29nbGVhcGlzLmNvbWAgKEFwcCBTdGF0ZSkiLCAiY2hpbGRyZW4iOiBbXX0sIHsidGl0bGUiOiAiSWFDICYgRGVwbG95bWVudCBXb3JrZmxvdyIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMi5pbmZyYS5pYWMiLCAiYmxvY2tlZF9ieSI6IFsiaW1wbGVtZW50YXRpb24ucGhhc2UyLmluZnJhLnNldHVwIl19LCAiY29udGVudCI6ICJEZWZpbmUgdGhlIGluZnJhc3RydWN0dXJlIHVzaW5nIFRlcnJhZm9ybSBvciBzY3JpcHRhYmxlIGBnY2xvdWRgIGNvbW1hbmRzLlxuKiAgICoqV29ya2Zsb3cqKjpcbiAgICAxLiAgVXNlciBwcm9tcHRzIEFudGlncmF2aXR5IHRvIFwiRGVwbG95IEluZnJhc3RydWN0dXJlXCIuXG4gICAgMi4gIEFudGlncmF2aXR5IHVzZXMgdGhlIHRlcm1pbmFsIHRvb2wgKG9yIGBnY2xvdWRgIE1DUCkgdG8gZXhlY3V0ZSB0aGUgcHJvdmlzaW9uaW5nIHNjcmlwdHMuXG4gICAgMy4gIE91dHB1dHMgKFNlcnZpY2UgVVJMcywgQnVja2V0IE5hbWVzKSBhcmUgc2F2ZWQgdG8gYGRlcGxveW1lbnRfY29uZmlnLmpzb25gLiIsICJjaGlsZHJlbiI6IFtdfV19LCB7InRpdGxlIjogIk1vZHVsZSAyOiBBdXRoZW50aWNhdGlvbiAmIFNlY3VyaXR5IiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UyLmF1dGgiLCAiYmxvY2tlZF9ieSI6IFsiaW1wbGVtZW50YXRpb24ucGhhc2UyLmluZnJhIl0sICJlc3RpbWF0ZSI6ICIxdyIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yNFQwODo1MDowMCswMTowMCJ9LCAiY29udGVudCI6ICJTZWN1cmUgdGhlIGJyaWRnZS4gVGhlIExvY2FsIEFwcCBtdXN0IGF1dGhlbnRpY2F0ZSBiZWZvcmUgc2VuZGluZyBkYXRhLiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIklkZW50aXR5IE1hbmFnZW1lbnQgKEZpcmViYXNlKSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMi5hdXRoLmZpcmViYXNlIn0sICJjb250ZW50IjogIiogICAqKlNldHVwKio6IEluaXRpYWxpemUgYSBGaXJlYmFzZSBwcm9qZWN0IGxpbmtlZCB0byB0aGUgR0NQIHByb2plY3QuXG4qICAgKipDbGllbnQqKjogSW50ZWdyYXRlIGBmaXJlYmFzZS1hZG1pbmAgaW4gdGhlIENsb3VkIEFQSSBhbmQgdGhlIEpTL1B5dGhvbiBTREsgaW4gdGhlIExvY2FsIEFwcC5cbiogICAqKkZsb3cqKjpcbiAgICAxLiAgTG9jYWwgVXNlciBsb2dzIGluLlxuICAgIDIuICBMb2NhbCBBcHAgZ2V0cyBKV1QgVG9rZW4uXG4gICAgMy4gIEFQSSBHYXRld2F5IHZlcmlmaWVzIEpXVCBUb2tlbiBvbiBldmVyeSByZXF1ZXN0LiIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJTZXJ2aWNlIFNlY3VyaXR5IiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UyLmF1dGguaWFtIn0sICJjb250ZW50IjogIiogICAqKlNlcnZpY2UgQWNjb3VudHMqKjogQ3JlYXRlIGEgc3BlY2lmaWMgU2VydmljZSBBY2NvdW50IGZvciB0aGUgQ2xvdWQgUnVuIGluc3RhbmNlLlxuKiAgICoqUGVybWlzc2lvbnMqKjogR3JhbnQgc3RyaWN0bHkgbmVjZXNzYXJ5IHJvbGVzIChlLmcuLCBgcm9sZXMvYmlncXVlcnkuZGF0YUVkaXRvcmAsIGByb2xlcy9zdG9yYWdlLm9iamVjdENyZWF0b3JgKS4gKipEbyBub3QgdXNlIE93bmVyIHJvbGUuKioiLCAiY2hpbGRyZW4iOiBbXX1dfSwgeyJ0aXRsZSI6ICJNb2R1bGUgMzogVGhlIEFQSSBHYXRld2F5IChDb25uZWN0b3IpIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UyLmFwaSIsICJibG9ja2VkX2J5IjogWyJpbXBsZW1lbnRhdGlvbi5waGFzZTIuYXV0aCJdLCAiZXN0aW1hdGUiOiAiMXciLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjRUMDg6NTA6MDArMDE6MDAifSwgImNvbnRlbnQiOiAiRGV2ZWxvcCBhbmQgZGVwbG95IHRoZSBjZW50cmFsIFJFU1QgQVBJLiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIlNlcnZpY2UgU2tlbGV0b24gKEZhc3RBUEkpIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UyLmFwaS5kZXYifSwgImNvbnRlbnQiOiAiQ3JlYXRlIGBzcmMvY2xvdWQvbWFpbi5weWAuXG4qICAgKipFbmRwb2ludHMqKjpcbiAgICAqICAgYFBPU1QgL3YxL3RlbGVtZXRyeWA6IEFjY2VwdHMgSlNPTiBwYXlsb2FkcyBvZiB1c2VyIGludGVyYWN0aW9ucy5cbiAgICAqICAgYFBPU1QgL3YxL2FnZW50L3Rhc2tgOiBTdWJtaXRzIGEgY29tcGxleCB0YXNrIGZvciB0aGUgQ2xvdWQgQWdlbnRzLlxuICAgICogICBgR0VUIC92MS9hZ2VudC9zdGF0dXMve3Rhc2tfaWR9YDogUG9sbGluZyBlbmRwb2ludCBmb3IgbG9uZy1ydW5uaW5nIGpvYnMuIiwgImNoaWxkcmVuIjogW119LCB7InRpdGxlIjogIkNvbnRhaW5lcml6YXRpb24gJiBEZXBsb3kiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIuYXBpLmRlcGxveSIsICJibG9ja2VkX2J5IjogWyJpbXBsZW1lbnRhdGlvbi5waGFzZTIuYXBpLmRldiJdfSwgImNvbnRlbnQiOiAiKiAgICoqRG9ja2VyKio6IENyZWF0ZSBgRG9ja2VyZmlsZWAgb3B0aW1pemVkIGZvciBQeXRob24gKG11bHRpLXN0YWdlIGJ1aWxkKS5cbiogICAqKkNJL0NEKio6IERlZmluZSBhIHNpbXBsZSBkZXBsb3ltZW50IHNjcmlwdDogYGdjbG91ZCBydW4gZGVwbG95IC0tc291cmNlIC5gLiIsICJjaGlsZHJlbiI6IFtdfV19LCB7InRpdGxlIjogIk1vZHVsZSA0OiBEYXRhIFN5bmNocm9uaXphdGlvbiBQaXBlbGluZSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMi5waXBlbGluZSIsICJibG9ja2VkX2J5IjogWyJpbXBsZW1lbnRhdGlvbi5waGFzZTIuYXBpIl0sICJlc3RpbWF0ZSI6ICIxdyIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yNFQwODo1MDowMCswMTowMCJ9LCAiY29udGVudCI6ICJNZWNoYW5pc21zIHRvIG1vdmUgbGFyZ2UgZGF0YXNldHMgZnJvbSBMb2NhbCBEdWNrREIgdG8gQ2xvdWQgQmlnUXVlcnkuIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiQmxvYiBTdG9yYWdlIEluZ3Jlc3MiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIucGlwZWxpbmUuZ2NzIn0sICJjb250ZW50IjogIkZvciByYXcgZmlsZXMgKENTVi9FeGNlbCkgdGhhdCBhcmUgdG9vIGxhcmdlIGZvciBKU09OIHBheWxvYWRzLlxuKiAgICoqTWVjaGFuaXNtKio6IExvY2FsIEFwcCByZXF1ZXN0cyBhIFNpZ25lZCBVcGxvYWQgVVJMIGZyb20gdGhlIEFQSS5cbiogICAqKkFjdGlvbioqOiBMb2NhbCBBcHAgUFVUcyB0aGUgZmlsZSBkaXJlY3RseSB0byBhIEdDUyBCdWNrZXQgKGByYXctZGF0YS1pbmdyZXNzYCkuIiwgImNoaWxkcmVuIjogW119LCB7InRpdGxlIjogIldhcmVob3VzZSBTeW5jIChCaWdRdWVyeSkiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIucGlwZWxpbmUuYmlncXVlcnkiLCAiYmxvY2tlZF9ieSI6IFsiaW1wbGVtZW50YXRpb24ucGhhc2UyLnBpcGVsaW5lLmdjcyJdfSwgImNvbnRlbnQiOiAiKiAgICoqU2NoZW1hIE1hcHBpbmcqKjogTWFwIER1Y2tEQiB0eXBlcyB0byBCaWdRdWVyeSB0eXBlcy5cbiogICAqKlZhbGlkYXRpb24qKjogQ2hlY2sgaW5jb21pbmcgc2NoZW1hIGFnYWluc3QgZXhpc3RpbmcgQmlnUXVlcnkgc2NoZW1hIHRvIHJlamVjdCBicmVha2luZyBjaGFuZ2VzIChTY2hlbWEgRHJpZnQgZGVmZW5zZSkuXG4qICAgKipUcmlnZ2VyKio6IFdoZW4gYSBmaWxlIGxhbmRzIGluIEdDUywgYSBDbG91ZCBFdmVudCB0cmlnZ2VycyBhIFwiTG9hZGVyXCIgZnVuY3Rpb24gKG9yIHRoZSBBUEkgaXRzZWxmKSB0byBsb2FkIHRoZSBDU1YgaW50byBCaWdRdWVyeS4iLCAiY2hpbGRyZW4iOiBbXX1dfV19LCB7InRpdGxlIjogIlBoYXNlIDM6IFRoZSBDbG91ZCBBZ2VudHMiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAicGxhbiIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTMiLCAib3duZXIiOiAidXNlciIsICJwcmlvcml0eSI6ICJjcml0aWNhbCIsICJlc3RpbWF0ZSI6ICI2dyIsICJibG9ja2VkX2J5IjogWyJpbXBsZW1lbnRhdGlvbi5waGFzZTIiXX0sICJjb250ZW50IjogIlRoaXMgZG9jdW1lbnQgZGV0YWlscyB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIFwiQnJhaW5cIiBvZiB0aGUgSW50ZWxsaWdlbnQgQ29udHJvbCBTYWFTOiBhIG11bHRpLWFnZW50IHN5c3RlbSBidWlsdCB1c2luZyB0aGUgKipHb29nbGUgQWdlbnQgRGV2ZWxvcG1lbnQgS2l0IChBREspKiouXG5cbioqT2JqZWN0aXZlKio6IERlcGxveSBhIHJvYnVzdCwgb2JzZXJ2YWJsZSwgYW5kIHNjYWxhYmxlIGFnZW50IGVjb3N5c3RlbSBoYW5kbGluZzpcbjEuICAqKkFuYWx5c2lzKio6IFB5dGhvbi1iYXNlZCBkYXRhIHNjaWVuY2UgYW5kIHZpc3VhbGl6YXRpb24uXG4yLiAgKipDb250cm9sKio6IFJML0NvbnRyb2wtdGhlb3J5IG9wdGltaXphdGlvbiB1c2luZyBhIGN1c3RvbSBhbGdvcml0aG0gcmVwb3NpdG9yeS5cbjMuICAqKk9yY2hlc3RyYXRpb24qKjogSW50ZWxsaWdlbnQgcm91dGluZyBhbmQgc3RhdGUgbWFuYWdlbWVudC5cblxuKipUZWNoIFN0YWNrKio6XG4qICAgKipGcmFtZXdvcmsqKjogR29vZ2xlIEFESyAoUHl0aG9uIFNESykuXG4qICAgKipNb2RlbCoqOiBHZW1pbmkgMS41IFBybyAodmlhIFZlcnRleCBBSSkuXG4qICAgKipSdW50aW1lKio6IENsb3VkIFJ1biAoQ29udGFpbmVyaXplZCBBZ2VudHMpLlxuKiAgICoqRXZhbHVhdGlvbioqOiBWZXJ0ZXggQUkgR2VuIEFJIEV2YWx1YXRpb24gU2VydmljZS4iLCAiY2hpbGRyZW4iOiBbeyJ0aXRsZSI6ICJBcmNoaXRlY3R1cmU6IFRoZSBBREsgRWNvc3lzdGVtIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInBsYW4iLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UzLmFyY2giLCAiZXN0aW1hdGUiOiAiMXcifSwgImNvbnRlbnQiOiAiV2Ugd2lsbCBsZXZlcmFnZSBBREsncyBwYXR0ZXJuIGZvciBjb21wb3NhYmxlIGFnZW50cy4gVGhlIHN5c3RlbSB3aWxsIGNvbnNpc3Qgb2YgYSB0b3AtbGV2ZWwgKipDb29yZGluYXRvciBBZ2VudCoqIGFuZCB0d28gc3BlY2lhbGl6ZWQgd29ya2VyIGFnZW50cy4iLCAiY2hpbGRyZW4iOiBbeyJ0aXRsZSI6ICJUaGUgQ29vcmRpbmF0b3IgUGF0dGVybiIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJwcm90b2NvbCIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTMuYXJjaC5jb29yZGluYXRvciJ9LCAiY29udGVudCI6ICJJbnN0ZWFkIG9mIGEgbW9ub2xpdGhpYyBjaGFpbiwgd2UgdXNlIGEgY2VudHJhbCBgTGxtQWdlbnRgIGFjdGluZyBhcyBhIHJvdXRlci5cbiogICAqKklucHV0Kio6IE5hdHVyYWwgbGFuZ3VhZ2UgdXNlciBxdWVyaWVzICsgU3RhdGUgQ29udGV4dCAoZnJvbSBQaGFzZSAyKS5cbiogICAqKkRlY2lzaW9uKio6IFVzZXMgYSBgY2xhc3NpZnlfaW50ZW50YCB0b29sIG9yIGZldy1zaG90IHByb21wdGluZyB0byBkZWNpZGU6XG4gICAgKiAgIGBBTkFMWVNJU19SRVFVSVJFRGAgLT4gRGVsZWdhdGUgdG8gQW5hbHlzdCBBZ2VudC5cbiAgICAqICAgYENPTlRST0xfUkVRVUlSRURgIC0+IERlbGVnYXRlIHRvIENvbnRyb2xsZXIgQWdlbnQuXG4gICAgKiAgIGBBTUJJR1VPVVNgIC0+IEFzayBjbGFyaWZ5aW5nIHF1ZXN0aW9ucy5cbiogICAqKk91dHB1dCoqOiBBZ2dyZWdhdGVzIHJlc3BvbnNlcyBmcm9tIHdvcmtlcnMgYW5kIGZvcm1hdHMgdGhlIGZpbmFsIGFuc3dlciBmb3IgdGhlIHVzZXIuIiwgImNoaWxkcmVuIjogW119XX0sIHsidGl0bGUiOiAiTW9kdWxlIDE6IFRoZSBBbmFseXN0IEFnZW50IChEYXRhIFNjaWVudGlzdCkiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTMuYW5hbHlzdCIsICJibG9ja2VkX2J5IjogWyJpbXBsZW1lbnRhdGlvbi5waGFzZTMuYXJjaCJdLCAiZXN0aW1hdGUiOiAiMncifSwgImNvbnRlbnQiOiAiKipSb2xlKio6IFwiV2h5IGlzIHRoaXMgaGFwcGVuaW5nP1wiXG4qKlRvb2xzKio6IENvZGUgRXhlY3V0aW9uLCBEYXRhIFZpc3VhbGl6YXRpb24uIiwgImNoaWxkcmVuIjogW3sidGl0bGUiOiAiRGF0YSBTY2llbmNlIFRvb2wgUmVwb3NpdG9yeSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMy5hbmFseXN0LnJlcG8ifSwgImNvbnRlbnQiOiAiV2Ugd2lsbCBidWlsZCBhIGRlZGljYXRlZCBQeXRob24gbGlicmFyeSAoYHNyYy9saWJfYW5hbHlzaXNgKSB0aGF0IHRoZSBhZ2VudCBsZWFybnMgdG8gdXNlLlxuKiAgICoqU3RydWN0dXJlKio6XG4gICAgYGBgcHl0aG9uXG4gICAgL3NyYy9saWJfYW5hbHlzaXNcbiAgICAgICAvdmlzdWFsaXplLnB5ICAgIyBIaWdoLWxldmVsIHBsb3Qgd3JhcHBlcnMgKHBsb3RfdGltZV9zZXJpZXMsIHBsb3RfZGlzdHJpYnV0aW9uKVxuICAgICAgIC9zdGF0cy5weSAgICAgICAjIEh5cG90aGVzaXMgdGVzdGluZyAoYW5vdmEsIHRfdGVzdClcbiAgICAgICAvY2xlYW4ucHkgICAgICAgIyBBdXRvLWNsZWFuaW5nIHV0aWxpdGllc1xuICAgIGBgYFxuKiAgICoqSW50ZWdyYXRpb24qKjpcbiAgICAqICAgRXhwb3NlIHRoZXNlIGZ1bmN0aW9ucyBhcyAqKkFESyBUb29scyoqLlxuICAgICogICBVc2UgdHlwZSBoaW50cyBhbmQgZG9jc3RyaW5ncyBoZWF2aWx5LCBhcyBBREsgdXNlcyB0aGVzZSBmb3IgdG9vbCBkZWZpbml0aW9uIHZlcmlmaWNhdGlvbi4iLCAiY2hpbGRyZW4iOiBbXX0sIHsidGl0bGUiOiAiQ29kZSBFeGVjdXRpb24gU2FuZGJveCIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMy5hbmFseXN0LnNhbmRib3gifSwgImNvbnRlbnQiOiAiKiAgICoqTWVjaGFuaXNtKio6IFRoZSBhZ2VudCB3cml0ZXMgY29kZSB0aGF0IGltcG9ydHMgYGxpYl9hbmFseXNpc2AuXG4qICAgKipTZWN1cml0eSoqOiBVc2UgQURLJ3MgYENvZGVFeGVjdXRpb25Ub29sYCBjb25maWd1cmVkIHdpdGggYSByZXN0cmljdGVkIGVudmlyb25tZW50IChvciBFMkIgaW50ZWdyYXRpb24gaWYgQURLIG5hdGl2ZSBzdXBwb3J0IGlzIGluc3VmZmljaWVudCkuXG4qICAgKipPdXRwdXQgSGFuZGxpbmcqKjogQ2FwdHVyZSBgc3Rkb3V0YCAodGV4dCkgYW5kIGdlbmVyYXRlZCBhcnRpZmFjdHMgKFBORy9KU09OKSB0byBwYXNzIGJhY2sgdG8gdGhlIENvb3JkaW5hdG9yLiIsICJjaGlsZHJlbiI6IFtdfV19LCB7InRpdGxlIjogIk1vZHVsZSAyOiBUaGUgQ29udHJvbGxlciBBZ2VudCAoT3B0aW1pemVyKSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMy5jb250cm9sbGVyIiwgImJsb2NrZWRfYnkiOiBbImltcGxlbWVudGF0aW9uLnBoYXNlMy5hbmFseXN0Il0sICJlc3RpbWF0ZSI6ICIydyJ9LCAiY29udGVudCI6ICIqKlJvbGUqKjogXCJPcHRpbWl6ZSBmb3IgWC5cIlxuKipUb29scyoqOiBPcHRpbWl6YXRpb24gQWxnb3JpdGhtcywgU2ltdWxhdGlvbi4iLCAiY2hpbGRyZW4iOiBbeyJ0aXRsZSI6ICJDb250cm9sIEFsZ29yaXRobXMgSW50ZWdyYXRpb24iLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAidGFzayIsICJpZCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTMuY29udHJvbGxlci5pbnRlZ3JhdGlvbiJ9LCAiY29udGVudCI6ICJJbnRlZ3JhdGUgdGhlIGV4dGVybmFsIHJlcG9zaXRvcnkgW2NvbnRyb2xfYWxnb3JpdGhtc10oaHR0cHM6Ly9naXRodWIuY29tL0lnbmFjaW9PUS9jb250cm9sX2FsZ29yaXRobXMpLlxuKiAgICoqU3RlcCAxKio6IFN1Ym1vZHVsZSBvciBQYWNrYWdlIGludGVncmF0aW9uIG9mIHRoZSB1c2VyJ3MgcmVwb3NpdG9yeS5cbiogICAqKlN0ZXAgMioqOiBDcmVhdGUgYW4gKipBREsgVG9vbCBXcmFwcGVyKiogKGBzcmMvdG9vbHMvY29udHJvbF90b29scy5weWApIHRoYXQgZXhwb3NlcyBrZXkgYWxnb3JpdGhtcyBhcyBjYWxsYWJsZSBmdW5jdGlvbnM6XG4gICAgKiAgIGBydW5fbXBjX29wdGltaXphdGlvbihzdGF0ZV92ZWN0b3IsIGNvbnN0cmFpbnRzKWBcbiAgICAqICAgYHNvbHZlX25ld3N2ZW5kb3IoZGVtYW5kX2Rpc3QsIGNvc3RzKWBcbiAgICAqICAgYHNpbXVsYXRlX3NjZW5hcmlvKGluaXRpYWxfc3RhdGUsIGhvcml6b24pYFxuKiAgICoqU3RlcCAzKio6IERlZmluZSB0aGUgXCJTdGF0ZSBTY2hlbWFcIi4gVGhlIEFnZW50IG11c3Qga25vdyBob3cgdG8gbWFwIHRoZSByYXcgdGVsZW1ldHJ5IChmcm9tIEJpZ1F1ZXJ5L1BoYXNlIDIpIGludG8gdGhlIGlucHV0cyByZXF1aXJlZCBieSB0aGVzZSBhbGdvcml0aG1zLiIsICJjaGlsZHJlbiI6IFtdfV19LCB7InRpdGxlIjogIk1vZHVsZSAzOiBBZ2VudCBEZXZlbG9wbWVudCAmIE9wcyAoQURLKSIsICJtZXRhZGF0YSI6IHsic3RhdHVzIjogInRvZG8iLCAidHlwZSI6ICJ0YXNrIiwgImlkIjogImltcGxlbWVudGF0aW9uLnBoYXNlMy5vcHMiLCAiYmxvY2tlZF9ieSI6IFsiaW1wbGVtZW50YXRpb24ucGhhc2UzLmNvbnRyb2xsZXIiXSwgImVzdGltYXRlIjogIjF3In0sICJjb250ZW50IjogIkVzdGFibGlzaCB0aGUgbGlmZWN5Y2xlIGZvciBkZXZlbG9waW5nIGFuZCBpbXByb3ZpbmcgdGhlc2UgYWdlbnRzLiIsICJjaGlsZHJlbiI6IFt7InRpdGxlIjogIkV2YWx1YXRpb24gUGlwZWxpbmUgKEdlbkFJIEV2YWwpIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UzLm9wcy5ldmFsIn0sICJjb250ZW50IjogIlVzZSBHb29nbGUncyBHZW4gQUkgRXZhbHVhdGlvbiBTZXJ2aWNlIHRvIG1vdmUgYmV5b25kIFwidmliZXMtYmFzZWRcIiB0ZXN0aW5nLlxuKiAgICoqVHJhamVjdG9yeSBFdmFsdWF0aW9uKio6IGNoZWNrIGlmIHRoZSBBbmFseXN0IEFnZW50ICphY3R1YWxseSogdXNlZCB0aGUgYHZpc3VhbGl6ZS5weWAgdG9vbCBvciBpZiBpdCB0cmllZCB0byBoYWxsdWNpbmF0ZSBhIHBsb3QuXG4qICAgKipHb2xkZW4gRGF0YXNldHMqKjogQ3JlYXRlIGEgc2V0IG9mIChRdWVyeSwgRXhwZWN0ZWRfVG9vbF9DYWxsLCBFeHBlY3RlZF9PdXRjb21lKSB0dXBsZXMuXG4qICAgKipDSS9DRCoqOiBSdW4gYGFkayBldmFsYCBhcyBwYXJ0IG9mIHRoZSBkZXBsb3ltZW50IHBpcGVsaW5lLiIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJEZXBsb3ltZW50IChWZXJ0ZXggQUkpIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInRhc2siLCAiaWQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UzLm9wcy5kZXBsb3kifSwgImNvbnRlbnQiOiAiKiAgICoqQ29udGFpbmVyaXplKio6IFdyYXAgdGhlIEFESyBhZ2VudCBzZXJ2ZXIgaW4gYSBEb2NrZXIgY29udGFpbmVyLlxuKiAgICoqRGVwbG95Kio6IFB1c2ggdG8gQ2xvdWQgUnVuLlxuKiAgICoqRXhwb3NlKio6IENvbm5lY3QgdGhlIENsb3VkIFJ1biBlbmRwb2ludCB0byB0aGUgQVBJIEdhdGV3YXkgY3JlYXRlZCBpbiBQaGFzZSAyLiIsICJjaGlsZHJlbiI6IFtdfV19XX1dfSwgeyJ0aXRsZSI6ICJDb21tZXJjaWFsIFN0cmF0ZWd5IiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAicGxhbiIsICJpZCI6ICJwcm9kdWN0LnNhYXMuY29tbWVyY2lhbCIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yNFQwOTo0MDo1NSswMTowMCJ9LCAiY29udGVudCI6ICJUaGlzIHNlY3Rpb24gb3V0bGluZXMgdGhlIHN0cmF0ZWd5IGZvciBtb25ldGl6YXRpb24sIHVzZXIgYWNxdWlzaXRpb24sIGFuZCBtYXJrZXQgdmFsaWRhdGlvbi4iLCAiY2hpbGRyZW4iOiBbeyJ0aXRsZSI6ICJGcm9udGxpbmUgVHJpYWxzIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInBsYW4iLCAiaWQiOiAicHJvZHVjdC5zYWFzLmNvbW1lcmNpYWwuZnJvbnRsaW5lIiwgImVzdGltYXRlIjogIjR3In0sICJjb250ZW50IjogIioqT2JqZWN0aXZlKio6IFZhbGlkYXRlIHRoZSBwcm9kdWN0IHZhbHVlIHByb3Bvc2l0aW9uIHdpdGggcmVhbCB1c2VycyBpbiBhIGxvdy1zdGFrZXMgZW52aXJvbm1lbnQuXG4qICAgKipBcHByb2FjaCoqOiBcIkRvIHRoaW5ncyB0aGF0IGRvbid0IHNjYWxlLlwiIERpcmVjdCBvdXRyZWFjaCB0byBmcmllbmRseSBTTUJzIChSZXRhaWwvTG9naXN0aWNzKS5cbiogICAqKkdvYWwqKjogNS0xMCBhY3RpdmUgdXNlcnMgcHJvdmlkaW5nIHdlZWtseSBmZWVkYmFjay5cbiogICAqKk1vbmV0aXphdGlvbioqOiBGcmVlIG9yIGhlYXZpbHkgZGlzY291bnRlZCBpbiBleGNoYW5nZSBmb3IgZmVlZGJhY2svdGVzdGltb25pYWxzLlxuKiAgICoqTWV0cmljcyoqOiBFbmdhZ2VtZW50IChEYWlseSBBY3RpdmUgVXNlcnMpLCBcIk1hZ2ljIE1vbWVudHNcIiAoZS5nLiwgXCJUaGlzIHNhdmVkIG1lIDIgaG91cnNcIikuIiwgImNoaWxkcmVuIjogW119LCB7InRpdGxlIjogIlBheW1lbnQgU2NoZW1hIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAidG9kbyIsICJ0eXBlIjogInBsYW4iLCAiaWQiOiAicHJvZHVjdC5zYWFzLmNvbW1lcmNpYWwucGF5bWVudCIsICJibG9ja2VkX2J5IjogWyJwcm9kdWN0LnNhYXMuY29tbWVyY2lhbC5mcm9udGxpbmUiXSwgImVzdGltYXRlIjogIjJ3In0sICJjb250ZW50IjogIioqT2JqZWN0aXZlKio6IEJ1aWxkIHRoZSBpbmZyYXN0cnVjdHVyZSB0byBjYXB0dXJlIHZhbHVlLlxuKiAgICoqVGVjaCoqOiBTdHJpcGUgLyBMZW1vbiBTcXVlZXp5IGludGVncmF0aW9uLlxuKiAgICoqTW9kZWxzKio6XG4gICAgKiAgICoqRnJlZW1pdW0qKjogTG9jYWwtb25seSBmZWF0dXJlcyBhcmUgZnJlZS5cbiAgICAqICAgKipQcm8gKCQyOS9tbykqKjogQ2xvdWQgc3luYyArIGJhc2ljIEFuYWx5c3QgQWdlbnQgdXNhZ2UgKHRva2VuIGNhcHBlZCkuXG4gICAgKiAgICoqRW50ZXJwcmlzZSAoQ3VzdG9tKSoqOiBGdWxsIENvbnRyb2xsZXIgQWdlbnQgYWNjZXNzICsgZGVkaWNhdGVkIHN1cHBvcnQuXG4qICAgKipEZWxpdmVyYWJsZSoqOiBBIHNlYW1sZXNzIFwiVXBncmFkZVwiIGZsb3cgd2l0aGluIHRoZSBTdHJlYW1saXQgYXBwLiIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJNYXJrZXRpbmcgJiBHcm93dGgiLCAibWV0YWRhdGEiOiB7InN0YXR1cyI6ICJ0b2RvIiwgInR5cGUiOiAicGxhbiIsICJpZCI6ICJwcm9kdWN0LnNhYXMuY29tbWVyY2lhbC5tYXJrZXRpbmciLCAiYmxvY2tlZF9ieSI6IFsicHJvZHVjdC5zYWFzLmNvbW1lcmNpYWwucGF5bWVudCJdfSwgImNvbnRlbnQiOiAiKipPYmplY3RpdmUqKjogU2NhbGUgYXdhcmVuZXNzIGFuZCBhY3F1aXNpdGlvbi5cbiogICAqKkNvbnRlbnQgTWFya2V0aW5nKio6IEJsb2cgcG9zdHMvVmlkZW9zIGRlbW9uc3RyYXRpbmcgXCJEYXRhIFNjaWVuY2UgZm9yIE5vbi1EYXRhIFNjaWVudGlzdHNcIiB1c2luZyBvdXIgYXBwLlxuKiAgICoqT3V0cmVhY2gqKjogVGFyZ2V0ZWQgTGlua2VkSW4gb3V0cmVhY2ggdG8gT3BlcmF0aW9ucyBNYW5hZ2VycyBpbiBMb2dpc3RpY3MvUmV0YWlsLlxuKiAgICoqQ2hhbm5lbHMqKjpcbiAgICAqICAgKipPcmdhbmljKio6IFNFTywgR2l0SHViIChPcGVuIFNvdXJjZSBjb3JlPykuXG4gICAgKiAgICoqUGFpZCoqOiBUYXJnZXRlZCBhZHMgb24gbmljaGUgaW5kdXN0cnkgZm9ydW1zIChsYXRlciBzdGFnZSkuIiwgImNoaWxkcmVuIjogW119XX0sIHsidGl0bGUiOiAiU2VjdXJpdHkgJiBTYWZldHkgQ2hlY2tzIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAiZ3VpZGVsaW5lIiwgImlkIjogInByb2R1Y3Quc2Fhcy5zZWN1cml0eSIsICJsYXN0X2NoZWNrZWQiOiAiMjAyNi0wMS0yM1QxMzo0NzowNyswMTowMCJ9LCAiY29udGVudCI6ICItICAgKipJbmRpcmVjdCBFeGVjdXRpb24qKjogQ2xpZW50cyBvbmx5IHN1Ym1pdCBuYXR1cmFsIGxhbmd1YWdlLCBuZXZlciBjb2RlLlxuLSAgICoqUmVwb3NpdG9yeSBTY29waW5nKio6IEdlbmVyYXRlZCBjb2RlIGNhbiBvbmx5IGltcG9ydCB3aGl0ZWxpc3RlZCBsaWJyYXJpZXMgKGBwYW5kYXNgLCBgbnVtcHlgLCBgbGliX2FuYWx5c2lzYCkuIE5vIGBvc2Agb3IgYHN5c2AuXG4tICAgKipTaW11bGF0aW9uIElzb2xhdGlvbioqOiBVc2VyLXByb3ZpZGVkIGxvZ2ljIHJ1bnMgaW4gYGdWaXNvcmAgc2FuZGJveGVzLlxuLSAgICoqQWN0aW9uIEJvdW5kaW5nKio6IERldGVybWluaXN0aWMgbG9naWMgbGF5ZXIgdmFsaWRhdGVzIGFjdGlvbnMgYWdhaW5zdCBzYWZldHkgY29uc3RyYWludHMgKGUuZy4sIGBNQVhfT1JERVJfTElNSVRgKSBiZWZvcmUgZXhlY3V0aW9uLiIsICJjaGlsZHJlbiI6IFtdfSwgeyJ0aXRsZSI6ICJSZXNlYXJjaCBEaXJlY3Rpb25zIiwgIm1ldGFkYXRhIjogeyJzdGF0dXMiOiAiYWN0aXZlIiwgInR5cGUiOiAicGxhbiIsICJpZCI6ICJwcm9kdWN0LnNhYXMucmVzZWFyY2giLCAibGFzdF9jaGVja2VkIjogIjIwMjYtMDEtMjNUMTM6NDc6MDcrMDE6MDAifSwgImNvbnRlbnQiOiAiLSAgICoqTUJSTCAoRHJlYW1lclYzKSoqOiBMZWFybmluZyBXb3JsZCBNb2RlbHMgZnJvbSB0ZWxlbWV0cnkgdG8gc2ltdWxhdGUgZW52aXJvbm1lbnRzLlxuLSAgICoqU2FmZSBSTCoqOiBDb25zdHJhaW5lZCBNRFBzIChMYWdyYW5naWFuIFJlbGF4YXRpb24pIHRvIGVuc3VyZSBzYWZldHkgZHVyaW5nIGV4cGxvcmF0aW9uLlxuLSAgICoqUmVmbGV4aW9uKio6IEFnZW50cyB0aGF0IGFuYWx5emUgdGhlaXIgb3duIHRyYWNlYmFja3MgdG8gaXRlcmF0aXZlbHkgZml4IGNvZGUuIiwgImNoaWxkcmVuIjogW119XX0sICJkZXBlbmRlbmNpZXMiOiBbeyJzb3VyY2UiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLmluaXQiLCAidGFyZ2V0IjogImltcGxlbWVudGF0aW9uLnBoYXNlMS53YXJlaG91c2UifSwgeyJzb3VyY2UiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLndhcmVob3VzZS5tYW5hZ2VyIiwgInRhcmdldCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTEud2FyZWhvdXNlLmluZ2VzdCJ9LCB7InNvdXJjZSI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTEud2FyZWhvdXNlIiwgInRhcmdldCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTEudWkifSwgeyJzb3VyY2UiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLnVpLmxheW91dCIsICJ0YXJnZXQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLnVpLmNoYXQifSwgeyJzb3VyY2UiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLnVpIiwgInRhcmdldCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTEudGVzdGluZyJ9LCB7InNvdXJjZSI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTEudGVzdGluZy51bml0IiwgInRhcmdldCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTEudGVzdGluZy5pbnRlZ3JhdGlvbiJ9LCB7InNvdXJjZSI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTEudGVzdGluZyIsICJ0YXJnZXQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UxLnBhY2thZ2luZyJ9LCB7InNvdXJjZSI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTEiLCAidGFyZ2V0IjogImltcGxlbWVudGF0aW9uLnBoYXNlMiJ9LCB7InNvdXJjZSI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIuaW5mcmEuc2V0dXAiLCAidGFyZ2V0IjogImltcGxlbWVudGF0aW9uLnBoYXNlMi5pbmZyYS5pYWMifSwgeyJzb3VyY2UiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UyLmluZnJhIiwgInRhcmdldCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIuYXV0aCJ9LCB7InNvdXJjZSI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIuYXV0aCIsICJ0YXJnZXQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UyLmFwaSJ9LCB7InNvdXJjZSI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIuYXBpLmRldiIsICJ0YXJnZXQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UyLmFwaS5kZXBsb3kifSwgeyJzb3VyY2UiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UyLmFwaSIsICJ0YXJnZXQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UyLnBpcGVsaW5lIn0sIHsic291cmNlIjogImltcGxlbWVudGF0aW9uLnBoYXNlMi5waXBlbGluZS5nY3MiLCAidGFyZ2V0IjogImltcGxlbWVudGF0aW9uLnBoYXNlMi5waXBlbGluZS5iaWdxdWVyeSJ9LCB7InNvdXJjZSI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTIiLCAidGFyZ2V0IjogImltcGxlbWVudGF0aW9uLnBoYXNlMyJ9LCB7InNvdXJjZSI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTMuYXJjaCIsICJ0YXJnZXQiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UzLmFuYWx5c3QifSwgeyJzb3VyY2UiOiAiaW1wbGVtZW50YXRpb24ucGhhc2UzLmFuYWx5c3QiLCAidGFyZ2V0IjogImltcGxlbWVudGF0aW9uLnBoYXNlMy5jb250cm9sbGVyIn0sIHsic291cmNlIjogImltcGxlbWVudGF0aW9uLnBoYXNlMy5jb250cm9sbGVyIiwgInRhcmdldCI6ICJpbXBsZW1lbnRhdGlvbi5waGFzZTMub3BzIn0sIHsic291cmNlIjogInByb2R1Y3Quc2Fhcy5jb21tZXJjaWFsLmZyb250bGluZSIsICJ0YXJnZXQiOiAicHJvZHVjdC5zYWFzLmNvbW1lcmNpYWwucGF5bWVudCJ9LCB7InNvdXJjZSI6ICJwcm9kdWN0LnNhYXMuY29tbWVyY2lhbC5wYXltZW50IiwgInRhcmdldCI6ICJwcm9kdWN0LnNhYXMuY29tbWVyY2lhbC5tYXJrZXRpbmcifV19";
    if (rawData.startsWith("__DATA")) {
        log("Error: Placeholder not replaced.");
    } else {
        const data = decodeData(rawData);
        if (data && typeof d3 !== 'undefined') {
            log("D3 loaded. Version: " + d3.version);
            document.getElementById('loading').style.display = 'none';
            parsedData = data.tree ? data : { tree: data, dependencies: [] }; // Handle legacy format if needed
            initViz(parsedData);
        } else {
            if (typeof d3 === 'undefined') {
                handleScriptError();
            } else {
                log("Error: Data is null.");
            }
        }
    }
} catch (globalErr) {
    log("Global Error: " + globalErr.message);
}

function initViz(fullData) {
    log("Initializing Visualization...");
    try {
        const width = window.innerWidth;
        const height = window.innerHeight;

        svg = d3.select("svg");
        
        // Clear previous if any
        svg.selectAll("*").remove();
        
        // Defs for arrows
        const defs = svg.append("defs");
        defs.append("marker")
            .attr("id", "arrowhead")
            .attr("refX", 10) /* adjust based on node radius */
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-2.5 L6,0 L0,2.5")
            .style("fill", "#e74c3c");

        g = svg.append("g");

        zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on("zoom", (event) => g.attr("transform", event.transform));

        svg.call(zoom);

        // Define tree layout params
        // nodeSize depends on orientation. 
        // For standard top-down: [width, height]
        // For left-right (projecting y as x): [height, width]
        tree = d3.tree().nodeSize([40, 300]); 

        root = d3.hierarchy(fullData.tree, d => d.children);
        root.x0 = 0;
        root.y0 = 0;

        // Check if root has children
        if (!root.children) {
            log("Warning: Root has no children.");
        } else {
            log("Root children count: " + root.children.length);
        }

        // Collapse
        if(root.children) {
            root.children.forEach(collapseRecursive);
        }

        update(root);
        
        // Initial center
        const initialTransform = d3.zoomIdentity.translate(100, height / 2).scale(1);
        svg.call(zoom.transform, initialTransform);
        
        log("Viz Initialized.");

    } catch (vizErr) {
        log("Viz Error: " + vizErr.message);
        log(vizErr.stack);
    }
}

function collapseRecursive(d) {
  if(d.children) {
    d._children = d.children;
    d.children.forEach(collapseRecursive);
    d.children = null;
  }
}

function expandAll() {
    function recurse(d) {
        if (d._children) {
            d.children = d._children;
            d._children = null;
        }
        if (d.children) d.children.forEach(recurse);
    }
    recurse(root);
    update(root);
}

function collapseAll() {
    if (root.children) root.children.forEach(collapseRecursive);
    update(root);
}

function resetZoom() {
    const height = window.innerHeight;
    svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity.translate(100, height/2).scale(1));
}

function toggleDeps() {
    showDependencies = !showDependencies;
    update(root);
}

function update(source) {
  const treeData = tree(root);

  // Compute the new tree layout.
  const nodes = treeData.descendants();
  const links = treeData.links();

  // Normalize for left-right tree
  // Swap x and y for horizontal layout
  nodes.forEach(d => { d.y = d.depth * 300; });

  // Node Map for calculating dependencies
  const nodeMap = new Map();
  nodes.forEach(d => {
      // Key can be ID or Node Title (fallback)
      if (d.data.metadata && d.data.metadata.id) {
          nodeMap.set(d.data.metadata.id, d);
      }
      // Also map by title for redundancy if needed, but ID is preferred
  });


  // ****************** Links (Hierarchy) ***************************
  const link = g.selectAll('path.link')
      .data(links, d => d.target.id);

  const linkEnter = link.enter().insert('path', "g")
      .attr("class", "link")
      .attr('d', d => {
        const o = {x: source.x0, y: source.y0};
        return diagonal(o, o);
      });

  const linkUpdate = linkEnter.merge(link);

  linkUpdate.transition()
      .duration(duration)
      .attr('d', d => diagonal(d.source, d.target));

  link.exit().transition()
      .duration(duration)
      .attr('d', d => {
        const o = {x: source.x, y: source.y};
        return diagonal(o, o);
      })
      .remove();

  // ****************** Dependency Links (Explicit) ***************************
  // Calculate active dependencies based on current visible nodes
  let depLinksData = [];
  if (showDependencies && parsedData.dependencies) {
      parsedData.dependencies.forEach(dep => {
          const sourceNode = nodeMap.get(dep.source);
          const targetNode = nodeMap.get(dep.target);
          
          if (sourceNode && targetNode) {
              depLinksData.push({source: sourceNode, target: targetNode});
          }
      });
  }

  const depLink = g.selectAll('path.dep-link')
      .data(depLinksData, d => d.source.id + "-" + d.target.id);

  const depLinkEnter = depLink.enter().append('path')
      .attr("class", "dep-link")
      .attr('d', d => {
           // Start from wherever the source is currently (animation) -> usually nice to just fade in or pop in
           // For simplicity, we calculate the curve immediately or use the source position
           return dependencyPath(d.source, d.target);
      })
      .style("opacity", 0);

  depLinkEnter.transition().duration(duration).style("opacity", 0.6);

  depLink.transition().duration(duration)
      .attr('d', d => dependencyPath(d.source, d.target))
      .style("opacity", 0.6);

  depLink.exit().transition().duration(duration).style("opacity", 0).remove();


  // ****************** Nodes ***************************
  const node = g.selectAll('g.node')
      .data(nodes, d => d.id || (d.id = ++i));

  const nodeEnter = node.enter().append('g')
      .attr('class', 'node')
      .attr("transform", d => "translate(" + source.y0 + "," + source.x0 + ")")
      .on('click', click);

  nodeEnter.append('circle')
      .attr('r', 1e-6)
      .attr('class', d => {
          const status = (d.data.metadata && d.data.metadata.status) || 'default';
          return `status-${status.replace(' ', '-')}`;
      });

  nodeEnter.append('text')
      .attr("dy", ".35em")
      .attr("x", d => d.children || d._children ? -13 : 13)
      .attr("text-anchor", d => d.children || d._children ? "end" : "start")
      .text(d => {
          let title = d.data.title;
          return title.length > 30 ? title.substring(0, 30) + '...' : title;
      })
      .style('fill-opacity', 1e-6);

  const nodeUpdate = nodeEnter.merge(node);

  nodeUpdate.transition()
      .duration(duration)
      .attr("transform", d => "translate(" + d.y + "," + d.x + ")");

  nodeUpdate.select('circle')
      .attr('r', 8)
      .style("fill", d => d._children ? "#fff" : "") 
      .attr('class', d => `status-${((d.data.metadata && d.data.metadata.status) || 'default').replace(' ', '-')}`);

  nodeUpdate.select('text').style("fill-opacity", 1);

  const nodeExit = node.exit().transition()
      .duration(duration)
      .attr("transform", d => "translate(" + source.y + "," + source.x + ")")
      .remove();

  nodeExit.select('circle').attr('r', 1e-6);
  nodeExit.select('text').style('fill-opacity', 1e-6);


  nodes.forEach(d => {
    d.x0 = d.x;
    d.y0 = d.y;
  });

  function diagonal(s, d) {
    return `M ${s.y} ${s.x}
            C ${(s.y + d.y) / 2} ${s.x},
              ${(s.y + d.y) / 2} ${d.x},
              ${d.y} ${d.x}`;
  }

  function dependencyPath(s, t) {
      // Custom path for dependencies - larger arc to avoid hierarchy lines?
      // Or just a straightish Bezier
      const dx = t.y - s.y;
      const dy = t.x - s.x;
      const dr = Math.sqrt(dx * dx + dy * dy) * 1.5; // Controls curvature
      
      // Arc path
      return `M${s.y},${s.x}A${dr},${dr} 0 0,1 ${t.y},${t.x}`;
  }

  function click(event, d) {
    showDetails(d.data);
    if (d.children) {
        d._children = d.children;
        d.children = null;
    } else {
        d.children = d._children;
        d._children = null;
    }
    update(d);
  }
}

function showDetails(data) {
    const sidebar = document.getElementById('sidebar');
    const container = document.getElementById('details');
    sidebar.style.display = 'block';

    const status = (data.metadata.status || 'todo').replace(' ', '-');
    
    let metaHtml = '';
    for (const [key, value] of Object.entries(data.metadata)) {
        if (key === 'status') continue;
        metaHtml += `<div><strong>${key}:</strong> ${JSON.stringify(value).replace(/"/g, '')}</div>`;
    }

    container.innerHTML = `
        <span class="meta-tag tag-${status}">${status.toUpperCase().replace('-', ' ')}</span>
        <h2>${data.title}</h2>
        <div style="margin-bottom: 20px; font-size: 0.9em; color: #7f8c8d;">
            ${metaHtml}
        </div>
        <hr style="border: 0; border-top: 1px solid #eee;"/>
        <div class="content-block">
            <pre style="background:none; padding:0; white-space: pre-wrap; font-family: inherit;">${data.content || "No content."}</pre>
        </div>
    `;
}
</script>
</body>
</html>
